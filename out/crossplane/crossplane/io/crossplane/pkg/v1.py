# Generated by cloudcoil-model-codegen v0.5.8
# DO NOT EDIT


from __future__ import annotations

from typing import (
    Annotated,
    Callable,
    Dict,
    List,
    Literal,
    Optional,
    Type,
    overload,
)

from cloudcoil import apimachinery
from cloudcoil.pydantic import (
    BaseModel,
    BaseModelBuilder,
    BuilderContextBase,
    GenericListBuilder,
    ListBuilderContext,
    Never,
    Self,
)
from cloudcoil.resources import Resource
from pydantic import AwareDatetime, Field


class PackagePullSecret(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PackagePullSecret"]:
            return PackagePullSecret

        def build(self) -> "PackagePullSecret":
            return PackagePullSecret(**self._attrs)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            This field is effectively required, but due to backwards compatibility is
            allowed to be empty. Instances of this type with an empty value here are
            almost certainly wrong.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

    class BuilderContext(BuilderContextBase["PackagePullSecret.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PackagePullSecret.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PackagePullSecret."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["PackagePullSecret", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PackagePullSecret.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: Optional[str] = ""
    """
    Name of the referent.
    This field is effectively required, but due to backwards compatibility is
    allowed to be empty. Instances of this type with an empty value here are
    almost certainly wrong.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """


class ConfigurationRevisionSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ConfigurationRevisionSpec"]:
            return ConfigurationRevisionSpec

        def build(self) -> "ConfigurationRevisionSpec":
            return ConfigurationRevisionSpec(**self._attrs)

        def common_labels(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            Map of string keys and values that can be used to organize and categorize
            (scope and select) objects. May match selectors of replication controllers
            and services.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
            """
            return self._set("common_labels", value)

        def desired_state(self, value: str, /) -> Self:
            """
            DesiredState of the PackageRevision. Can be either Active or Inactive.
            """
            return self._set("desired_state", value)

        def ignore_crossplane_constraints(self, value: Optional[bool], /) -> Self:
            """
            IgnoreCrossplaneConstraints indicates to the package manager whether to
            honor Crossplane version constrains specified by the package.
            Default is false.
            """
            return self._set("ignore_crossplane_constraints", value)

        def image(self, value: str, /) -> Self:
            """
            Package image used by install Pod to extract package contents.
            """
            return self._set("image", value)

        def package_pull_policy(self, value: Optional[str], /) -> Self:
            """
            PackagePullPolicy defines the pull policy for the package. It is also
            applied to any images pulled for the package, such as a provider's
            controller image.
            Default is IfNotPresent.
            """
            return self._set("package_pull_policy", value)

        @overload
        def package_pull_secrets(
            self, value_or_callback: List[PackagePullSecret], /
        ) -> "ConfigurationRevisionSpec.Builder": ...

        @overload
        def package_pull_secrets(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[PackagePullSecret, PackagePullSecret.Builder]],
                GenericListBuilder[PackagePullSecret, PackagePullSecret.Builder]
                | List[PackagePullSecret],
            ],
            /,
        ) -> "ConfigurationRevisionSpec.Builder": ...

        @overload
        def package_pull_secrets(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[PackagePullSecret.Builder]: ...

        def package_pull_secrets(self, value_or_callback=None, /):
            """
            PackagePullSecrets are named secrets in the same namespace that can be
            used to fetch packages from private registries. They are also applied to
            any images pulled for the package, such as a provider's controller image.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[PackagePullSecret.Builder]()
                context._parent_builder = self
                context._field_name = "package_pull_secrets"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PackagePullSecret.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("package_pull_secrets", value)

        def revision(self, value: int, /) -> Self:
            """
            Revision number. Indicates when the revision will be garbage collected
            based on the parent's RevisionHistoryLimit.
            """
            return self._set("revision", value)

        def skip_dependency_resolution(self, value: Optional[bool], /) -> Self:
            """
            SkipDependencyResolution indicates to the package manager whether to skip
            resolving dependencies for a package. Setting this value to true may have
            unintended consequences.
            Default is false.
            """
            return self._set("skip_dependency_resolution", value)

    class BuilderContext(BuilderContextBase["ConfigurationRevisionSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ConfigurationRevisionSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ConfigurationRevisionSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ConfigurationRevisionSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ConfigurationRevisionSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    common_labels: Annotated[Optional[Dict[str, str]], Field(alias="commonLabels")] = None
    """
    Map of string keys and values that can be used to organize and categorize
    (scope and select) objects. May match selectors of replication controllers
    and services.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
    """
    desired_state: Annotated[str, Field(alias="desiredState")]
    """
    DesiredState of the PackageRevision. Can be either Active or Inactive.
    """
    ignore_crossplane_constraints: Annotated[
        Optional[bool], Field(alias="ignoreCrossplaneConstraints")
    ] = False
    """
    IgnoreCrossplaneConstraints indicates to the package manager whether to
    honor Crossplane version constrains specified by the package.
    Default is false.
    """
    image: str
    """
    Package image used by install Pod to extract package contents.
    """
    package_pull_policy: Annotated[Optional[str], Field(alias="packagePullPolicy")] = "IfNotPresent"
    """
    PackagePullPolicy defines the pull policy for the package. It is also
    applied to any images pulled for the package, such as a provider's
    controller image.
    Default is IfNotPresent.
    """
    package_pull_secrets: Annotated[
        Optional[List[PackagePullSecret]], Field(alias="packagePullSecrets")
    ] = None
    """
    PackagePullSecrets are named secrets in the same namespace that can be
    used to fetch packages from private registries. They are also applied to
    any images pulled for the package, such as a provider's controller image.
    """
    revision: int
    """
    Revision number. Indicates when the revision will be garbage collected
    based on the parent's RevisionHistoryLimit.
    """
    skip_dependency_resolution: Annotated[
        Optional[bool], Field(alias="skipDependencyResolution")
    ] = False
    """
    SkipDependencyResolution indicates to the package manager whether to skip
    resolving dependencies for a package. Setting this value to true may have
    unintended consequences.
    Default is false.
    """


class AppliedImageConfigRef(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AppliedImageConfigRef"]:
            return AppliedImageConfigRef

        def build(self) -> "AppliedImageConfigRef":
            return AppliedImageConfigRef(**self._attrs)

        def name(self, value: str, /) -> Self:
            """
            Name is the name of the image config.
            """
            return self._set("name", value)

        def reason(self, value: str, /) -> Self:
            """
            Reason indicates what the image config was used for.
            """
            return self._set("reason", value)

    class BuilderContext(BuilderContextBase["AppliedImageConfigRef.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AppliedImageConfigRef.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AppliedImageConfigRef."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AppliedImageConfigRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AppliedImageConfigRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: str
    """
    Name is the name of the image config.
    """
    reason: str
    """
    Reason indicates what the image config was used for.
    """


class Condition(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Condition"]:
            return Condition

        def build(self) -> "Condition":
            return Condition(**self._attrs)

        def last_transition_time(self, value: AwareDatetime, /) -> Self:
            """
            LastTransitionTime is the last time this condition transitioned from one
            status to another.
            """
            return self._set("last_transition_time", value)

        def message(self, value: Optional[str], /) -> Self:
            """
            A Message containing details about this condition's last transition from
            one status to another, if any.
            """
            return self._set("message", value)

        def observed_generation(self, value: Optional[int], /) -> Self:
            """
            ObservedGeneration represents the .metadata.generation that the condition was set based upon.
            For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
            with respect to the current state of the instance.
            """
            return self._set("observed_generation", value)

        def reason(self, value: str, /) -> Self:
            """
            A Reason for this condition's last transition from one status to another.
            """
            return self._set("reason", value)

        def status(self, value: str, /) -> Self:
            """
            Status of this condition; is it currently True, False, or Unknown?
            """
            return self._set("status", value)

        def type(self, value: str, /) -> Self:
            """
            Type of this condition. At most one of each condition type may apply to
            a resource at any point in time.
            """
            return self._set("type", value)

    class BuilderContext(BuilderContextBase["Condition.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Condition.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Condition."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Condition", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Condition.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    last_transition_time: Annotated[AwareDatetime, Field(alias="lastTransitionTime")]
    """
    LastTransitionTime is the last time this condition transitioned from one
    status to another.
    """
    message: Optional[str] = None
    """
    A Message containing details about this condition's last transition from
    one status to another, if any.
    """
    observed_generation: Annotated[Optional[int], Field(alias="observedGeneration")] = None
    """
    ObservedGeneration represents the .metadata.generation that the condition was set based upon.
    For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
    with respect to the current state of the instance.
    """
    reason: str
    """
    A Reason for this condition's last transition from one status to another.
    """
    status: str
    """
    Status of this condition; is it currently True, False, or Unknown?
    """
    type: str
    """
    Type of this condition. At most one of each condition type may apply to
    a resource at any point in time.
    """


class ObjectRef(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ObjectRef"]:
            return ObjectRef

        def build(self) -> "ObjectRef":
            return ObjectRef(**self._attrs)

        def api_version(self, value: str, /) -> Self:
            """
            APIVersion of the referenced object.
            """
            return self._set("api_version", value)

        def kind(self, value: str, /) -> Self:
            """
            Kind of the referenced object.
            """
            return self._set("kind", value)

        def name(self, value: str, /) -> Self:
            """
            Name of the referenced object.
            """
            return self._set("name", value)

        def uid(self, value: Optional[str], /) -> Self:
            """
            UID of the referenced object.
            """
            return self._set("uid", value)

    class BuilderContext(BuilderContextBase["ObjectRef.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ObjectRef.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ObjectRef."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ObjectRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ObjectRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[str, Field(alias="apiVersion")]
    """
    APIVersion of the referenced object.
    """
    kind: str
    """
    Kind of the referenced object.
    """
    name: str
    """
    Name of the referenced object.
    """
    uid: Optional[str] = None
    """
    UID of the referenced object.
    """


class ConfigurationRevisionStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ConfigurationRevisionStatus"]:
            return ConfigurationRevisionStatus

        def build(self) -> "ConfigurationRevisionStatus":
            return ConfigurationRevisionStatus(**self._attrs)

        @overload
        def applied_image_config_refs(
            self, value_or_callback: List[AppliedImageConfigRef], /
        ) -> "ConfigurationRevisionStatus.Builder": ...

        @overload
        def applied_image_config_refs(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[AppliedImageConfigRef, AppliedImageConfigRef.Builder]],
                GenericListBuilder[AppliedImageConfigRef, AppliedImageConfigRef.Builder]
                | List[AppliedImageConfigRef],
            ],
            /,
        ) -> "ConfigurationRevisionStatus.Builder": ...

        @overload
        def applied_image_config_refs(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[AppliedImageConfigRef.Builder]: ...

        def applied_image_config_refs(self, value_or_callback=None, /):
            """
            AppliedImageConfigRefs records any image configs that were applied in
            reconciling this revision, and what they were used for.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[AppliedImageConfigRef.Builder]()
                context._parent_builder = self
                context._field_name = "applied_image_config_refs"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AppliedImageConfigRef.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("applied_image_config_refs", value)

        def capabilities(self, value: Optional[List[str]], /) -> Self:
            """
            Capabilities of this package. Capabilities are opaque strings that
            may be meaningful to package consumers.
            """
            return self._set("capabilities", value)

        @overload
        def conditions(
            self, value_or_callback: List[Condition], /
        ) -> "ConfigurationRevisionStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Condition, Condition.Builder]],
                GenericListBuilder[Condition, Condition.Builder] | List[Condition],
            ],
            /,
        ) -> "ConfigurationRevisionStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            """
            Conditions of the resource.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        def found_dependencies(self, value: Optional[int], /) -> Self:
            """
            Dependency information.
            """
            return self._set("found_dependencies", value)

        def installed_dependencies(self, value: Optional[int], /) -> Self:
            return self._set("installed_dependencies", value)

        def invalid_dependencies(self, value: Optional[int], /) -> Self:
            return self._set("invalid_dependencies", value)

        @overload
        def object_refs(
            self, value_or_callback: List[ObjectRef], /
        ) -> "ConfigurationRevisionStatus.Builder": ...

        @overload
        def object_refs(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[ObjectRef, ObjectRef.Builder]],
                GenericListBuilder[ObjectRef, ObjectRef.Builder] | List[ObjectRef],
            ],
            /,
        ) -> "ConfigurationRevisionStatus.Builder": ...

        @overload
        def object_refs(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ObjectRef.Builder]: ...

        def object_refs(self, value_or_callback=None, /):
            """
            References to objects owned by PackageRevision.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ObjectRef.Builder]()
                context._parent_builder = self
                context._field_name = "object_refs"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ObjectRef.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("object_refs", value)

        def resolved_image(self, value: Optional[str], /) -> Self:
            """
            ResolvedPackage is the name of the package that was installed. It may be
            different from spec.image if the package path was rewritten using an
            image config.
            """
            return self._set("resolved_image", value)

    class BuilderContext(BuilderContextBase["ConfigurationRevisionStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ConfigurationRevisionStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ConfigurationRevisionStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ConfigurationRevisionStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ConfigurationRevisionStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    applied_image_config_refs: Annotated[
        Optional[List[AppliedImageConfigRef]], Field(alias="appliedImageConfigRefs")
    ] = None
    """
    AppliedImageConfigRefs records any image configs that were applied in
    reconciling this revision, and what they were used for.
    """
    capabilities: Optional[List[str]] = None
    """
    Capabilities of this package. Capabilities are opaque strings that
    may be meaningful to package consumers.
    """
    conditions: Optional[List[Condition]] = None
    """
    Conditions of the resource.
    """
    found_dependencies: Annotated[Optional[int], Field(alias="foundDependencies")] = None
    """
    Dependency information.
    """
    installed_dependencies: Annotated[Optional[int], Field(alias="installedDependencies")] = None
    invalid_dependencies: Annotated[Optional[int], Field(alias="invalidDependencies")] = None
    object_refs: Annotated[Optional[List[ObjectRef]], Field(alias="objectRefs")] = None
    """
    References to objects owned by PackageRevision.
    """
    resolved_image: Annotated[Optional[str], Field(alias="resolvedImage")] = None
    """
    ResolvedPackage is the name of the package that was installed. It may be
    different from spec.image if the package path was rewritten using an
    image config.
    """


class ConfigurationSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ConfigurationSpec"]:
            return ConfigurationSpec

        def build(self) -> "ConfigurationSpec":
            return ConfigurationSpec(**self._attrs)

        def common_labels(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            Map of string keys and values that can be used to organize and categorize
            (scope and select) objects. May match selectors of replication controllers
            and services.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
            """
            return self._set("common_labels", value)

        def ignore_crossplane_constraints(self, value: Optional[bool], /) -> Self:
            """
            IgnoreCrossplaneConstraints indicates to the package manager whether to
            honor Crossplane version constrains specified by the package.
            Default is false.
            """
            return self._set("ignore_crossplane_constraints", value)

        def package(self, value: str, /) -> Self:
            """
            Package is the name of the package that is being requested.
            must be a fully qualified image name, including the registry,
            repository, and tag. for example, "registry.example.com/repo/package:tag".
            """
            return self._set("package", value)

        def package_pull_policy(self, value: Optional[str], /) -> Self:
            """
            PackagePullPolicy defines the pull policy for the package.
            Default is IfNotPresent.
            """
            return self._set("package_pull_policy", value)

        @overload
        def package_pull_secrets(
            self, value_or_callback: List[PackagePullSecret], /
        ) -> "ConfigurationSpec.Builder": ...

        @overload
        def package_pull_secrets(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[PackagePullSecret, PackagePullSecret.Builder]],
                GenericListBuilder[PackagePullSecret, PackagePullSecret.Builder]
                | List[PackagePullSecret],
            ],
            /,
        ) -> "ConfigurationSpec.Builder": ...

        @overload
        def package_pull_secrets(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[PackagePullSecret.Builder]: ...

        def package_pull_secrets(self, value_or_callback=None, /):
            """
            PackagePullSecrets are named secrets in the same namespace that can be used
            to fetch packages from private registries.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[PackagePullSecret.Builder]()
                context._parent_builder = self
                context._field_name = "package_pull_secrets"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PackagePullSecret.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("package_pull_secrets", value)

        def revision_activation_policy(self, value: Optional[str], /) -> Self:
            """
            RevisionActivationPolicy specifies how the package controller should
            update from one revision to the next. Options are Automatic or Manual.
            Default is Automatic.
            """
            return self._set("revision_activation_policy", value)

        def revision_history_limit(self, value: Optional[int], /) -> Self:
            """
            RevisionHistoryLimit dictates how the package controller cleans up old
            inactive package revisions.
            Defaults to 1. Can be disabled by explicitly setting to 0.
            """
            return self._set("revision_history_limit", value)

        def skip_dependency_resolution(self, value: Optional[bool], /) -> Self:
            """
            SkipDependencyResolution indicates to the package manager whether to skip
            resolving dependencies for a package. Setting this value to true may have
            unintended consequences.
            Default is false.
            """
            return self._set("skip_dependency_resolution", value)

    class BuilderContext(BuilderContextBase["ConfigurationSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ConfigurationSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ConfigurationSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ConfigurationSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ConfigurationSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    common_labels: Annotated[Optional[Dict[str, str]], Field(alias="commonLabels")] = None
    """
    Map of string keys and values that can be used to organize and categorize
    (scope and select) objects. May match selectors of replication controllers
    and services.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
    """
    ignore_crossplane_constraints: Annotated[
        Optional[bool], Field(alias="ignoreCrossplaneConstraints")
    ] = False
    """
    IgnoreCrossplaneConstraints indicates to the package manager whether to
    honor Crossplane version constrains specified by the package.
    Default is false.
    """
    package: str
    """
    Package is the name of the package that is being requested.
    must be a fully qualified image name, including the registry,
    repository, and tag. for example, "registry.example.com/repo/package:tag".
    """
    package_pull_policy: Annotated[Optional[str], Field(alias="packagePullPolicy")] = "IfNotPresent"
    """
    PackagePullPolicy defines the pull policy for the package.
    Default is IfNotPresent.
    """
    package_pull_secrets: Annotated[
        Optional[List[PackagePullSecret]], Field(alias="packagePullSecrets")
    ] = None
    """
    PackagePullSecrets are named secrets in the same namespace that can be used
    to fetch packages from private registries.
    """
    revision_activation_policy: Annotated[
        Optional[str], Field(alias="revisionActivationPolicy")
    ] = "Automatic"
    """
    RevisionActivationPolicy specifies how the package controller should
    update from one revision to the next. Options are Automatic or Manual.
    Default is Automatic.
    """
    revision_history_limit: Annotated[Optional[int], Field(alias="revisionHistoryLimit")] = 1
    """
    RevisionHistoryLimit dictates how the package controller cleans up old
    inactive package revisions.
    Defaults to 1. Can be disabled by explicitly setting to 0.
    """
    skip_dependency_resolution: Annotated[
        Optional[bool], Field(alias="skipDependencyResolution")
    ] = False
    """
    SkipDependencyResolution indicates to the package manager whether to skip
    resolving dependencies for a package. Setting this value to true may have
    unintended consequences.
    Default is false.
    """


class ConfigurationStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ConfigurationStatus"]:
            return ConfigurationStatus

        def build(self) -> "ConfigurationStatus":
            return ConfigurationStatus(**self._attrs)

        @overload
        def applied_image_config_refs(
            self, value_or_callback: List[AppliedImageConfigRef], /
        ) -> "ConfigurationStatus.Builder": ...

        @overload
        def applied_image_config_refs(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[AppliedImageConfigRef, AppliedImageConfigRef.Builder]],
                GenericListBuilder[AppliedImageConfigRef, AppliedImageConfigRef.Builder]
                | List[AppliedImageConfigRef],
            ],
            /,
        ) -> "ConfigurationStatus.Builder": ...

        @overload
        def applied_image_config_refs(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[AppliedImageConfigRef.Builder]: ...

        def applied_image_config_refs(self, value_or_callback=None, /):
            """
            AppliedImageConfigRefs records any image configs that were applied in
            reconciling this package, and what they were used for.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[AppliedImageConfigRef.Builder]()
                context._parent_builder = self
                context._field_name = "applied_image_config_refs"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AppliedImageConfigRef.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("applied_image_config_refs", value)

        @overload
        def conditions(
            self, value_or_callback: List[Condition], /
        ) -> "ConfigurationStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Condition, Condition.Builder]],
                GenericListBuilder[Condition, Condition.Builder] | List[Condition],
            ],
            /,
        ) -> "ConfigurationStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            """
            Conditions of the resource.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        def current_identifier(self, value: Optional[str], /) -> Self:
            """
            CurrentIdentifier is the most recent package source that was used to
            produce a revision. The package manager uses this field to determine
            whether to check for package updates for a given source when
            packagePullPolicy is set to IfNotPresent. Manually removing this field
            will cause the package manager to check that the current revision is
            correct for the given package source.
            """
            return self._set("current_identifier", value)

        def current_revision(self, value: Optional[str], /) -> Self:
            """
            CurrentRevision is the name of the current package revision. It will
            reflect the most up to date revision, whether it has been activated or
            not.
            """
            return self._set("current_revision", value)

        def resolved_package(self, value: Optional[str], /) -> Self:
            """
            ResolvedPackage is the name of the package that was used for version
            resolution. It may be different from spec.package if the package path was
            rewritten using an image config.
            """
            return self._set("resolved_package", value)

    class BuilderContext(BuilderContextBase["ConfigurationStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ConfigurationStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ConfigurationStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ConfigurationStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ConfigurationStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    applied_image_config_refs: Annotated[
        Optional[List[AppliedImageConfigRef]], Field(alias="appliedImageConfigRefs")
    ] = None
    """
    AppliedImageConfigRefs records any image configs that were applied in
    reconciling this package, and what they were used for.
    """
    conditions: Optional[List[Condition]] = None
    """
    Conditions of the resource.
    """
    current_identifier: Annotated[Optional[str], Field(alias="currentIdentifier")] = None
    """
    CurrentIdentifier is the most recent package source that was used to
    produce a revision. The package manager uses this field to determine
    whether to check for package updates for a given source when
    packagePullPolicy is set to IfNotPresent. Manually removing this field
    will cause the package manager to check that the current revision is
    correct for the given package source.
    """
    current_revision: Annotated[Optional[str], Field(alias="currentRevision")] = None
    """
    CurrentRevision is the name of the current package revision. It will
    reflect the most up to date revision, whether it has been activated or
    not.
    """
    resolved_package: Annotated[Optional[str], Field(alias="resolvedPackage")] = None
    """
    ResolvedPackage is the name of the package that was used for version
    resolution. It may be different from spec.package if the package path was
    rewritten using an image config.
    """


class RuntimeConfigRef(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["RuntimeConfigRef"]:
            return RuntimeConfigRef

        def build(self) -> "RuntimeConfigRef":
            return RuntimeConfigRef(**self._attrs)

        def api_version(self, value: Optional[str], /) -> Self:
            """
            API version of the referent.
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[str], /) -> Self:
            """
            Kind of the referent.
            """
            return self._set("kind", value)

        def name(self, value: str, /) -> Self:
            """
            Name of the RuntimeConfig.
            """
            return self._set("name", value)

    class BuilderContext(BuilderContextBase["RuntimeConfigRef.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = RuntimeConfigRef.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RuntimeConfigRef."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["RuntimeConfigRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use RuntimeConfigRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[str], Field(alias="apiVersion")] = "pkg.crossplane.io/v1beta1"
    """
    API version of the referent.
    """
    kind: Optional[str] = "DeploymentRuntimeConfig"
    """
    Kind of the referent.
    """
    name: str
    """
    Name of the RuntimeConfig.
    """


class FunctionRevisionSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["FunctionRevisionSpec"]:
            return FunctionRevisionSpec

        def build(self) -> "FunctionRevisionSpec":
            return FunctionRevisionSpec(**self._attrs)

        def common_labels(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            Map of string keys and values that can be used to organize and categorize
            (scope and select) objects. May match selectors of replication controllers
            and services.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
            """
            return self._set("common_labels", value)

        def desired_state(self, value: str, /) -> Self:
            """
            DesiredState of the PackageRevision. Can be either Active or Inactive.
            """
            return self._set("desired_state", value)

        def ignore_crossplane_constraints(self, value: Optional[bool], /) -> Self:
            """
            IgnoreCrossplaneConstraints indicates to the package manager whether to
            honor Crossplane version constrains specified by the package.
            Default is false.
            """
            return self._set("ignore_crossplane_constraints", value)

        def image(self, value: str, /) -> Self:
            """
            Package image used by install Pod to extract package contents.
            """
            return self._set("image", value)

        def package_pull_policy(self, value: Optional[str], /) -> Self:
            """
            PackagePullPolicy defines the pull policy for the package. It is also
            applied to any images pulled for the package, such as a provider's
            controller image.
            Default is IfNotPresent.
            """
            return self._set("package_pull_policy", value)

        @overload
        def package_pull_secrets(
            self, value_or_callback: List[PackagePullSecret], /
        ) -> "FunctionRevisionSpec.Builder": ...

        @overload
        def package_pull_secrets(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[PackagePullSecret, PackagePullSecret.Builder]],
                GenericListBuilder[PackagePullSecret, PackagePullSecret.Builder]
                | List[PackagePullSecret],
            ],
            /,
        ) -> "FunctionRevisionSpec.Builder": ...

        @overload
        def package_pull_secrets(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[PackagePullSecret.Builder]: ...

        def package_pull_secrets(self, value_or_callback=None, /):
            """
            PackagePullSecrets are named secrets in the same namespace that can be
            used to fetch packages from private registries. They are also applied to
            any images pulled for the package, such as a provider's controller image.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[PackagePullSecret.Builder]()
                context._parent_builder = self
                context._field_name = "package_pull_secrets"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PackagePullSecret.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("package_pull_secrets", value)

        def revision(self, value: int, /) -> Self:
            """
            Revision number. Indicates when the revision will be garbage collected
            based on the parent's RevisionHistoryLimit.
            """
            return self._set("revision", value)

        @overload
        def runtime_config_ref(
            self, value_or_callback: Optional[RuntimeConfigRef], /
        ) -> "FunctionRevisionSpec.Builder": ...

        @overload
        def runtime_config_ref(
            self,
            value_or_callback: Callable[
                [RuntimeConfigRef.Builder], RuntimeConfigRef.Builder | RuntimeConfigRef
            ],
            /,
        ) -> "FunctionRevisionSpec.Builder": ...

        @overload
        def runtime_config_ref(
            self, value_or_callback: Never = ...
        ) -> "RuntimeConfigRef.BuilderContext": ...

        def runtime_config_ref(self, value_or_callback=None, /):
            """
            RuntimeConfigRef references a RuntimeConfig resource that will be used
            to configure the package runtime.
            """
            if self._in_context and value_or_callback is None:
                context = RuntimeConfigRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "runtime_config_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(RuntimeConfigRef.builder())
                if isinstance(output, RuntimeConfigRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("runtime_config_ref", value)

        def skip_dependency_resolution(self, value: Optional[bool], /) -> Self:
            """
            SkipDependencyResolution indicates to the package manager whether to skip
            resolving dependencies for a package. Setting this value to true may have
            unintended consequences.
            Default is false.
            """
            return self._set("skip_dependency_resolution", value)

        def tls_client_secret_name(self, value: Optional[str], /) -> Self:
            """
            TLSClientSecretName is the name of the TLS Secret that stores client
            certificates of the Provider.
            """
            return self._set("tls_client_secret_name", value)

        def tls_server_secret_name(self, value: Optional[str], /) -> Self:
            """
            TLSServerSecretName is the name of the TLS Secret that stores server
            certificates of the Provider.
            """
            return self._set("tls_server_secret_name", value)

    class BuilderContext(BuilderContextBase["FunctionRevisionSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = FunctionRevisionSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for FunctionRevisionSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["FunctionRevisionSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use FunctionRevisionSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    common_labels: Annotated[Optional[Dict[str, str]], Field(alias="commonLabels")] = None
    """
    Map of string keys and values that can be used to organize and categorize
    (scope and select) objects. May match selectors of replication controllers
    and services.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
    """
    desired_state: Annotated[str, Field(alias="desiredState")]
    """
    DesiredState of the PackageRevision. Can be either Active or Inactive.
    """
    ignore_crossplane_constraints: Annotated[
        Optional[bool], Field(alias="ignoreCrossplaneConstraints")
    ] = False
    """
    IgnoreCrossplaneConstraints indicates to the package manager whether to
    honor Crossplane version constrains specified by the package.
    Default is false.
    """
    image: str
    """
    Package image used by install Pod to extract package contents.
    """
    package_pull_policy: Annotated[Optional[str], Field(alias="packagePullPolicy")] = "IfNotPresent"
    """
    PackagePullPolicy defines the pull policy for the package. It is also
    applied to any images pulled for the package, such as a provider's
    controller image.
    Default is IfNotPresent.
    """
    package_pull_secrets: Annotated[
        Optional[List[PackagePullSecret]], Field(alias="packagePullSecrets")
    ] = None
    """
    PackagePullSecrets are named secrets in the same namespace that can be
    used to fetch packages from private registries. They are also applied to
    any images pulled for the package, such as a provider's controller image.
    """
    revision: int
    """
    Revision number. Indicates when the revision will be garbage collected
    based on the parent's RevisionHistoryLimit.
    """
    runtime_config_ref: Annotated[
        Optional[RuntimeConfigRef],
        Field(
            default_factory=lambda: RuntimeConfigRef.model_validate({"name": "default"}),
            alias="runtimeConfigRef",
        ),
    ] = {"name": "default"}
    """
    RuntimeConfigRef references a RuntimeConfig resource that will be used
    to configure the package runtime.
    """
    skip_dependency_resolution: Annotated[
        Optional[bool], Field(alias="skipDependencyResolution")
    ] = False
    """
    SkipDependencyResolution indicates to the package manager whether to skip
    resolving dependencies for a package. Setting this value to true may have
    unintended consequences.
    Default is false.
    """
    tls_client_secret_name: Annotated[Optional[str], Field(alias="tlsClientSecretName")] = None
    """
    TLSClientSecretName is the name of the TLS Secret that stores client
    certificates of the Provider.
    """
    tls_server_secret_name: Annotated[Optional[str], Field(alias="tlsServerSecretName")] = None
    """
    TLSServerSecretName is the name of the TLS Secret that stores server
    certificates of the Provider.
    """


class FunctionRevisionStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["FunctionRevisionStatus"]:
            return FunctionRevisionStatus

        def build(self) -> "FunctionRevisionStatus":
            return FunctionRevisionStatus(**self._attrs)

        @overload
        def applied_image_config_refs(
            self, value_or_callback: List[AppliedImageConfigRef], /
        ) -> "FunctionRevisionStatus.Builder": ...

        @overload
        def applied_image_config_refs(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[AppliedImageConfigRef, AppliedImageConfigRef.Builder]],
                GenericListBuilder[AppliedImageConfigRef, AppliedImageConfigRef.Builder]
                | List[AppliedImageConfigRef],
            ],
            /,
        ) -> "FunctionRevisionStatus.Builder": ...

        @overload
        def applied_image_config_refs(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[AppliedImageConfigRef.Builder]: ...

        def applied_image_config_refs(self, value_or_callback=None, /):
            """
            AppliedImageConfigRefs records any image configs that were applied in
            reconciling this revision, and what they were used for.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[AppliedImageConfigRef.Builder]()
                context._parent_builder = self
                context._field_name = "applied_image_config_refs"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AppliedImageConfigRef.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("applied_image_config_refs", value)

        def capabilities(self, value: Optional[List[str]], /) -> Self:
            """
            Capabilities of this package. Capabilities are opaque strings that
            may be meaningful to package consumers.
            """
            return self._set("capabilities", value)

        @overload
        def conditions(
            self, value_or_callback: List[Condition], /
        ) -> "FunctionRevisionStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Condition, Condition.Builder]],
                GenericListBuilder[Condition, Condition.Builder] | List[Condition],
            ],
            /,
        ) -> "FunctionRevisionStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            """
            Conditions of the resource.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        def endpoint(self, value: Optional[str], /) -> Self:
            """
            Endpoint is the gRPC endpoint where Crossplane will send
            RunFunctionRequests.
            """
            return self._set("endpoint", value)

        def found_dependencies(self, value: Optional[int], /) -> Self:
            """
            Dependency information.
            """
            return self._set("found_dependencies", value)

        def installed_dependencies(self, value: Optional[int], /) -> Self:
            return self._set("installed_dependencies", value)

        def invalid_dependencies(self, value: Optional[int], /) -> Self:
            return self._set("invalid_dependencies", value)

        @overload
        def object_refs(
            self, value_or_callback: List[ObjectRef], /
        ) -> "FunctionRevisionStatus.Builder": ...

        @overload
        def object_refs(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[ObjectRef, ObjectRef.Builder]],
                GenericListBuilder[ObjectRef, ObjectRef.Builder] | List[ObjectRef],
            ],
            /,
        ) -> "FunctionRevisionStatus.Builder": ...

        @overload
        def object_refs(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ObjectRef.Builder]: ...

        def object_refs(self, value_or_callback=None, /):
            """
            References to objects owned by PackageRevision.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ObjectRef.Builder]()
                context._parent_builder = self
                context._field_name = "object_refs"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ObjectRef.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("object_refs", value)

        def resolved_image(self, value: Optional[str], /) -> Self:
            """
            ResolvedPackage is the name of the package that was installed. It may be
            different from spec.image if the package path was rewritten using an
            image config.
            """
            return self._set("resolved_image", value)

        def tls_client_secret_name(self, value: Optional[str], /) -> Self:
            """
            TLSClientSecretName is the name of the TLS Secret that stores client
            certificates of the Provider.
            """
            return self._set("tls_client_secret_name", value)

        def tls_server_secret_name(self, value: Optional[str], /) -> Self:
            """
            TLSServerSecretName is the name of the TLS Secret that stores server
            certificates of the Provider.
            """
            return self._set("tls_server_secret_name", value)

    class BuilderContext(BuilderContextBase["FunctionRevisionStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = FunctionRevisionStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for FunctionRevisionStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["FunctionRevisionStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use FunctionRevisionStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    applied_image_config_refs: Annotated[
        Optional[List[AppliedImageConfigRef]], Field(alias="appliedImageConfigRefs")
    ] = None
    """
    AppliedImageConfigRefs records any image configs that were applied in
    reconciling this revision, and what they were used for.
    """
    capabilities: Optional[List[str]] = None
    """
    Capabilities of this package. Capabilities are opaque strings that
    may be meaningful to package consumers.
    """
    conditions: Optional[List[Condition]] = None
    """
    Conditions of the resource.
    """
    endpoint: Optional[str] = None
    """
    Endpoint is the gRPC endpoint where Crossplane will send
    RunFunctionRequests.
    """
    found_dependencies: Annotated[Optional[int], Field(alias="foundDependencies")] = None
    """
    Dependency information.
    """
    installed_dependencies: Annotated[Optional[int], Field(alias="installedDependencies")] = None
    invalid_dependencies: Annotated[Optional[int], Field(alias="invalidDependencies")] = None
    object_refs: Annotated[Optional[List[ObjectRef]], Field(alias="objectRefs")] = None
    """
    References to objects owned by PackageRevision.
    """
    resolved_image: Annotated[Optional[str], Field(alias="resolvedImage")] = None
    """
    ResolvedPackage is the name of the package that was installed. It may be
    different from spec.image if the package path was rewritten using an
    image config.
    """
    tls_client_secret_name: Annotated[Optional[str], Field(alias="tlsClientSecretName")] = None
    """
    TLSClientSecretName is the name of the TLS Secret that stores client
    certificates of the Provider.
    """
    tls_server_secret_name: Annotated[Optional[str], Field(alias="tlsServerSecretName")] = None
    """
    TLSServerSecretName is the name of the TLS Secret that stores server
    certificates of the Provider.
    """


class FunctionSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["FunctionSpec"]:
            return FunctionSpec

        def build(self) -> "FunctionSpec":
            return FunctionSpec(**self._attrs)

        def common_labels(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            Map of string keys and values that can be used to organize and categorize
            (scope and select) objects. May match selectors of replication controllers
            and services.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
            """
            return self._set("common_labels", value)

        def ignore_crossplane_constraints(self, value: Optional[bool], /) -> Self:
            """
            IgnoreCrossplaneConstraints indicates to the package manager whether to
            honor Crossplane version constrains specified by the package.
            Default is false.
            """
            return self._set("ignore_crossplane_constraints", value)

        def package(self, value: str, /) -> Self:
            """
            Package is the name of the package that is being requested.
            must be a fully qualified image name, including the registry,
            repository, and tag. for example, "registry.example.com/repo/package:tag".
            """
            return self._set("package", value)

        def package_pull_policy(self, value: Optional[str], /) -> Self:
            """
            PackagePullPolicy defines the pull policy for the package.
            Default is IfNotPresent.
            """
            return self._set("package_pull_policy", value)

        @overload
        def package_pull_secrets(
            self, value_or_callback: List[PackagePullSecret], /
        ) -> "FunctionSpec.Builder": ...

        @overload
        def package_pull_secrets(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[PackagePullSecret, PackagePullSecret.Builder]],
                GenericListBuilder[PackagePullSecret, PackagePullSecret.Builder]
                | List[PackagePullSecret],
            ],
            /,
        ) -> "FunctionSpec.Builder": ...

        @overload
        def package_pull_secrets(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[PackagePullSecret.Builder]: ...

        def package_pull_secrets(self, value_or_callback=None, /):
            """
            PackagePullSecrets are named secrets in the same namespace that can be used
            to fetch packages from private registries.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[PackagePullSecret.Builder]()
                context._parent_builder = self
                context._field_name = "package_pull_secrets"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PackagePullSecret.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("package_pull_secrets", value)

        def revision_activation_policy(self, value: Optional[str], /) -> Self:
            """
            RevisionActivationPolicy specifies how the package controller should
            update from one revision to the next. Options are Automatic or Manual.
            Default is Automatic.
            """
            return self._set("revision_activation_policy", value)

        def revision_history_limit(self, value: Optional[int], /) -> Self:
            """
            RevisionHistoryLimit dictates how the package controller cleans up old
            inactive package revisions.
            Defaults to 1. Can be disabled by explicitly setting to 0.
            """
            return self._set("revision_history_limit", value)

        @overload
        def runtime_config_ref(
            self, value_or_callback: Optional[RuntimeConfigRef], /
        ) -> "FunctionSpec.Builder": ...

        @overload
        def runtime_config_ref(
            self,
            value_or_callback: Callable[
                [RuntimeConfigRef.Builder], RuntimeConfigRef.Builder | RuntimeConfigRef
            ],
            /,
        ) -> "FunctionSpec.Builder": ...

        @overload
        def runtime_config_ref(
            self, value_or_callback: Never = ...
        ) -> "RuntimeConfigRef.BuilderContext": ...

        def runtime_config_ref(self, value_or_callback=None, /):
            """
            RuntimeConfigRef references a RuntimeConfig resource that will be used
            to configure the package runtime.
            """
            if self._in_context and value_or_callback is None:
                context = RuntimeConfigRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "runtime_config_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(RuntimeConfigRef.builder())
                if isinstance(output, RuntimeConfigRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("runtime_config_ref", value)

        def skip_dependency_resolution(self, value: Optional[bool], /) -> Self:
            """
            SkipDependencyResolution indicates to the package manager whether to skip
            resolving dependencies for a package. Setting this value to true may have
            unintended consequences.
            Default is false.
            """
            return self._set("skip_dependency_resolution", value)

    class BuilderContext(BuilderContextBase["FunctionSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = FunctionSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for FunctionSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["FunctionSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use FunctionSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    common_labels: Annotated[Optional[Dict[str, str]], Field(alias="commonLabels")] = None
    """
    Map of string keys and values that can be used to organize and categorize
    (scope and select) objects. May match selectors of replication controllers
    and services.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
    """
    ignore_crossplane_constraints: Annotated[
        Optional[bool], Field(alias="ignoreCrossplaneConstraints")
    ] = False
    """
    IgnoreCrossplaneConstraints indicates to the package manager whether to
    honor Crossplane version constrains specified by the package.
    Default is false.
    """
    package: str
    """
    Package is the name of the package that is being requested.
    must be a fully qualified image name, including the registry,
    repository, and tag. for example, "registry.example.com/repo/package:tag".
    """
    package_pull_policy: Annotated[Optional[str], Field(alias="packagePullPolicy")] = "IfNotPresent"
    """
    PackagePullPolicy defines the pull policy for the package.
    Default is IfNotPresent.
    """
    package_pull_secrets: Annotated[
        Optional[List[PackagePullSecret]], Field(alias="packagePullSecrets")
    ] = None
    """
    PackagePullSecrets are named secrets in the same namespace that can be used
    to fetch packages from private registries.
    """
    revision_activation_policy: Annotated[
        Optional[str], Field(alias="revisionActivationPolicy")
    ] = "Automatic"
    """
    RevisionActivationPolicy specifies how the package controller should
    update from one revision to the next. Options are Automatic or Manual.
    Default is Automatic.
    """
    revision_history_limit: Annotated[Optional[int], Field(alias="revisionHistoryLimit")] = 1
    """
    RevisionHistoryLimit dictates how the package controller cleans up old
    inactive package revisions.
    Defaults to 1. Can be disabled by explicitly setting to 0.
    """
    runtime_config_ref: Annotated[
        Optional[RuntimeConfigRef],
        Field(
            default_factory=lambda: RuntimeConfigRef.model_validate({"name": "default"}),
            alias="runtimeConfigRef",
        ),
    ] = {"name": "default"}
    """
    RuntimeConfigRef references a RuntimeConfig resource that will be used
    to configure the package runtime.
    """
    skip_dependency_resolution: Annotated[
        Optional[bool], Field(alias="skipDependencyResolution")
    ] = False
    """
    SkipDependencyResolution indicates to the package manager whether to skip
    resolving dependencies for a package. Setting this value to true may have
    unintended consequences.
    Default is false.
    """


class FunctionStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["FunctionStatus"]:
            return FunctionStatus

        def build(self) -> "FunctionStatus":
            return FunctionStatus(**self._attrs)

        @overload
        def applied_image_config_refs(
            self, value_or_callback: List[AppliedImageConfigRef], /
        ) -> "FunctionStatus.Builder": ...

        @overload
        def applied_image_config_refs(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[AppliedImageConfigRef, AppliedImageConfigRef.Builder]],
                GenericListBuilder[AppliedImageConfigRef, AppliedImageConfigRef.Builder]
                | List[AppliedImageConfigRef],
            ],
            /,
        ) -> "FunctionStatus.Builder": ...

        @overload
        def applied_image_config_refs(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[AppliedImageConfigRef.Builder]: ...

        def applied_image_config_refs(self, value_or_callback=None, /):
            """
            AppliedImageConfigRefs records any image configs that were applied in
            reconciling this package, and what they were used for.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[AppliedImageConfigRef.Builder]()
                context._parent_builder = self
                context._field_name = "applied_image_config_refs"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AppliedImageConfigRef.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("applied_image_config_refs", value)

        @overload
        def conditions(self, value_or_callback: List[Condition], /) -> "FunctionStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Condition, Condition.Builder]],
                GenericListBuilder[Condition, Condition.Builder] | List[Condition],
            ],
            /,
        ) -> "FunctionStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            """
            Conditions of the resource.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        def current_identifier(self, value: Optional[str], /) -> Self:
            """
            CurrentIdentifier is the most recent package source that was used to
            produce a revision. The package manager uses this field to determine
            whether to check for package updates for a given source when
            packagePullPolicy is set to IfNotPresent. Manually removing this field
            will cause the package manager to check that the current revision is
            correct for the given package source.
            """
            return self._set("current_identifier", value)

        def current_revision(self, value: Optional[str], /) -> Self:
            """
            CurrentRevision is the name of the current package revision. It will
            reflect the most up to date revision, whether it has been activated or
            not.
            """
            return self._set("current_revision", value)

        def resolved_package(self, value: Optional[str], /) -> Self:
            """
            ResolvedPackage is the name of the package that was used for version
            resolution. It may be different from spec.package if the package path was
            rewritten using an image config.
            """
            return self._set("resolved_package", value)

    class BuilderContext(BuilderContextBase["FunctionStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = FunctionStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for FunctionStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["FunctionStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use FunctionStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    applied_image_config_refs: Annotated[
        Optional[List[AppliedImageConfigRef]], Field(alias="appliedImageConfigRefs")
    ] = None
    """
    AppliedImageConfigRefs records any image configs that were applied in
    reconciling this package, and what they were used for.
    """
    conditions: Optional[List[Condition]] = None
    """
    Conditions of the resource.
    """
    current_identifier: Annotated[Optional[str], Field(alias="currentIdentifier")] = None
    """
    CurrentIdentifier is the most recent package source that was used to
    produce a revision. The package manager uses this field to determine
    whether to check for package updates for a given source when
    packagePullPolicy is set to IfNotPresent. Manually removing this field
    will cause the package manager to check that the current revision is
    correct for the given package source.
    """
    current_revision: Annotated[Optional[str], Field(alias="currentRevision")] = None
    """
    CurrentRevision is the name of the current package revision. It will
    reflect the most up to date revision, whether it has been activated or
    not.
    """
    resolved_package: Annotated[Optional[str], Field(alias="resolvedPackage")] = None
    """
    ResolvedPackage is the name of the package that was used for version
    resolution. It may be different from spec.package if the package path was
    rewritten using an image config.
    """


class ProviderRevisionSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ProviderRevisionSpec"]:
            return ProviderRevisionSpec

        def build(self) -> "ProviderRevisionSpec":
            return ProviderRevisionSpec(**self._attrs)

        def common_labels(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            Map of string keys and values that can be used to organize and categorize
            (scope and select) objects. May match selectors of replication controllers
            and services.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
            """
            return self._set("common_labels", value)

        def desired_state(self, value: str, /) -> Self:
            """
            DesiredState of the PackageRevision. Can be either Active or Inactive.
            """
            return self._set("desired_state", value)

        def ignore_crossplane_constraints(self, value: Optional[bool], /) -> Self:
            """
            IgnoreCrossplaneConstraints indicates to the package manager whether to
            honor Crossplane version constrains specified by the package.
            Default is false.
            """
            return self._set("ignore_crossplane_constraints", value)

        def image(self, value: str, /) -> Self:
            """
            Package image used by install Pod to extract package contents.
            """
            return self._set("image", value)

        def package_pull_policy(self, value: Optional[str], /) -> Self:
            """
            PackagePullPolicy defines the pull policy for the package. It is also
            applied to any images pulled for the package, such as a provider's
            controller image.
            Default is IfNotPresent.
            """
            return self._set("package_pull_policy", value)

        @overload
        def package_pull_secrets(
            self, value_or_callback: List[PackagePullSecret], /
        ) -> "ProviderRevisionSpec.Builder": ...

        @overload
        def package_pull_secrets(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[PackagePullSecret, PackagePullSecret.Builder]],
                GenericListBuilder[PackagePullSecret, PackagePullSecret.Builder]
                | List[PackagePullSecret],
            ],
            /,
        ) -> "ProviderRevisionSpec.Builder": ...

        @overload
        def package_pull_secrets(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[PackagePullSecret.Builder]: ...

        def package_pull_secrets(self, value_or_callback=None, /):
            """
            PackagePullSecrets are named secrets in the same namespace that can be
            used to fetch packages from private registries. They are also applied to
            any images pulled for the package, such as a provider's controller image.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[PackagePullSecret.Builder]()
                context._parent_builder = self
                context._field_name = "package_pull_secrets"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PackagePullSecret.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("package_pull_secrets", value)

        def revision(self, value: int, /) -> Self:
            """
            Revision number. Indicates when the revision will be garbage collected
            based on the parent's RevisionHistoryLimit.
            """
            return self._set("revision", value)

        @overload
        def runtime_config_ref(
            self, value_or_callback: Optional[RuntimeConfigRef], /
        ) -> "ProviderRevisionSpec.Builder": ...

        @overload
        def runtime_config_ref(
            self,
            value_or_callback: Callable[
                [RuntimeConfigRef.Builder], RuntimeConfigRef.Builder | RuntimeConfigRef
            ],
            /,
        ) -> "ProviderRevisionSpec.Builder": ...

        @overload
        def runtime_config_ref(
            self, value_or_callback: Never = ...
        ) -> "RuntimeConfigRef.BuilderContext": ...

        def runtime_config_ref(self, value_or_callback=None, /):
            """
            RuntimeConfigRef references a RuntimeConfig resource that will be used
            to configure the package runtime.
            """
            if self._in_context and value_or_callback is None:
                context = RuntimeConfigRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "runtime_config_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(RuntimeConfigRef.builder())
                if isinstance(output, RuntimeConfigRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("runtime_config_ref", value)

        def skip_dependency_resolution(self, value: Optional[bool], /) -> Self:
            """
            SkipDependencyResolution indicates to the package manager whether to skip
            resolving dependencies for a package. Setting this value to true may have
            unintended consequences.
            Default is false.
            """
            return self._set("skip_dependency_resolution", value)

        def tls_client_secret_name(self, value: Optional[str], /) -> Self:
            """
            TLSClientSecretName is the name of the TLS Secret that stores client
            certificates of the Provider.
            """
            return self._set("tls_client_secret_name", value)

        def tls_server_secret_name(self, value: Optional[str], /) -> Self:
            """
            TLSServerSecretName is the name of the TLS Secret that stores server
            certificates of the Provider.
            """
            return self._set("tls_server_secret_name", value)

    class BuilderContext(BuilderContextBase["ProviderRevisionSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ProviderRevisionSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ProviderRevisionSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ProviderRevisionSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ProviderRevisionSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    common_labels: Annotated[Optional[Dict[str, str]], Field(alias="commonLabels")] = None
    """
    Map of string keys and values that can be used to organize and categorize
    (scope and select) objects. May match selectors of replication controllers
    and services.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
    """
    desired_state: Annotated[str, Field(alias="desiredState")]
    """
    DesiredState of the PackageRevision. Can be either Active or Inactive.
    """
    ignore_crossplane_constraints: Annotated[
        Optional[bool], Field(alias="ignoreCrossplaneConstraints")
    ] = False
    """
    IgnoreCrossplaneConstraints indicates to the package manager whether to
    honor Crossplane version constrains specified by the package.
    Default is false.
    """
    image: str
    """
    Package image used by install Pod to extract package contents.
    """
    package_pull_policy: Annotated[Optional[str], Field(alias="packagePullPolicy")] = "IfNotPresent"
    """
    PackagePullPolicy defines the pull policy for the package. It is also
    applied to any images pulled for the package, such as a provider's
    controller image.
    Default is IfNotPresent.
    """
    package_pull_secrets: Annotated[
        Optional[List[PackagePullSecret]], Field(alias="packagePullSecrets")
    ] = None
    """
    PackagePullSecrets are named secrets in the same namespace that can be
    used to fetch packages from private registries. They are also applied to
    any images pulled for the package, such as a provider's controller image.
    """
    revision: int
    """
    Revision number. Indicates when the revision will be garbage collected
    based on the parent's RevisionHistoryLimit.
    """
    runtime_config_ref: Annotated[
        Optional[RuntimeConfigRef],
        Field(
            default_factory=lambda: RuntimeConfigRef.model_validate({"name": "default"}),
            alias="runtimeConfigRef",
        ),
    ] = {"name": "default"}
    """
    RuntimeConfigRef references a RuntimeConfig resource that will be used
    to configure the package runtime.
    """
    skip_dependency_resolution: Annotated[
        Optional[bool], Field(alias="skipDependencyResolution")
    ] = False
    """
    SkipDependencyResolution indicates to the package manager whether to skip
    resolving dependencies for a package. Setting this value to true may have
    unintended consequences.
    Default is false.
    """
    tls_client_secret_name: Annotated[Optional[str], Field(alias="tlsClientSecretName")] = None
    """
    TLSClientSecretName is the name of the TLS Secret that stores client
    certificates of the Provider.
    """
    tls_server_secret_name: Annotated[Optional[str], Field(alias="tlsServerSecretName")] = None
    """
    TLSServerSecretName is the name of the TLS Secret that stores server
    certificates of the Provider.
    """


class ProviderRevisionStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ProviderRevisionStatus"]:
            return ProviderRevisionStatus

        def build(self) -> "ProviderRevisionStatus":
            return ProviderRevisionStatus(**self._attrs)

        @overload
        def applied_image_config_refs(
            self, value_or_callback: List[AppliedImageConfigRef], /
        ) -> "ProviderRevisionStatus.Builder": ...

        @overload
        def applied_image_config_refs(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[AppliedImageConfigRef, AppliedImageConfigRef.Builder]],
                GenericListBuilder[AppliedImageConfigRef, AppliedImageConfigRef.Builder]
                | List[AppliedImageConfigRef],
            ],
            /,
        ) -> "ProviderRevisionStatus.Builder": ...

        @overload
        def applied_image_config_refs(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[AppliedImageConfigRef.Builder]: ...

        def applied_image_config_refs(self, value_or_callback=None, /):
            """
            AppliedImageConfigRefs records any image configs that were applied in
            reconciling this revision, and what they were used for.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[AppliedImageConfigRef.Builder]()
                context._parent_builder = self
                context._field_name = "applied_image_config_refs"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AppliedImageConfigRef.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("applied_image_config_refs", value)

        def capabilities(self, value: Optional[List[str]], /) -> Self:
            """
            Capabilities of this package. Capabilities are opaque strings that
            may be meaningful to package consumers.
            """
            return self._set("capabilities", value)

        @overload
        def conditions(
            self, value_or_callback: List[Condition], /
        ) -> "ProviderRevisionStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Condition, Condition.Builder]],
                GenericListBuilder[Condition, Condition.Builder] | List[Condition],
            ],
            /,
        ) -> "ProviderRevisionStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            """
            Conditions of the resource.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        def found_dependencies(self, value: Optional[int], /) -> Self:
            """
            Dependency information.
            """
            return self._set("found_dependencies", value)

        def installed_dependencies(self, value: Optional[int], /) -> Self:
            return self._set("installed_dependencies", value)

        def invalid_dependencies(self, value: Optional[int], /) -> Self:
            return self._set("invalid_dependencies", value)

        @overload
        def object_refs(
            self, value_or_callback: List[ObjectRef], /
        ) -> "ProviderRevisionStatus.Builder": ...

        @overload
        def object_refs(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[ObjectRef, ObjectRef.Builder]],
                GenericListBuilder[ObjectRef, ObjectRef.Builder] | List[ObjectRef],
            ],
            /,
        ) -> "ProviderRevisionStatus.Builder": ...

        @overload
        def object_refs(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ObjectRef.Builder]: ...

        def object_refs(self, value_or_callback=None, /):
            """
            References to objects owned by PackageRevision.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ObjectRef.Builder]()
                context._parent_builder = self
                context._field_name = "object_refs"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ObjectRef.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("object_refs", value)

        def resolved_image(self, value: Optional[str], /) -> Self:
            """
            ResolvedPackage is the name of the package that was installed. It may be
            different from spec.image if the package path was rewritten using an
            image config.
            """
            return self._set("resolved_image", value)

        def tls_client_secret_name(self, value: Optional[str], /) -> Self:
            """
            TLSClientSecretName is the name of the TLS Secret that stores client
            certificates of the Provider.
            """
            return self._set("tls_client_secret_name", value)

        def tls_server_secret_name(self, value: Optional[str], /) -> Self:
            """
            TLSServerSecretName is the name of the TLS Secret that stores server
            certificates of the Provider.
            """
            return self._set("tls_server_secret_name", value)

    class BuilderContext(BuilderContextBase["ProviderRevisionStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ProviderRevisionStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ProviderRevisionStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ProviderRevisionStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ProviderRevisionStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    applied_image_config_refs: Annotated[
        Optional[List[AppliedImageConfigRef]], Field(alias="appliedImageConfigRefs")
    ] = None
    """
    AppliedImageConfigRefs records any image configs that were applied in
    reconciling this revision, and what they were used for.
    """
    capabilities: Optional[List[str]] = None
    """
    Capabilities of this package. Capabilities are opaque strings that
    may be meaningful to package consumers.
    """
    conditions: Optional[List[Condition]] = None
    """
    Conditions of the resource.
    """
    found_dependencies: Annotated[Optional[int], Field(alias="foundDependencies")] = None
    """
    Dependency information.
    """
    installed_dependencies: Annotated[Optional[int], Field(alias="installedDependencies")] = None
    invalid_dependencies: Annotated[Optional[int], Field(alias="invalidDependencies")] = None
    object_refs: Annotated[Optional[List[ObjectRef]], Field(alias="objectRefs")] = None
    """
    References to objects owned by PackageRevision.
    """
    resolved_image: Annotated[Optional[str], Field(alias="resolvedImage")] = None
    """
    ResolvedPackage is the name of the package that was installed. It may be
    different from spec.image if the package path was rewritten using an
    image config.
    """
    tls_client_secret_name: Annotated[Optional[str], Field(alias="tlsClientSecretName")] = None
    """
    TLSClientSecretName is the name of the TLS Secret that stores client
    certificates of the Provider.
    """
    tls_server_secret_name: Annotated[Optional[str], Field(alias="tlsServerSecretName")] = None
    """
    TLSServerSecretName is the name of the TLS Secret that stores server
    certificates of the Provider.
    """


class ProviderSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ProviderSpec"]:
            return ProviderSpec

        def build(self) -> "ProviderSpec":
            return ProviderSpec(**self._attrs)

        def common_labels(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            Map of string keys and values that can be used to organize and categorize
            (scope and select) objects. May match selectors of replication controllers
            and services.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
            """
            return self._set("common_labels", value)

        def ignore_crossplane_constraints(self, value: Optional[bool], /) -> Self:
            """
            IgnoreCrossplaneConstraints indicates to the package manager whether to
            honor Crossplane version constrains specified by the package.
            Default is false.
            """
            return self._set("ignore_crossplane_constraints", value)

        def package(self, value: str, /) -> Self:
            """
            Package is the name of the package that is being requested.
            must be a fully qualified image name, including the registry,
            repository, and tag. for example, "registry.example.com/repo/package:tag".
            """
            return self._set("package", value)

        def package_pull_policy(self, value: Optional[str], /) -> Self:
            """
            PackagePullPolicy defines the pull policy for the package.
            Default is IfNotPresent.
            """
            return self._set("package_pull_policy", value)

        @overload
        def package_pull_secrets(
            self, value_or_callback: List[PackagePullSecret], /
        ) -> "ProviderSpec.Builder": ...

        @overload
        def package_pull_secrets(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[PackagePullSecret, PackagePullSecret.Builder]],
                GenericListBuilder[PackagePullSecret, PackagePullSecret.Builder]
                | List[PackagePullSecret],
            ],
            /,
        ) -> "ProviderSpec.Builder": ...

        @overload
        def package_pull_secrets(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[PackagePullSecret.Builder]: ...

        def package_pull_secrets(self, value_or_callback=None, /):
            """
            PackagePullSecrets are named secrets in the same namespace that can be used
            to fetch packages from private registries.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[PackagePullSecret.Builder]()
                context._parent_builder = self
                context._field_name = "package_pull_secrets"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PackagePullSecret.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("package_pull_secrets", value)

        def revision_activation_policy(self, value: Optional[str], /) -> Self:
            """
            RevisionActivationPolicy specifies how the package controller should
            update from one revision to the next. Options are Automatic or Manual.
            Default is Automatic.
            """
            return self._set("revision_activation_policy", value)

        def revision_history_limit(self, value: Optional[int], /) -> Self:
            """
            RevisionHistoryLimit dictates how the package controller cleans up old
            inactive package revisions.
            Defaults to 1. Can be disabled by explicitly setting to 0.
            """
            return self._set("revision_history_limit", value)

        @overload
        def runtime_config_ref(
            self, value_or_callback: Optional[RuntimeConfigRef], /
        ) -> "ProviderSpec.Builder": ...

        @overload
        def runtime_config_ref(
            self,
            value_or_callback: Callable[
                [RuntimeConfigRef.Builder], RuntimeConfigRef.Builder | RuntimeConfigRef
            ],
            /,
        ) -> "ProviderSpec.Builder": ...

        @overload
        def runtime_config_ref(
            self, value_or_callback: Never = ...
        ) -> "RuntimeConfigRef.BuilderContext": ...

        def runtime_config_ref(self, value_or_callback=None, /):
            """
            RuntimeConfigRef references a RuntimeConfig resource that will be used
            to configure the package runtime.
            """
            if self._in_context and value_or_callback is None:
                context = RuntimeConfigRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "runtime_config_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(RuntimeConfigRef.builder())
                if isinstance(output, RuntimeConfigRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("runtime_config_ref", value)

        def skip_dependency_resolution(self, value: Optional[bool], /) -> Self:
            """
            SkipDependencyResolution indicates to the package manager whether to skip
            resolving dependencies for a package. Setting this value to true may have
            unintended consequences.
            Default is false.
            """
            return self._set("skip_dependency_resolution", value)

    class BuilderContext(BuilderContextBase["ProviderSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ProviderSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ProviderSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ProviderSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ProviderSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    common_labels: Annotated[Optional[Dict[str, str]], Field(alias="commonLabels")] = None
    """
    Map of string keys and values that can be used to organize and categorize
    (scope and select) objects. May match selectors of replication controllers
    and services.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
    """
    ignore_crossplane_constraints: Annotated[
        Optional[bool], Field(alias="ignoreCrossplaneConstraints")
    ] = False
    """
    IgnoreCrossplaneConstraints indicates to the package manager whether to
    honor Crossplane version constrains specified by the package.
    Default is false.
    """
    package: str
    """
    Package is the name of the package that is being requested.
    must be a fully qualified image name, including the registry,
    repository, and tag. for example, "registry.example.com/repo/package:tag".
    """
    package_pull_policy: Annotated[Optional[str], Field(alias="packagePullPolicy")] = "IfNotPresent"
    """
    PackagePullPolicy defines the pull policy for the package.
    Default is IfNotPresent.
    """
    package_pull_secrets: Annotated[
        Optional[List[PackagePullSecret]], Field(alias="packagePullSecrets")
    ] = None
    """
    PackagePullSecrets are named secrets in the same namespace that can be used
    to fetch packages from private registries.
    """
    revision_activation_policy: Annotated[
        Optional[str], Field(alias="revisionActivationPolicy")
    ] = "Automatic"
    """
    RevisionActivationPolicy specifies how the package controller should
    update from one revision to the next. Options are Automatic or Manual.
    Default is Automatic.
    """
    revision_history_limit: Annotated[Optional[int], Field(alias="revisionHistoryLimit")] = 1
    """
    RevisionHistoryLimit dictates how the package controller cleans up old
    inactive package revisions.
    Defaults to 1. Can be disabled by explicitly setting to 0.
    """
    runtime_config_ref: Annotated[
        Optional[RuntimeConfigRef],
        Field(
            default_factory=lambda: RuntimeConfigRef.model_validate({"name": "default"}),
            alias="runtimeConfigRef",
        ),
    ] = {"name": "default"}
    """
    RuntimeConfigRef references a RuntimeConfig resource that will be used
    to configure the package runtime.
    """
    skip_dependency_resolution: Annotated[
        Optional[bool], Field(alias="skipDependencyResolution")
    ] = False
    """
    SkipDependencyResolution indicates to the package manager whether to skip
    resolving dependencies for a package. Setting this value to true may have
    unintended consequences.
    Default is false.
    """


class ProviderStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ProviderStatus"]:
            return ProviderStatus

        def build(self) -> "ProviderStatus":
            return ProviderStatus(**self._attrs)

        @overload
        def applied_image_config_refs(
            self, value_or_callback: List[AppliedImageConfigRef], /
        ) -> "ProviderStatus.Builder": ...

        @overload
        def applied_image_config_refs(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[AppliedImageConfigRef, AppliedImageConfigRef.Builder]],
                GenericListBuilder[AppliedImageConfigRef, AppliedImageConfigRef.Builder]
                | List[AppliedImageConfigRef],
            ],
            /,
        ) -> "ProviderStatus.Builder": ...

        @overload
        def applied_image_config_refs(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[AppliedImageConfigRef.Builder]: ...

        def applied_image_config_refs(self, value_or_callback=None, /):
            """
            AppliedImageConfigRefs records any image configs that were applied in
            reconciling this package, and what they were used for.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[AppliedImageConfigRef.Builder]()
                context._parent_builder = self
                context._field_name = "applied_image_config_refs"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AppliedImageConfigRef.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("applied_image_config_refs", value)

        @overload
        def conditions(self, value_or_callback: List[Condition], /) -> "ProviderStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Condition, Condition.Builder]],
                GenericListBuilder[Condition, Condition.Builder] | List[Condition],
            ],
            /,
        ) -> "ProviderStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            """
            Conditions of the resource.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        def current_identifier(self, value: Optional[str], /) -> Self:
            """
            CurrentIdentifier is the most recent package source that was used to
            produce a revision. The package manager uses this field to determine
            whether to check for package updates for a given source when
            packagePullPolicy is set to IfNotPresent. Manually removing this field
            will cause the package manager to check that the current revision is
            correct for the given package source.
            """
            return self._set("current_identifier", value)

        def current_revision(self, value: Optional[str], /) -> Self:
            """
            CurrentRevision is the name of the current package revision. It will
            reflect the most up to date revision, whether it has been activated or
            not.
            """
            return self._set("current_revision", value)

        def resolved_package(self, value: Optional[str], /) -> Self:
            """
            ResolvedPackage is the name of the package that was used for version
            resolution. It may be different from spec.package if the package path was
            rewritten using an image config.
            """
            return self._set("resolved_package", value)

    class BuilderContext(BuilderContextBase["ProviderStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ProviderStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ProviderStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ProviderStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ProviderStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    applied_image_config_refs: Annotated[
        Optional[List[AppliedImageConfigRef]], Field(alias="appliedImageConfigRefs")
    ] = None
    """
    AppliedImageConfigRefs records any image configs that were applied in
    reconciling this package, and what they were used for.
    """
    conditions: Optional[List[Condition]] = None
    """
    Conditions of the resource.
    """
    current_identifier: Annotated[Optional[str], Field(alias="currentIdentifier")] = None
    """
    CurrentIdentifier is the most recent package source that was used to
    produce a revision. The package manager uses this field to determine
    whether to check for package updates for a given source when
    packagePullPolicy is set to IfNotPresent. Manually removing this field
    will cause the package manager to check that the current revision is
    correct for the given package source.
    """
    current_revision: Annotated[Optional[str], Field(alias="currentRevision")] = None
    """
    CurrentRevision is the name of the current package revision. It will
    reflect the most up to date revision, whether it has been activated or
    not.
    """
    resolved_package: Annotated[Optional[str], Field(alias="resolvedPackage")] = None
    """
    ResolvedPackage is the name of the package that was used for version
    resolution. It may be different from spec.package if the package path was
    rewritten using an image config.
    """


class ConfigurationRevision(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ConfigurationRevision"]:
            return ConfigurationRevision

        def build(self) -> "ConfigurationRevision":
            return ConfigurationRevision(**self._attrs)

        def api_version(self, value: Optional[Literal["pkg.crossplane.io/v1"]], /) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["ConfigurationRevision"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "ConfigurationRevision.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "ConfigurationRevision.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(
            self, value_or_callback: Optional[ConfigurationRevisionSpec], /
        ) -> "ConfigurationRevision.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [ConfigurationRevisionSpec.Builder],
                ConfigurationRevisionSpec.Builder | ConfigurationRevisionSpec,
            ],
            /,
        ) -> "ConfigurationRevision.Builder": ...

        @overload
        def spec(
            self, value_or_callback: Never = ...
        ) -> "ConfigurationRevisionSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ConfigurationRevisionSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ConfigurationRevisionSpec.builder())
                if isinstance(output, ConfigurationRevisionSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(
            self, value_or_callback: Optional[ConfigurationRevisionStatus], /
        ) -> "ConfigurationRevision.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [ConfigurationRevisionStatus.Builder],
                ConfigurationRevisionStatus.Builder | ConfigurationRevisionStatus,
            ],
            /,
        ) -> "ConfigurationRevision.Builder": ...

        @overload
        def status(
            self, value_or_callback: Never = ...
        ) -> "ConfigurationRevisionStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ConfigurationRevisionStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ConfigurationRevisionStatus.builder())
                if isinstance(output, ConfigurationRevisionStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["ConfigurationRevision.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ConfigurationRevision.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ConfigurationRevision."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ConfigurationRevision", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ConfigurationRevision.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[Literal["pkg.crossplane.io/v1"]], Field(alias="apiVersion")] = (
        "pkg.crossplane.io/v1"
    )
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["ConfigurationRevision"]] = "ConfigurationRevision"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: Optional[ConfigurationRevisionSpec] = None
    status: Optional[ConfigurationRevisionStatus] = None


class Configuration(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Configuration"]:
            return Configuration

        def build(self) -> "Configuration":
            return Configuration(**self._attrs)

        def api_version(self, value: Optional[Literal["pkg.crossplane.io/v1"]], /) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["Configuration"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "Configuration.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "Configuration.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(
            self, value_or_callback: Optional[ConfigurationSpec], /
        ) -> "Configuration.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [ConfigurationSpec.Builder],
                ConfigurationSpec.Builder | ConfigurationSpec,
            ],
            /,
        ) -> "Configuration.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "ConfigurationSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ConfigurationSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ConfigurationSpec.builder())
                if isinstance(output, ConfigurationSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(
            self, value_or_callback: Optional[ConfigurationStatus], /
        ) -> "Configuration.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [ConfigurationStatus.Builder],
                ConfigurationStatus.Builder | ConfigurationStatus,
            ],
            /,
        ) -> "Configuration.Builder": ...

        @overload
        def status(
            self, value_or_callback: Never = ...
        ) -> "ConfigurationStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ConfigurationStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ConfigurationStatus.builder())
                if isinstance(output, ConfigurationStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["Configuration.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Configuration.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Configuration."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Configuration", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Configuration.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[Literal["pkg.crossplane.io/v1"]], Field(alias="apiVersion")] = (
        "pkg.crossplane.io/v1"
    )
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["Configuration"]] = "Configuration"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: Optional[ConfigurationSpec] = None
    status: Optional[ConfigurationStatus] = None


class FunctionRevision(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["FunctionRevision"]:
            return FunctionRevision

        def build(self) -> "FunctionRevision":
            return FunctionRevision(**self._attrs)

        def api_version(self, value: Optional[Literal["pkg.crossplane.io/v1"]], /) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["FunctionRevision"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "FunctionRevision.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "FunctionRevision.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(
            self, value_or_callback: Optional[FunctionRevisionSpec], /
        ) -> "FunctionRevision.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [FunctionRevisionSpec.Builder],
                FunctionRevisionSpec.Builder | FunctionRevisionSpec,
            ],
            /,
        ) -> "FunctionRevision.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "FunctionRevisionSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = FunctionRevisionSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(FunctionRevisionSpec.builder())
                if isinstance(output, FunctionRevisionSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(
            self, value_or_callback: Optional[FunctionRevisionStatus], /
        ) -> "FunctionRevision.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [FunctionRevisionStatus.Builder],
                FunctionRevisionStatus.Builder | FunctionRevisionStatus,
            ],
            /,
        ) -> "FunctionRevision.Builder": ...

        @overload
        def status(
            self, value_or_callback: Never = ...
        ) -> "FunctionRevisionStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = FunctionRevisionStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(FunctionRevisionStatus.builder())
                if isinstance(output, FunctionRevisionStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["FunctionRevision.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = FunctionRevision.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for FunctionRevision."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["FunctionRevision", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use FunctionRevision.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[Literal["pkg.crossplane.io/v1"]], Field(alias="apiVersion")] = (
        "pkg.crossplane.io/v1"
    )
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["FunctionRevision"]] = "FunctionRevision"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: Optional[FunctionRevisionSpec] = None
    status: Optional[FunctionRevisionStatus] = None


class Function(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Function"]:
            return Function

        def build(self) -> "Function":
            return Function(**self._attrs)

        def api_version(self, value: Optional[Literal["pkg.crossplane.io/v1"]], /) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["Function"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "Function.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "Function.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(self, value_or_callback: Optional[FunctionSpec], /) -> "Function.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [FunctionSpec.Builder], FunctionSpec.Builder | FunctionSpec
            ],
            /,
        ) -> "Function.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "FunctionSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = FunctionSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(FunctionSpec.builder())
                if isinstance(output, FunctionSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(self, value_or_callback: Optional[FunctionStatus], /) -> "Function.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [FunctionStatus.Builder], FunctionStatus.Builder | FunctionStatus
            ],
            /,
        ) -> "Function.Builder": ...

        @overload
        def status(self, value_or_callback: Never = ...) -> "FunctionStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = FunctionStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(FunctionStatus.builder())
                if isinstance(output, FunctionStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["Function.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Function.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Function."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Function", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Function.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[Literal["pkg.crossplane.io/v1"]], Field(alias="apiVersion")] = (
        "pkg.crossplane.io/v1"
    )
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["Function"]] = "Function"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: Optional[FunctionSpec] = None
    status: Optional[FunctionStatus] = None


class ProviderRevision(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ProviderRevision"]:
            return ProviderRevision

        def build(self) -> "ProviderRevision":
            return ProviderRevision(**self._attrs)

        def api_version(self, value: Optional[Literal["pkg.crossplane.io/v1"]], /) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["ProviderRevision"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "ProviderRevision.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "ProviderRevision.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(
            self, value_or_callback: Optional[ProviderRevisionSpec], /
        ) -> "ProviderRevision.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [ProviderRevisionSpec.Builder],
                ProviderRevisionSpec.Builder | ProviderRevisionSpec,
            ],
            /,
        ) -> "ProviderRevision.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "ProviderRevisionSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ProviderRevisionSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ProviderRevisionSpec.builder())
                if isinstance(output, ProviderRevisionSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(
            self, value_or_callback: Optional[ProviderRevisionStatus], /
        ) -> "ProviderRevision.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [ProviderRevisionStatus.Builder],
                ProviderRevisionStatus.Builder | ProviderRevisionStatus,
            ],
            /,
        ) -> "ProviderRevision.Builder": ...

        @overload
        def status(
            self, value_or_callback: Never = ...
        ) -> "ProviderRevisionStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ProviderRevisionStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ProviderRevisionStatus.builder())
                if isinstance(output, ProviderRevisionStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["ProviderRevision.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ProviderRevision.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ProviderRevision."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ProviderRevision", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ProviderRevision.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[Literal["pkg.crossplane.io/v1"]], Field(alias="apiVersion")] = (
        "pkg.crossplane.io/v1"
    )
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["ProviderRevision"]] = "ProviderRevision"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: Optional[ProviderRevisionSpec] = None
    status: Optional[ProviderRevisionStatus] = None


class Provider(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Provider"]:
            return Provider

        def build(self) -> "Provider":
            return Provider(**self._attrs)

        def api_version(self, value: Optional[Literal["pkg.crossplane.io/v1"]], /) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["Provider"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "Provider.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "Provider.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(self, value_or_callback: Optional[ProviderSpec], /) -> "Provider.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [ProviderSpec.Builder], ProviderSpec.Builder | ProviderSpec
            ],
            /,
        ) -> "Provider.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "ProviderSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ProviderSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ProviderSpec.builder())
                if isinstance(output, ProviderSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(self, value_or_callback: Optional[ProviderStatus], /) -> "Provider.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [ProviderStatus.Builder], ProviderStatus.Builder | ProviderStatus
            ],
            /,
        ) -> "Provider.Builder": ...

        @overload
        def status(self, value_or_callback: Never = ...) -> "ProviderStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ProviderStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ProviderStatus.builder())
                if isinstance(output, ProviderStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["Provider.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Provider.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Provider."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Provider", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Provider.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[Literal["pkg.crossplane.io/v1"]], Field(alias="apiVersion")] = (
        "pkg.crossplane.io/v1"
    )
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["Provider"]] = "Provider"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: Optional[ProviderSpec] = None
    status: Optional[ProviderStatus] = None
