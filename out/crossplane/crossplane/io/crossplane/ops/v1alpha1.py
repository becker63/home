# Generated by cloudcoil-model-codegen v0.5.8
# DO NOT EDIT


from __future__ import annotations

from typing import (
    Annotated,
    Any,
    Callable,
    Dict,
    List,
    Literal,
    Optional,
    Type,
    overload,
)

from cloudcoil import apimachinery
from cloudcoil.pydantic import (
    BaseModel,
    BaseModelBuilder,
    BuilderContextBase,
    GenericListBuilder,
    ListBuilderContext,
    Never,
    Self,
)
from cloudcoil.resources import Resource
from pydantic import AwareDatetime, Field


class SecretRef(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["SecretRef"]:
            return SecretRef

        def build(self) -> "SecretRef":
            return SecretRef(**self._attrs)

        def name(self, value: str, /) -> Self:
            """
            Name of the secret.
            """
            return self._set("name", value)

        def namespace(self, value: str, /) -> Self:
            """
            Namespace of the secret.
            """
            return self._set("namespace", value)

    class BuilderContext(BuilderContextBase["SecretRef.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SecretRef.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SecretRef."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["SecretRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SecretRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: str
    """
    Name of the secret.
    """
    namespace: str
    """
    Namespace of the secret.
    """


class Credential(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Credential"]:
            return Credential

        def build(self) -> "Credential":
            return Credential(**self._attrs)

        def name(self, value: str, /) -> Self:
            """
            Name of this set of credentials.
            """
            return self._set("name", value)

        @overload
        def secret_ref(self, value_or_callback: Optional[SecretRef], /) -> "Credential.Builder": ...

        @overload
        def secret_ref(
            self,
            value_or_callback: Callable[[SecretRef.Builder], SecretRef.Builder | SecretRef],
            /,
        ) -> "Credential.Builder": ...

        @overload
        def secret_ref(self, value_or_callback: Never = ...) -> "SecretRef.BuilderContext": ...

        def secret_ref(self, value_or_callback=None, /):
            """
            A SecretRef is a reference to a secret containing credentials that should
            be supplied to the function.
            """
            if self._in_context and value_or_callback is None:
                context = SecretRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "secret_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SecretRef.builder())
                if isinstance(output, SecretRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("secret_ref", value)

        def source(self, value: Literal["None", "Secret"], /) -> Self:
            """
            Source of the function credentials.
            """
            return self._set("source", value)

    class BuilderContext(BuilderContextBase["Credential.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Credential.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Credential."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Credential", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Credential.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: str
    """
    Name of this set of credentials.
    """
    secret_ref: Annotated[Optional[SecretRef], Field(alias="secretRef")] = None
    """
    A SecretRef is a reference to a secret containing credentials that should
    be supplied to the function.
    """
    source: Literal["None", "Secret"]
    """
    Source of the function credentials.
    """


class FunctionRef(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["FunctionRef"]:
            return FunctionRef

        def build(self) -> "FunctionRef":
            return FunctionRef(**self._attrs)

        def name(self, value: str, /) -> Self:
            """
            Name of the referenced function.
            """
            return self._set("name", value)

    class BuilderContext(BuilderContextBase["FunctionRef.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = FunctionRef.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for FunctionRef."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["FunctionRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use FunctionRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: str
    """
    Name of the referenced function.
    """


class RequiredResource(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["RequiredResource"]:
            return RequiredResource

        def build(self) -> "RequiredResource":
            return RequiredResource(**self._attrs)

        def api_version(self, value: str, /) -> Self:
            """
            APIVersion of resources to select.
            """
            return self._set("api_version", value)

        def kind(self, value: str, /) -> Self:
            """
            Kind of resources to select.
            """
            return self._set("kind", value)

        def match_labels(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            MatchLabels matches resources by label selector. Only one of Name or
            MatchLabels may be specified.
            """
            return self._set("match_labels", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name matches a single resource by name. Only one of Name or
            MatchLabels may be specified.
            """
            return self._set("name", value)

        def namespace(self, value: Optional[str], /) -> Self:
            """
            Namespace to search for resources. Optional for cluster-scoped resources.
            """
            return self._set("namespace", value)

        def requirement_name(self, value: str, /) -> Self:
            """
            RequirementName uniquely identifies this group of resources.
            This name will be used as the key in RunFunctionRequest.required_resources.
            """
            return self._set("requirement_name", value)

    class BuilderContext(BuilderContextBase["RequiredResource.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = RequiredResource.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RequiredResource."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["RequiredResource", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use RequiredResource.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[str, Field(alias="apiVersion")]
    """
    APIVersion of resources to select.
    """
    kind: str
    """
    Kind of resources to select.
    """
    match_labels: Annotated[Optional[Dict[str, str]], Field(alias="matchLabels")] = None
    """
    MatchLabels matches resources by label selector. Only one of Name or
    MatchLabels may be specified.
    """
    name: Optional[str] = None
    """
    Name matches a single resource by name. Only one of Name or
    MatchLabels may be specified.
    """
    namespace: Optional[str] = None
    """
    Namespace to search for resources. Optional for cluster-scoped resources.
    """
    requirement_name: Annotated[str, Field(alias="requirementName")]
    """
    RequirementName uniquely identifies this group of resources.
    This name will be used as the key in RunFunctionRequest.required_resources.
    """


class Requirements(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Requirements"]:
            return Requirements

        def build(self) -> "Requirements":
            return Requirements(**self._attrs)

        @overload
        def required_resources(
            self, value_or_callback: List[RequiredResource], /
        ) -> "Requirements.Builder": ...

        @overload
        def required_resources(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[RequiredResource, RequiredResource.Builder]],
                GenericListBuilder[RequiredResource, RequiredResource.Builder]
                | List[RequiredResource],
            ],
            /,
        ) -> "Requirements.Builder": ...

        @overload
        def required_resources(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[RequiredResource.Builder]: ...

        def required_resources(self, value_or_callback=None, /):
            """
            RequiredResources that will be fetched before this pipeline step
            is called for the first time.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[RequiredResource.Builder]()
                context._parent_builder = self
                context._field_name = "required_resources"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(RequiredResource.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("required_resources", value)

    class BuilderContext(BuilderContextBase["Requirements.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Requirements.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Requirements."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Requirements", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Requirements.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    required_resources: Annotated[
        Optional[List[RequiredResource]], Field(alias="requiredResources")
    ] = None
    """
    RequiredResources that will be fetched before this pipeline step
    is called for the first time.
    """


class Pipeline(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Pipeline"]:
            return Pipeline

        def build(self) -> "Pipeline":
            return Pipeline(**self._attrs)

        @overload
        def credentials(self, value_or_callback: List[Credential], /) -> "Pipeline.Builder": ...

        @overload
        def credentials(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Credential, Credential.Builder]],
                GenericListBuilder[Credential, Credential.Builder] | List[Credential],
            ],
            /,
        ) -> "Pipeline.Builder": ...

        @overload
        def credentials(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Credential.Builder]: ...

        def credentials(self, value_or_callback=None, /):
            """
            Credentials are optional credentials that the operation function needs.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Credential.Builder]()
                context._parent_builder = self
                context._field_name = "credentials"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Credential.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("credentials", value)

        @overload
        def function_ref(self, value_or_callback: FunctionRef, /) -> "Pipeline.Builder": ...

        @overload
        def function_ref(
            self,
            value_or_callback: Callable[[FunctionRef.Builder], FunctionRef.Builder | FunctionRef],
            /,
        ) -> "Pipeline.Builder": ...

        @overload
        def function_ref(self, value_or_callback: Never = ...) -> "FunctionRef.BuilderContext": ...

        def function_ref(self, value_or_callback=None, /):
            """
            FunctionRef is a reference to the function this step should
            execute.
            """
            if self._in_context and value_or_callback is None:
                context = FunctionRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "function_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(FunctionRef.builder())
                if isinstance(output, FunctionRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("function_ref", value)

        def input(self, value: Optional[Dict[str, Any]], /) -> Self:
            """
            Input is an optional, arbitrary Kubernetes resource (i.e. a resource
            with an apiVersion and kind) that will be passed to the unction as
            the 'input' of its RunFunctionRequest.
            """
            return self._set("input", value)

        @overload
        def requirements(
            self, value_or_callback: Optional[Requirements], /
        ) -> "Pipeline.Builder": ...

        @overload
        def requirements(
            self,
            value_or_callback: Callable[
                [Requirements.Builder], Requirements.Builder | Requirements
            ],
            /,
        ) -> "Pipeline.Builder": ...

        @overload
        def requirements(self, value_or_callback: Never = ...) -> "Requirements.BuilderContext": ...

        def requirements(self, value_or_callback=None, /):
            """
            Requirements are resource requirements that will be satisfied before
            this pipeline step is called for the first time. This allows
            pre-populating required resources without requiring a function to
            request them first.
            """
            if self._in_context and value_or_callback is None:
                context = Requirements.BuilderContext()
                context._parent_builder = self
                context._field_name = "requirements"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Requirements.builder())
                if isinstance(output, Requirements.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("requirements", value)

        def step(self, value: str, /) -> Self:
            """
            Step name. Must be unique within its Pipeline.
            """
            return self._set("step", value)

    class BuilderContext(BuilderContextBase["Pipeline.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Pipeline.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Pipeline."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Pipeline", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Pipeline.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    credentials: Optional[List[Credential]] = None
    """
    Credentials are optional credentials that the operation function needs.
    """
    function_ref: Annotated[FunctionRef, Field(alias="functionRef")]
    """
    FunctionRef is a reference to the function this step should
    execute.
    """
    input: Optional[Dict[str, Any]] = None
    """
    Input is an optional, arbitrary Kubernetes resource (i.e. a resource
    with an apiVersion and kind) that will be passed to the unction as
    the 'input' of its RunFunctionRequest.
    """
    requirements: Optional[Requirements] = None
    """
    Requirements are resource requirements that will be satisfied before
    this pipeline step is called for the first time. This allows
    pre-populating required resources without requiring a function to
    request them first.
    """
    step: str
    """
    Step name. Must be unique within its Pipeline.
    """


class Spec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Spec"]:
            return Spec

        def build(self) -> "Spec":
            return Spec(**self._attrs)

        def mode(self, value: Optional[Literal["Pipeline"]], /) -> Self:
            """
            Mode controls what type or "mode" of operation will be used.

            "Pipeline" indicates that an Operation specifies a pipeline of
            functions, each of which is responsible for implementing its logic.
            """
            return self._set("mode", value)

        @overload
        def pipeline(self, value_or_callback: List[Pipeline], /) -> "Spec.Builder": ...

        @overload
        def pipeline(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Pipeline, Pipeline.Builder]],
                GenericListBuilder[Pipeline, Pipeline.Builder] | List[Pipeline],
            ],
            /,
        ) -> "Spec.Builder": ...

        @overload
        def pipeline(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Pipeline.Builder]: ...

        def pipeline(self, value_or_callback=None, /):
            """
            Pipeline is a list of operation function steps that will be used when
            this operation runs.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Pipeline.Builder]()
                context._parent_builder = self
                context._field_name = "pipeline"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Pipeline.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("pipeline", value)

        def retry_limit(self, value: Optional[int], /) -> Self:
            """
            RetryLimit configures how many times the operation may fail. When the
            failure limit is exceeded, the operation will not be retried.
            """
            return self._set("retry_limit", value)

    class BuilderContext(BuilderContextBase["Spec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Spec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Spec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Spec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Spec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    mode: Optional[Literal["Pipeline"]] = "Pipeline"
    """
    Mode controls what type or "mode" of operation will be used.

    "Pipeline" indicates that an Operation specifies a pipeline of
    functions, each of which is responsible for implementing its logic.
    """
    pipeline: Annotated[List[Pipeline], Field(max_length=99, min_length=1)]
    """
    Pipeline is a list of operation function steps that will be used when
    this operation runs.
    """
    retry_limit: Annotated[Optional[int], Field(alias="retryLimit")] = None
    """
    RetryLimit configures how many times the operation may fail. When the
    failure limit is exceeded, the operation will not be retried.
    """


class OperationTemplate(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["OperationTemplate"]:
            return OperationTemplate

        def build(self) -> "OperationTemplate":
            return OperationTemplate(**self._attrs)

        def metadata(self, value: Optional[Dict[str, Any]], /) -> Self:
            """
            Standard object metadata.
            """
            return self._set("metadata", value)

        @overload
        def spec(self, value_or_callback: Spec, /) -> "OperationTemplate.Builder": ...

        @overload
        def spec(
            self, value_or_callback: Callable[[Spec.Builder], Spec.Builder | Spec], /
        ) -> "OperationTemplate.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "Spec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            """
            Spec is the specification of the Operation to be created.
            """
            if self._in_context and value_or_callback is None:
                context = Spec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Spec.builder())
                if isinstance(output, Spec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

    class BuilderContext(BuilderContextBase["OperationTemplate.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = OperationTemplate.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for OperationTemplate."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["OperationTemplate", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use OperationTemplate.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    metadata: Optional[Dict[str, Any]] = None
    """
    Standard object metadata.
    """
    spec: Spec
    """
    Spec is the specification of the Operation to be created.
    """


class CronOperationSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["CronOperationSpec"]:
            return CronOperationSpec

        def build(self) -> "CronOperationSpec":
            return CronOperationSpec(**self._attrs)

        def concurrency_policy(
            self, value: Optional[Literal["Allow", "Forbid", "Replace"]], /
        ) -> Self:
            """
            ConcurrencyPolicy specifies how to treat concurrent executions of an
            operation.
            """
            return self._set("concurrency_policy", value)

        def failed_history_limit(self, value: Optional[int], /) -> Self:
            """
            FailedHistoryLimit is the number of failed Operations to retain.
            """
            return self._set("failed_history_limit", value)

        @overload
        def operation_template(
            self, value_or_callback: OperationTemplate, /
        ) -> "CronOperationSpec.Builder": ...

        @overload
        def operation_template(
            self,
            value_or_callback: Callable[
                [OperationTemplate.Builder],
                OperationTemplate.Builder | OperationTemplate,
            ],
            /,
        ) -> "CronOperationSpec.Builder": ...

        @overload
        def operation_template(
            self, value_or_callback: Never = ...
        ) -> "OperationTemplate.BuilderContext": ...

        def operation_template(self, value_or_callback=None, /):
            """
            OperationTemplate is the template for the Operation to be created.
            """
            if self._in_context and value_or_callback is None:
                context = OperationTemplate.BuilderContext()
                context._parent_builder = self
                context._field_name = "operation_template"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(OperationTemplate.builder())
                if isinstance(output, OperationTemplate.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("operation_template", value)

        def schedule(self, value: str, /) -> Self:
            """
            Schedule is the cron schedule for the operation.
            """
            return self._set("schedule", value)

        def starting_deadline_seconds(self, value: Optional[int], /) -> Self:
            """
            StartingDeadlineSeconds is the deadline in seconds for starting the
            operation if it misses its scheduled time for any reason.
            """
            return self._set("starting_deadline_seconds", value)

        def successful_history_limit(self, value: Optional[int], /) -> Self:
            """
            SuccessfulHistoryLimit is the number of successful Operations to retain.
            """
            return self._set("successful_history_limit", value)

    class BuilderContext(BuilderContextBase["CronOperationSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = CronOperationSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for CronOperationSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["CronOperationSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use CronOperationSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    concurrency_policy: Annotated[
        Optional[Literal["Allow", "Forbid", "Replace"]],
        Field(alias="concurrencyPolicy"),
    ] = "Allow"
    """
    ConcurrencyPolicy specifies how to treat concurrent executions of an
    operation.
    """
    failed_history_limit: Annotated[Optional[int], Field(alias="failedHistoryLimit")] = 1
    """
    FailedHistoryLimit is the number of failed Operations to retain.
    """
    operation_template: Annotated[OperationTemplate, Field(alias="operationTemplate")]
    """
    OperationTemplate is the template for the Operation to be created.
    """
    schedule: str
    """
    Schedule is the cron schedule for the operation.
    """
    starting_deadline_seconds: Annotated[Optional[int], Field(alias="startingDeadlineSeconds")] = (
        None
    )
    """
    StartingDeadlineSeconds is the deadline in seconds for starting the
    operation if it misses its scheduled time for any reason.
    """
    successful_history_limit: Annotated[Optional[int], Field(alias="successfulHistoryLimit")] = 3
    """
    SuccessfulHistoryLimit is the number of successful Operations to retain.
    """


class Condition(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Condition"]:
            return Condition

        def build(self) -> "Condition":
            return Condition(**self._attrs)

        def last_transition_time(self, value: AwareDatetime, /) -> Self:
            """
            LastTransitionTime is the last time this condition transitioned from one
            status to another.
            """
            return self._set("last_transition_time", value)

        def message(self, value: Optional[str], /) -> Self:
            """
            A Message containing details about this condition's last transition from
            one status to another, if any.
            """
            return self._set("message", value)

        def observed_generation(self, value: Optional[int], /) -> Self:
            """
            ObservedGeneration represents the .metadata.generation that the condition was set based upon.
            For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
            with respect to the current state of the instance.
            """
            return self._set("observed_generation", value)

        def reason(self, value: str, /) -> Self:
            """
            A Reason for this condition's last transition from one status to another.
            """
            return self._set("reason", value)

        def status(self, value: str, /) -> Self:
            """
            Status of this condition; is it currently True, False, or Unknown?
            """
            return self._set("status", value)

        def type(self, value: str, /) -> Self:
            """
            Type of this condition. At most one of each condition type may apply to
            a resource at any point in time.
            """
            return self._set("type", value)

    class BuilderContext(BuilderContextBase["Condition.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Condition.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Condition."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Condition", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Condition.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    last_transition_time: Annotated[AwareDatetime, Field(alias="lastTransitionTime")]
    """
    LastTransitionTime is the last time this condition transitioned from one
    status to another.
    """
    message: Optional[str] = None
    """
    A Message containing details about this condition's last transition from
    one status to another, if any.
    """
    observed_generation: Annotated[Optional[int], Field(alias="observedGeneration")] = None
    """
    ObservedGeneration represents the .metadata.generation that the condition was set based upon.
    For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
    with respect to the current state of the instance.
    """
    reason: str
    """
    A Reason for this condition's last transition from one status to another.
    """
    status: str
    """
    Status of this condition; is it currently True, False, or Unknown?
    """
    type: str
    """
    Type of this condition. At most one of each condition type may apply to
    a resource at any point in time.
    """


class RunningOperationRef(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["RunningOperationRef"]:
            return RunningOperationRef

        def build(self) -> "RunningOperationRef":
            return RunningOperationRef(**self._attrs)

        def name(self, value: str, /) -> Self:
            """
            Name of the active operation.
            """
            return self._set("name", value)

    class BuilderContext(BuilderContextBase["RunningOperationRef.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = RunningOperationRef.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RunningOperationRef."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["RunningOperationRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use RunningOperationRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: str
    """
    Name of the active operation.
    """


class CronOperationStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["CronOperationStatus"]:
            return CronOperationStatus

        def build(self) -> "CronOperationStatus":
            return CronOperationStatus(**self._attrs)

        @overload
        def conditions(
            self, value_or_callback: List[Condition], /
        ) -> "CronOperationStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Condition, Condition.Builder]],
                GenericListBuilder[Condition, Condition.Builder] | List[Condition],
            ],
            /,
        ) -> "CronOperationStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            """
            Conditions of the resource.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        def last_schedule_time(self, value: Optional[AwareDatetime], /) -> Self:
            """
            LastScheduleTime is the last time the CronOperation was scheduled.
            """
            return self._set("last_schedule_time", value)

        def last_successful_time(self, value: Optional[AwareDatetime], /) -> Self:
            """
            LastSuccessfulTime is the last time the CronOperation was successfully
            completed.
            """
            return self._set("last_successful_time", value)

        @overload
        def running_operation_refs(
            self, value_or_callback: List[RunningOperationRef], /
        ) -> "CronOperationStatus.Builder": ...

        @overload
        def running_operation_refs(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[RunningOperationRef, RunningOperationRef.Builder]],
                GenericListBuilder[RunningOperationRef, RunningOperationRef.Builder]
                | List[RunningOperationRef],
            ],
            /,
        ) -> "CronOperationStatus.Builder": ...

        @overload
        def running_operation_refs(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[RunningOperationRef.Builder]: ...

        def running_operation_refs(self, value_or_callback=None, /):
            """
            RunningOperationRefs is a list of currently running Operations.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[RunningOperationRef.Builder]()
                context._parent_builder = self
                context._field_name = "running_operation_refs"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(RunningOperationRef.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("running_operation_refs", value)

    class BuilderContext(BuilderContextBase["CronOperationStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = CronOperationStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for CronOperationStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["CronOperationStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use CronOperationStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    conditions: Optional[List[Condition]] = None
    """
    Conditions of the resource.
    """
    last_schedule_time: Annotated[Optional[AwareDatetime], Field(alias="lastScheduleTime")] = None
    """
    LastScheduleTime is the last time the CronOperation was scheduled.
    """
    last_successful_time: Annotated[Optional[AwareDatetime], Field(alias="lastSuccessfulTime")] = (
        None
    )
    """
    LastSuccessfulTime is the last time the CronOperation was successfully
    completed.
    """
    running_operation_refs: Annotated[
        Optional[List[RunningOperationRef]], Field(alias="runningOperationRefs")
    ] = None
    """
    RunningOperationRefs is a list of currently running Operations.
    """


class OperationSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["OperationSpec"]:
            return OperationSpec

        def build(self) -> "OperationSpec":
            return OperationSpec(**self._attrs)

        def mode(self, value: Optional[Literal["Pipeline"]], /) -> Self:
            """
            Mode controls what type or "mode" of operation will be used.

            "Pipeline" indicates that an Operation specifies a pipeline of
            functions, each of which is responsible for implementing its logic.
            """
            return self._set("mode", value)

        @overload
        def pipeline(self, value_or_callback: List[Pipeline], /) -> "OperationSpec.Builder": ...

        @overload
        def pipeline(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Pipeline, Pipeline.Builder]],
                GenericListBuilder[Pipeline, Pipeline.Builder] | List[Pipeline],
            ],
            /,
        ) -> "OperationSpec.Builder": ...

        @overload
        def pipeline(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Pipeline.Builder]: ...

        def pipeline(self, value_or_callback=None, /):
            """
            Pipeline is a list of operation function steps that will be used when
            this operation runs.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Pipeline.Builder]()
                context._parent_builder = self
                context._field_name = "pipeline"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Pipeline.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("pipeline", value)

        def retry_limit(self, value: Optional[int], /) -> Self:
            """
            RetryLimit configures how many times the operation may fail. When the
            failure limit is exceeded, the operation will not be retried.
            """
            return self._set("retry_limit", value)

    class BuilderContext(BuilderContextBase["OperationSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = OperationSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for OperationSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["OperationSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use OperationSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    mode: Optional[Literal["Pipeline"]] = "Pipeline"
    """
    Mode controls what type or "mode" of operation will be used.

    "Pipeline" indicates that an Operation specifies a pipeline of
    functions, each of which is responsible for implementing its logic.
    """
    pipeline: Annotated[List[Pipeline], Field(max_length=99, min_length=1)]
    """
    Pipeline is a list of operation function steps that will be used when
    this operation runs.
    """
    retry_limit: Annotated[Optional[int], Field(alias="retryLimit")] = None
    """
    RetryLimit configures how many times the operation may fail. When the
    failure limit is exceeded, the operation will not be retried.
    """


class AppliedResourceRef(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AppliedResourceRef"]:
            return AppliedResourceRef

        def build(self) -> "AppliedResourceRef":
            return AppliedResourceRef(**self._attrs)

        def api_version(self, value: str, /) -> Self:
            """
            APIVersion of the applied resource.
            """
            return self._set("api_version", value)

        def kind(self, value: str, /) -> Self:
            """
            Kind of the applied resource.
            """
            return self._set("kind", value)

        def name(self, value: str, /) -> Self:
            """
            Name of the applied resource.
            """
            return self._set("name", value)

        def namespace(self, value: Optional[str], /) -> Self:
            """
            Namespace of the applied resource.
            """
            return self._set("namespace", value)

    class BuilderContext(BuilderContextBase["AppliedResourceRef.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AppliedResourceRef.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AppliedResourceRef."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AppliedResourceRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AppliedResourceRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[str, Field(alias="apiVersion")]
    """
    APIVersion of the applied resource.
    """
    kind: str
    """
    Kind of the applied resource.
    """
    name: str
    """
    Name of the applied resource.
    """
    namespace: Optional[str] = None
    """
    Namespace of the applied resource.
    """


class PipelineModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PipelineModel"]:
            return PipelineModel

        def build(self) -> "PipelineModel":
            return PipelineModel(**self._attrs)

        def output(self, value: Optional[Dict[str, Any]], /) -> Self:
            """
            Output of this step.
            """
            return self._set("output", value)

        def step(self, value: str, /) -> Self:
            """
            Step name. Unique within its Pipeline.
            """
            return self._set("step", value)

    class BuilderContext(BuilderContextBase["PipelineModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PipelineModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PipelineModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["PipelineModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PipelineModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    output: Optional[Dict[str, Any]] = None
    """
    Output of this step.
    """
    step: str
    """
    Step name. Unique within its Pipeline.
    """


class OperationStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["OperationStatus"]:
            return OperationStatus

        def build(self) -> "OperationStatus":
            return OperationStatus(**self._attrs)

        @overload
        def applied_resource_refs(
            self, value_or_callback: List[AppliedResourceRef], /
        ) -> "OperationStatus.Builder": ...

        @overload
        def applied_resource_refs(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[AppliedResourceRef, AppliedResourceRef.Builder]],
                GenericListBuilder[AppliedResourceRef, AppliedResourceRef.Builder]
                | List[AppliedResourceRef],
            ],
            /,
        ) -> "OperationStatus.Builder": ...

        @overload
        def applied_resource_refs(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[AppliedResourceRef.Builder]: ...

        def applied_resource_refs(self, value_or_callback=None, /):
            """
            AppliedResourceRefs references all resources the Operation applied.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[AppliedResourceRef.Builder]()
                context._parent_builder = self
                context._field_name = "applied_resource_refs"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AppliedResourceRef.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("applied_resource_refs", value)

        @overload
        def conditions(
            self, value_or_callback: List[Condition], /
        ) -> "OperationStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Condition, Condition.Builder]],
                GenericListBuilder[Condition, Condition.Builder] | List[Condition],
            ],
            /,
        ) -> "OperationStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            """
            Conditions of the resource.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        def failures(self, value: Optional[int], /) -> Self:
            """
            Number of operation failures.
            """
            return self._set("failures", value)

        @overload
        def pipeline(
            self, value_or_callback: List[PipelineModel], /
        ) -> "OperationStatus.Builder": ...

        @overload
        def pipeline(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[PipelineModel, PipelineModel.Builder]],
                GenericListBuilder[PipelineModel, PipelineModel.Builder] | List[PipelineModel],
            ],
            /,
        ) -> "OperationStatus.Builder": ...

        @overload
        def pipeline(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[PipelineModel.Builder]: ...

        def pipeline(self, value_or_callback=None, /):
            """
            Pipeline represents the output of the pipeline steps that this operation
            ran.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[PipelineModel.Builder]()
                context._parent_builder = self
                context._field_name = "pipeline"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PipelineModel.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("pipeline", value)

    class BuilderContext(BuilderContextBase["OperationStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = OperationStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for OperationStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["OperationStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use OperationStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    applied_resource_refs: Annotated[
        Optional[List[AppliedResourceRef]], Field(alias="appliedResourceRefs")
    ] = None
    """
    AppliedResourceRefs references all resources the Operation applied.
    """
    conditions: Optional[List[Condition]] = None
    """
    Conditions of the resource.
    """
    failures: Optional[int] = None
    """
    Number of operation failures.
    """
    pipeline: Optional[List[PipelineModel]] = None
    """
    Pipeline represents the output of the pipeline steps that this operation
    ran.
    """


class PipelineModel1(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PipelineModel1"]:
            return PipelineModel1

        def build(self) -> "PipelineModel1":
            return PipelineModel1(**self._attrs)

        @overload
        def credentials(
            self, value_or_callback: List[Credential], /
        ) -> "PipelineModel1.Builder": ...

        @overload
        def credentials(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Credential, Credential.Builder]],
                GenericListBuilder[Credential, Credential.Builder] | List[Credential],
            ],
            /,
        ) -> "PipelineModel1.Builder": ...

        @overload
        def credentials(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Credential.Builder]: ...

        def credentials(self, value_or_callback=None, /):
            """
            Credentials are optional credentials that the operation function needs.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Credential.Builder]()
                context._parent_builder = self
                context._field_name = "credentials"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Credential.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("credentials", value)

        @overload
        def function_ref(self, value_or_callback: FunctionRef, /) -> "PipelineModel1.Builder": ...

        @overload
        def function_ref(
            self,
            value_or_callback: Callable[[FunctionRef.Builder], FunctionRef.Builder | FunctionRef],
            /,
        ) -> "PipelineModel1.Builder": ...

        @overload
        def function_ref(self, value_or_callback: Never = ...) -> "FunctionRef.BuilderContext": ...

        def function_ref(self, value_or_callback=None, /):
            """
            FunctionRef is a reference to the function this step should
            execute.
            """
            if self._in_context and value_or_callback is None:
                context = FunctionRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "function_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(FunctionRef.builder())
                if isinstance(output, FunctionRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("function_ref", value)

        def input(self, value: Optional[Dict[str, Any]], /) -> Self:
            """
            Input is an optional, arbitrary Kubernetes resource (i.e. a resource
            with an apiVersion and kind) that will be passed to the unction as
            the 'input' of its RunFunctionRequest.
            """
            return self._set("input", value)

        @overload
        def requirements(
            self, value_or_callback: Optional[Requirements], /
        ) -> "PipelineModel1.Builder": ...

        @overload
        def requirements(
            self,
            value_or_callback: Callable[
                [Requirements.Builder], Requirements.Builder | Requirements
            ],
            /,
        ) -> "PipelineModel1.Builder": ...

        @overload
        def requirements(self, value_or_callback: Never = ...) -> "Requirements.BuilderContext": ...

        def requirements(self, value_or_callback=None, /):
            """
            Requirements are resource requirements that will be satisfied before
            this pipeline step is called for the first time. This allows
            pre-populating required resources without requiring a function to
            request them first.
            """
            if self._in_context and value_or_callback is None:
                context = Requirements.BuilderContext()
                context._parent_builder = self
                context._field_name = "requirements"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Requirements.builder())
                if isinstance(output, Requirements.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("requirements", value)

        def step(self, value: str, /) -> Self:
            """
            Step name. Must be unique within its Pipeline.
            """
            return self._set("step", value)

    class BuilderContext(BuilderContextBase["PipelineModel1.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PipelineModel1.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PipelineModel1."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["PipelineModel1", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PipelineModel1.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    credentials: Optional[List[Credential]] = None
    """
    Credentials are optional credentials that the operation function needs.
    """
    function_ref: Annotated[FunctionRef, Field(alias="functionRef")]
    """
    FunctionRef is a reference to the function this step should
    execute.
    """
    input: Optional[Dict[str, Any]] = None
    """
    Input is an optional, arbitrary Kubernetes resource (i.e. a resource
    with an apiVersion and kind) that will be passed to the unction as
    the 'input' of its RunFunctionRequest.
    """
    requirements: Optional[Requirements] = None
    """
    Requirements are resource requirements that will be satisfied before
    this pipeline step is called for the first time. This allows
    pre-populating required resources without requiring a function to
    request them first.
    """
    step: str
    """
    Step name. Must be unique within its Pipeline.
    """


class Watch(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Watch"]:
            return Watch

        def build(self) -> "Watch":
            return Watch(**self._attrs)

        def api_version(self, value: str, /) -> Self:
            """
            APIVersion of the resource to watch.
            """
            return self._set("api_version", value)

        def kind(self, value: str, /) -> Self:
            """
            Kind of the resource to watch.
            """
            return self._set("kind", value)

        def match_labels(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            MatchLabels selects resources by label. If empty, all resources of the
            specified kind are watched.
            """
            return self._set("match_labels", value)

        def namespace(self, value: Optional[str], /) -> Self:
            """
            Namespace selects resources in a specific namespace. If empty, all
            namespaces are watched. Only applicable for namespaced resources.
            """
            return self._set("namespace", value)

    class BuilderContext(BuilderContextBase["Watch.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Watch.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Watch."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Watch", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Watch.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[str, Field(alias="apiVersion")]
    """
    APIVersion of the resource to watch.
    """
    kind: str
    """
    Kind of the resource to watch.
    """
    match_labels: Annotated[Optional[Dict[str, str]], Field(alias="matchLabels")] = None
    """
    MatchLabels selects resources by label. If empty, all resources of the
    specified kind are watched.
    """
    namespace: Optional[str] = None
    """
    Namespace selects resources in a specific namespace. If empty, all
    namespaces are watched. Only applicable for namespaced resources.
    """


class WatchOperationSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["WatchOperationSpec"]:
            return WatchOperationSpec

        def build(self) -> "WatchOperationSpec":
            return WatchOperationSpec(**self._attrs)

        def concurrency_policy(
            self, value: Optional[Literal["Allow", "Forbid", "Replace"]], /
        ) -> Self:
            """
            ConcurrencyPolicy specifies how to treat concurrent executions of an
            operation.
            """
            return self._set("concurrency_policy", value)

        def failed_history_limit(self, value: Optional[int], /) -> Self:
            """
            FailedHistoryLimit is the number of failed Operations to retain.
            """
            return self._set("failed_history_limit", value)

        @overload
        def operation_template(
            self, value_or_callback: OperationTemplate, /
        ) -> "WatchOperationSpec.Builder": ...

        @overload
        def operation_template(
            self,
            value_or_callback: Callable[
                [OperationTemplate.Builder],
                OperationTemplate.Builder | OperationTemplate,
            ],
            /,
        ) -> "WatchOperationSpec.Builder": ...

        @overload
        def operation_template(
            self, value_or_callback: Never = ...
        ) -> "OperationTemplate.BuilderContext": ...

        def operation_template(self, value_or_callback=None, /):
            """
            OperationTemplate is the template for the Operation to be created.
            """
            if self._in_context and value_or_callback is None:
                context = OperationTemplate.BuilderContext()
                context._parent_builder = self
                context._field_name = "operation_template"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(OperationTemplate.builder())
                if isinstance(output, OperationTemplate.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("operation_template", value)

        def successful_history_limit(self, value: Optional[int], /) -> Self:
            """
            SuccessfulHistoryLimit is the number of successful Operations to retain.
            """
            return self._set("successful_history_limit", value)

        @overload
        def watch(self, value_or_callback: Watch, /) -> "WatchOperationSpec.Builder": ...

        @overload
        def watch(
            self, value_or_callback: Callable[[Watch.Builder], Watch.Builder | Watch], /
        ) -> "WatchOperationSpec.Builder": ...

        @overload
        def watch(self, value_or_callback: Never = ...) -> "Watch.BuilderContext": ...

        def watch(self, value_or_callback=None, /):
            """
            Watch specifies the resource to watch.
            """
            if self._in_context and value_or_callback is None:
                context = Watch.BuilderContext()
                context._parent_builder = self
                context._field_name = "watch"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Watch.builder())
                if isinstance(output, Watch.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("watch", value)

    class BuilderContext(BuilderContextBase["WatchOperationSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = WatchOperationSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for WatchOperationSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["WatchOperationSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use WatchOperationSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    concurrency_policy: Annotated[
        Optional[Literal["Allow", "Forbid", "Replace"]],
        Field(alias="concurrencyPolicy"),
    ] = "Allow"
    """
    ConcurrencyPolicy specifies how to treat concurrent executions of an
    operation.
    """
    failed_history_limit: Annotated[Optional[int], Field(alias="failedHistoryLimit")] = 1
    """
    FailedHistoryLimit is the number of failed Operations to retain.
    """
    operation_template: Annotated[OperationTemplate, Field(alias="operationTemplate")]
    """
    OperationTemplate is the template for the Operation to be created.
    """
    successful_history_limit: Annotated[Optional[int], Field(alias="successfulHistoryLimit")] = 3
    """
    SuccessfulHistoryLimit is the number of successful Operations to retain.
    """
    watch: Watch
    """
    Watch specifies the resource to watch.
    """


class WatchOperationStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["WatchOperationStatus"]:
            return WatchOperationStatus

        def build(self) -> "WatchOperationStatus":
            return WatchOperationStatus(**self._attrs)

        @overload
        def conditions(
            self, value_or_callback: List[Condition], /
        ) -> "WatchOperationStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Condition, Condition.Builder]],
                GenericListBuilder[Condition, Condition.Builder] | List[Condition],
            ],
            /,
        ) -> "WatchOperationStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            """
            Conditions of the resource.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        def last_schedule_time(self, value: Optional[AwareDatetime], /) -> Self:
            """
            LastScheduleTime is the last time the WatchOperation created an
            Operation.
            """
            return self._set("last_schedule_time", value)

        def last_successful_time(self, value: Optional[AwareDatetime], /) -> Self:
            """
            LastSuccessfulTime is the last time the WatchOperation successfully
            completed an Operation.
            """
            return self._set("last_successful_time", value)

        @overload
        def running_operation_refs(
            self, value_or_callback: List[RunningOperationRef], /
        ) -> "WatchOperationStatus.Builder": ...

        @overload
        def running_operation_refs(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[RunningOperationRef, RunningOperationRef.Builder]],
                GenericListBuilder[RunningOperationRef, RunningOperationRef.Builder]
                | List[RunningOperationRef],
            ],
            /,
        ) -> "WatchOperationStatus.Builder": ...

        @overload
        def running_operation_refs(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[RunningOperationRef.Builder]: ...

        def running_operation_refs(self, value_or_callback=None, /):
            """
            RunningOperationRefs is a list of currently running Operations.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[RunningOperationRef.Builder]()
                context._parent_builder = self
                context._field_name = "running_operation_refs"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(RunningOperationRef.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("running_operation_refs", value)

        def watching_resources(self, value: Optional[int], /) -> Self:
            """
            WatchingResources is the number of resources this WatchOperation is
            currently watching.
            """
            return self._set("watching_resources", value)

    class BuilderContext(BuilderContextBase["WatchOperationStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = WatchOperationStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for WatchOperationStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["WatchOperationStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use WatchOperationStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    conditions: Optional[List[Condition]] = None
    """
    Conditions of the resource.
    """
    last_schedule_time: Annotated[Optional[AwareDatetime], Field(alias="lastScheduleTime")] = None
    """
    LastScheduleTime is the last time the WatchOperation created an
    Operation.
    """
    last_successful_time: Annotated[Optional[AwareDatetime], Field(alias="lastSuccessfulTime")] = (
        None
    )
    """
    LastSuccessfulTime is the last time the WatchOperation successfully
    completed an Operation.
    """
    running_operation_refs: Annotated[
        Optional[List[RunningOperationRef]], Field(alias="runningOperationRefs")
    ] = None
    """
    RunningOperationRefs is a list of currently running Operations.
    """
    watching_resources: Annotated[Optional[int], Field(alias="watchingResources")] = None
    """
    WatchingResources is the number of resources this WatchOperation is
    currently watching.
    """


class CronOperation(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["CronOperation"]:
            return CronOperation

        def build(self) -> "CronOperation":
            return CronOperation(**self._attrs)

        def api_version(self, value: Optional[Literal["ops.crossplane.io/v1alpha1"]], /) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["CronOperation"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "CronOperation.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "CronOperation.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(
            self, value_or_callback: Optional[CronOperationSpec], /
        ) -> "CronOperation.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [CronOperationSpec.Builder],
                CronOperationSpec.Builder | CronOperationSpec,
            ],
            /,
        ) -> "CronOperation.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "CronOperationSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = CronOperationSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(CronOperationSpec.builder())
                if isinstance(output, CronOperationSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(
            self, value_or_callback: Optional[CronOperationStatus], /
        ) -> "CronOperation.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [CronOperationStatus.Builder],
                CronOperationStatus.Builder | CronOperationStatus,
            ],
            /,
        ) -> "CronOperation.Builder": ...

        @overload
        def status(
            self, value_or_callback: Never = ...
        ) -> "CronOperationStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = CronOperationStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(CronOperationStatus.builder())
                if isinstance(output, CronOperationStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["CronOperation.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = CronOperation.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for CronOperation."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["CronOperation", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use CronOperation.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[
        Optional[Literal["ops.crossplane.io/v1alpha1"]], Field(alias="apiVersion")
    ] = "ops.crossplane.io/v1alpha1"
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["CronOperation"]] = "CronOperation"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: Optional[CronOperationSpec] = None
    status: Optional[CronOperationStatus] = None


class Operation(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Operation"]:
            return Operation

        def build(self) -> "Operation":
            return Operation(**self._attrs)

        def api_version(self, value: Optional[Literal["ops.crossplane.io/v1alpha1"]], /) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["Operation"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "Operation.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "Operation.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(self, value_or_callback: Optional[OperationSpec], /) -> "Operation.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [OperationSpec.Builder], OperationSpec.Builder | OperationSpec
            ],
            /,
        ) -> "Operation.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "OperationSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = OperationSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(OperationSpec.builder())
                if isinstance(output, OperationSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(
            self, value_or_callback: Optional[OperationStatus], /
        ) -> "Operation.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [OperationStatus.Builder], OperationStatus.Builder | OperationStatus
            ],
            /,
        ) -> "Operation.Builder": ...

        @overload
        def status(self, value_or_callback: Never = ...) -> "OperationStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = OperationStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(OperationStatus.builder())
                if isinstance(output, OperationStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["Operation.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Operation.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Operation."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Operation", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Operation.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[
        Optional[Literal["ops.crossplane.io/v1alpha1"]], Field(alias="apiVersion")
    ] = "ops.crossplane.io/v1alpha1"
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["Operation"]] = "Operation"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: Optional[OperationSpec] = None
    status: Optional[OperationStatus] = None


class WatchOperation(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["WatchOperation"]:
            return WatchOperation

        def build(self) -> "WatchOperation":
            return WatchOperation(**self._attrs)

        def api_version(self, value: Optional[Literal["ops.crossplane.io/v1alpha1"]], /) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["WatchOperation"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "WatchOperation.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "WatchOperation.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(
            self, value_or_callback: Optional[WatchOperationSpec], /
        ) -> "WatchOperation.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [WatchOperationSpec.Builder],
                WatchOperationSpec.Builder | WatchOperationSpec,
            ],
            /,
        ) -> "WatchOperation.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "WatchOperationSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = WatchOperationSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(WatchOperationSpec.builder())
                if isinstance(output, WatchOperationSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(
            self, value_or_callback: Optional[WatchOperationStatus], /
        ) -> "WatchOperation.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [WatchOperationStatus.Builder],
                WatchOperationStatus.Builder | WatchOperationStatus,
            ],
            /,
        ) -> "WatchOperation.Builder": ...

        @overload
        def status(
            self, value_or_callback: Never = ...
        ) -> "WatchOperationStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = WatchOperationStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(WatchOperationStatus.builder())
                if isinstance(output, WatchOperationStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["WatchOperation.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = WatchOperation.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for WatchOperation."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["WatchOperation", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use WatchOperation.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[
        Optional[Literal["ops.crossplane.io/v1alpha1"]], Field(alias="apiVersion")
    ] = "ops.crossplane.io/v1alpha1"
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["WatchOperation"]] = "WatchOperation"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: Optional[WatchOperationSpec] = None
    status: Optional[WatchOperationStatus] = None
