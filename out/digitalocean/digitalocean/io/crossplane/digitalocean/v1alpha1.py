# Generated by cloudcoil-model-codegen v0.5.8
# DO NOT EDIT


from __future__ import annotations

from typing import (
    Annotated,
    Callable,
    List,
    Literal,
    Optional,
    Type,
    overload,
)

from cloudcoil import apimachinery
from cloudcoil.pydantic import (
    BaseModel,
    BaseModelBuilder,
    BuilderContextBase,
    GenericListBuilder,
    ListBuilderContext,
    Never,
    Self,
)
from cloudcoil.resources import Resource
from pydantic import AwareDatetime, Field


class Env(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Env"]:
            return Env

        def build(self) -> "Env":
            return Env(**self._attrs)

        def name(self, value: str, /) -> Self:
            """
            Name is the name of an environment variable.
            """
            return self._set("name", value)

    class BuilderContext(BuilderContextBase["Env.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Env.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Env."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Env", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Env.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: str
    """
    Name is the name of an environment variable.
    """


class Fs(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Fs"]:
            return Fs

        def build(self) -> "Fs":
            return Fs(**self._attrs)

        def path(self, value: str, /) -> Self:
            """
            Path is a filesystem path.
            """
            return self._set("path", value)

    class BuilderContext(BuilderContextBase["Fs.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Fs.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Fs."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Fs", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Fs.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    path: str
    """
    Path is a filesystem path.
    """


class SecretRef(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["SecretRef"]:
            return SecretRef

        def build(self) -> "SecretRef":
            return SecretRef(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            The key to select.
            """
            return self._set("key", value)

        def name(self, value: str, /) -> Self:
            """
            Name of the secret.
            """
            return self._set("name", value)

        def namespace(self, value: str, /) -> Self:
            """
            Namespace of the secret.
            """
            return self._set("namespace", value)

    class BuilderContext(BuilderContextBase["SecretRef.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SecretRef.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SecretRef."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["SecretRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SecretRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: str
    """
    The key to select.
    """
    name: str
    """
    Name of the secret.
    """
    namespace: str
    """
    Namespace of the secret.
    """


class Auth(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Auth"]:
            return Auth

        def build(self) -> "Auth":
            return Auth(**self._attrs)

        @overload
        def env(self, value_or_callback: Optional[Env], /) -> "Auth.Builder": ...

        @overload
        def env(
            self, value_or_callback: Callable[[Env.Builder], Env.Builder | Env], /
        ) -> "Auth.Builder": ...

        @overload
        def env(self, value_or_callback: Never = ...) -> "Env.BuilderContext": ...

        def env(self, value_or_callback=None, /):
            """
            Env is a reference to an environment variable that contains credentials
            that must be used to connect to the provider.
            """
            if self._in_context and value_or_callback is None:
                context = Env.BuilderContext()
                context._parent_builder = self
                context._field_name = "env"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Env.builder())
                if isinstance(output, Env.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("env", value)

        @overload
        def fs(self, value_or_callback: Optional[Fs], /) -> "Auth.Builder": ...

        @overload
        def fs(
            self, value_or_callback: Callable[[Fs.Builder], Fs.Builder | Fs], /
        ) -> "Auth.Builder": ...

        @overload
        def fs(self, value_or_callback: Never = ...) -> "Fs.BuilderContext": ...

        def fs(self, value_or_callback=None, /):
            """
            Fs is a reference to a filesystem location that contains credentials that
            must be used to connect to the provider.
            """
            if self._in_context and value_or_callback is None:
                context = Fs.BuilderContext()
                context._parent_builder = self
                context._field_name = "fs"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Fs.builder())
                if isinstance(output, Fs.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("fs", value)

        @overload
        def secret_ref(self, value_or_callback: Optional[SecretRef], /) -> "Auth.Builder": ...

        @overload
        def secret_ref(
            self,
            value_or_callback: Callable[[SecretRef.Builder], SecretRef.Builder | SecretRef],
            /,
        ) -> "Auth.Builder": ...

        @overload
        def secret_ref(self, value_or_callback: Never = ...) -> "SecretRef.BuilderContext": ...

        def secret_ref(self, value_or_callback=None, /):
            """
            A SecretRef is a reference to a secret key that contains the credentials
            that must be used to connect to the provider.
            """
            if self._in_context and value_or_callback is None:
                context = SecretRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "secret_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SecretRef.builder())
                if isinstance(output, SecretRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("secret_ref", value)

        def source(self, value: Literal["None", "Secret", "Environment", "Filesystem"], /) -> Self:
            """
            Source of the credentials.
            """
            return self._set("source", value)

    class BuilderContext(BuilderContextBase["Auth.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Auth.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Auth."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Auth", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Auth.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    env: Optional[Env] = None
    """
    Env is a reference to an environment variable that contains credentials
    that must be used to connect to the provider.
    """
    fs: Optional[Fs] = None
    """
    Fs is a reference to a filesystem location that contains credentials that
    must be used to connect to the provider.
    """
    secret_ref: Annotated[Optional[SecretRef], Field(alias="secretRef")] = None
    """
    A SecretRef is a reference to a secret key that contains the credentials
    that must be used to connect to the provider.
    """
    source: Literal["None", "Secret", "Environment", "Filesystem"]
    """
    Source of the credentials.
    """


class Kubernetes(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Kubernetes"]:
            return Kubernetes

        def build(self) -> "Kubernetes":
            return Kubernetes(**self._attrs)

        @overload
        def auth(self, value_or_callback: Auth, /) -> "Kubernetes.Builder": ...

        @overload
        def auth(
            self, value_or_callback: Callable[[Auth.Builder], Auth.Builder | Auth], /
        ) -> "Kubernetes.Builder": ...

        @overload
        def auth(self, value_or_callback: Never = ...) -> "Auth.BuilderContext": ...

        def auth(self, value_or_callback=None, /):
            """
            Credentials used to connect to the Kubernetes API.
            """
            if self._in_context and value_or_callback is None:
                context = Auth.BuilderContext()
                context._parent_builder = self
                context._field_name = "auth"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Auth.builder())
                if isinstance(output, Auth.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("auth", value)

    class BuilderContext(BuilderContextBase["Kubernetes.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Kubernetes.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Kubernetes."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Kubernetes", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Kubernetes.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    auth: Auth
    """
    Credentials used to connect to the Kubernetes API.
    """


class ConfigRef(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ConfigRef"]:
            return ConfigRef

        def build(self) -> "ConfigRef":
            return ConfigRef(**self._attrs)

        def api_version(self, value: str, /) -> Self:
            """
            APIVersion of the referenced config.
            """
            return self._set("api_version", value)

        def kind(self, value: str, /) -> Self:
            """
            Kind of the referenced config.
            """
            return self._set("kind", value)

        def name(self, value: str, /) -> Self:
            """
            Name of the referenced config.
            """
            return self._set("name", value)

    class BuilderContext(BuilderContextBase["ConfigRef.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ConfigRef.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ConfigRef."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ConfigRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ConfigRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[str, Field(alias="apiVersion")]
    """
    APIVersion of the referenced config.
    """
    kind: str
    """
    Kind of the referenced config.
    """
    name: str
    """
    Name of the referenced config.
    """


class Plugin(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Plugin"]:
            return Plugin

        def build(self) -> "Plugin":
            return Plugin(**self._attrs)

        @overload
        def config_ref(self, value_or_callback: Optional[ConfigRef], /) -> "Plugin.Builder": ...

        @overload
        def config_ref(
            self,
            value_or_callback: Callable[[ConfigRef.Builder], ConfigRef.Builder | ConfigRef],
            /,
        ) -> "Plugin.Builder": ...

        @overload
        def config_ref(self, value_or_callback: Never = ...) -> "ConfigRef.BuilderContext": ...

        def config_ref(self, value_or_callback=None, /):
            """
            ConfigRef contains store config reference info.
            """
            if self._in_context and value_or_callback is None:
                context = ConfigRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "config_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ConfigRef.builder())
                if isinstance(output, ConfigRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("config_ref", value)

        def endpoint(self, value: Optional[str], /) -> Self:
            """
            Endpoint is the endpoint of the gRPC server.
            """
            return self._set("endpoint", value)

    class BuilderContext(BuilderContextBase["Plugin.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Plugin.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Plugin."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Plugin", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Plugin.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    config_ref: Annotated[Optional[ConfigRef], Field(alias="configRef")] = None
    """
    ConfigRef contains store config reference info.
    """
    endpoint: Optional[str] = None
    """
    Endpoint is the endpoint of the gRPC server.
    """


class StoreConfigSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["StoreConfigSpec"]:
            return StoreConfigSpec

        def build(self) -> "StoreConfigSpec":
            return StoreConfigSpec(**self._attrs)

        def default_scope(self, value: str, /) -> Self:
            """
            DefaultScope used for scoping secrets for "cluster-scoped" resources.
            If store type is "Kubernetes", this would mean the default namespace to
            store connection secrets for cluster scoped resources.
            In case of "Vault", this would be used as the default parent path.
            Typically, should be set as Crossplane installation namespace.
            """
            return self._set("default_scope", value)

        @overload
        def kubernetes(
            self, value_or_callback: Optional[Kubernetes], /
        ) -> "StoreConfigSpec.Builder": ...

        @overload
        def kubernetes(
            self,
            value_or_callback: Callable[[Kubernetes.Builder], Kubernetes.Builder | Kubernetes],
            /,
        ) -> "StoreConfigSpec.Builder": ...

        @overload
        def kubernetes(self, value_or_callback: Never = ...) -> "Kubernetes.BuilderContext": ...

        def kubernetes(self, value_or_callback=None, /):
            """
            Kubernetes configures a Kubernetes secret store.
            If the "type" is "Kubernetes" but no config provided, in cluster config
            will be used.
            """
            if self._in_context and value_or_callback is None:
                context = Kubernetes.BuilderContext()
                context._parent_builder = self
                context._field_name = "kubernetes"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Kubernetes.builder())
                if isinstance(output, Kubernetes.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("kubernetes", value)

        @overload
        def plugin(self, value_or_callback: Optional[Plugin], /) -> "StoreConfigSpec.Builder": ...

        @overload
        def plugin(
            self,
            value_or_callback: Callable[[Plugin.Builder], Plugin.Builder | Plugin],
            /,
        ) -> "StoreConfigSpec.Builder": ...

        @overload
        def plugin(self, value_or_callback: Never = ...) -> "Plugin.BuilderContext": ...

        def plugin(self, value_or_callback=None, /):
            """
            Plugin configures External secret store as a plugin.
            """
            if self._in_context and value_or_callback is None:
                context = Plugin.BuilderContext()
                context._parent_builder = self
                context._field_name = "plugin"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Plugin.builder())
                if isinstance(output, Plugin.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("plugin", value)

        def type(self, value: Optional[Literal["Kubernetes", "Vault", "Plugin"]], /) -> Self:
            """
            Type configures which secret store to be used. Only the configuration
            block for this store will be used and others will be ignored if provided.
            Default is Kubernetes.
            """
            return self._set("type", value)

    class BuilderContext(BuilderContextBase["StoreConfigSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = StoreConfigSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for StoreConfigSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["StoreConfigSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use StoreConfigSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    default_scope: Annotated[str, Field(alias="defaultScope")]
    """
    DefaultScope used for scoping secrets for "cluster-scoped" resources.
    If store type is "Kubernetes", this would mean the default namespace to
    store connection secrets for cluster scoped resources.
    In case of "Vault", this would be used as the default parent path.
    Typically, should be set as Crossplane installation namespace.
    """
    kubernetes: Optional[Kubernetes] = None
    """
    Kubernetes configures a Kubernetes secret store.
    If the "type" is "Kubernetes" but no config provided, in cluster config
    will be used.
    """
    plugin: Optional[Plugin] = None
    """
    Plugin configures External secret store as a plugin.
    """
    type: Optional[Literal["Kubernetes", "Vault", "Plugin"]] = "Kubernetes"
    """
    Type configures which secret store to be used. Only the configuration
    block for this store will be used and others will be ignored if provided.
    Default is Kubernetes.
    """


class Condition(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Condition"]:
            return Condition

        def build(self) -> "Condition":
            return Condition(**self._attrs)

        def last_transition_time(self, value: AwareDatetime, /) -> Self:
            """
            LastTransitionTime is the last time this condition transitioned from one
            status to another.
            """
            return self._set("last_transition_time", value)

        def message(self, value: Optional[str], /) -> Self:
            """
            A Message containing details about this condition's last transition from
            one status to another, if any.
            """
            return self._set("message", value)

        def observed_generation(self, value: Optional[int], /) -> Self:
            """
            ObservedGeneration represents the .metadata.generation that the condition was set based upon.
            For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
            with respect to the current state of the instance.
            """
            return self._set("observed_generation", value)

        def reason(self, value: str, /) -> Self:
            """
            A Reason for this condition's last transition from one status to another.
            """
            return self._set("reason", value)

        def status(self, value: str, /) -> Self:
            """
            Status of this condition; is it currently True, False, or Unknown?
            """
            return self._set("status", value)

        def type(self, value: str, /) -> Self:
            """
            Type of this condition. At most one of each condition type may apply to
            a resource at any point in time.
            """
            return self._set("type", value)

    class BuilderContext(BuilderContextBase["Condition.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Condition.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Condition."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Condition", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Condition.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    last_transition_time: Annotated[AwareDatetime, Field(alias="lastTransitionTime")]
    """
    LastTransitionTime is the last time this condition transitioned from one
    status to another.
    """
    message: Optional[str] = None
    """
    A Message containing details about this condition's last transition from
    one status to another, if any.
    """
    observed_generation: Annotated[Optional[int], Field(alias="observedGeneration")] = None
    """
    ObservedGeneration represents the .metadata.generation that the condition was set based upon.
    For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
    with respect to the current state of the instance.
    """
    reason: str
    """
    A Reason for this condition's last transition from one status to another.
    """
    status: str
    """
    Status of this condition; is it currently True, False, or Unknown?
    """
    type: str
    """
    Type of this condition. At most one of each condition type may apply to
    a resource at any point in time.
    """


class StoreConfigStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["StoreConfigStatus"]:
            return StoreConfigStatus

        def build(self) -> "StoreConfigStatus":
            return StoreConfigStatus(**self._attrs)

        @overload
        def conditions(
            self, value_or_callback: List[Condition], /
        ) -> "StoreConfigStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Condition, Condition.Builder]],
                GenericListBuilder[Condition, Condition.Builder] | List[Condition],
            ],
            /,
        ) -> "StoreConfigStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            """
            Conditions of the resource.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

    class BuilderContext(BuilderContextBase["StoreConfigStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = StoreConfigStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for StoreConfigStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["StoreConfigStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use StoreConfigStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    conditions: Optional[List[Condition]] = None
    """
    Conditions of the resource.
    """


class StoreConfig(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["StoreConfig"]:
            return StoreConfig

        def build(self) -> "StoreConfig":
            return StoreConfig(**self._attrs)

        def api_version(
            self, value: Optional[Literal["digitalocean.crossplane.io/v1alpha1"]], /
        ) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["StoreConfig"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "StoreConfig.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "StoreConfig.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(self, value_or_callback: StoreConfigSpec, /) -> "StoreConfig.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [StoreConfigSpec.Builder], StoreConfigSpec.Builder | StoreConfigSpec
            ],
            /,
        ) -> "StoreConfig.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "StoreConfigSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = StoreConfigSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(StoreConfigSpec.builder())
                if isinstance(output, StoreConfigSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(
            self, value_or_callback: Optional[StoreConfigStatus], /
        ) -> "StoreConfig.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [StoreConfigStatus.Builder],
                StoreConfigStatus.Builder | StoreConfigStatus,
            ],
            /,
        ) -> "StoreConfig.Builder": ...

        @overload
        def status(self, value_or_callback: Never = ...) -> "StoreConfigStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = StoreConfigStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(StoreConfigStatus.builder())
                if isinstance(output, StoreConfigStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["StoreConfig.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = StoreConfig.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for StoreConfig."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["StoreConfig", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use StoreConfig.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[
        Optional[Literal["digitalocean.crossplane.io/v1alpha1"]],
        Field(alias="apiVersion"),
    ] = "digitalocean.crossplane.io/v1alpha1"
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["StoreConfig"]] = "StoreConfig"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: StoreConfigSpec
    status: Optional[StoreConfigStatus] = None
