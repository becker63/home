# Generated by cloudcoil-model-codegen v0.5.8
# DO NOT EDIT


from __future__ import annotations

from typing import (
    Annotated,
    Callable,
    Dict,
    List,
    Literal,
    Optional,
    Type,
    overload,
)

from cloudcoil import apimachinery
from cloudcoil.pydantic import (
    BaseModel,
    BaseModelBuilder,
    BuilderContextBase,
    GenericListBuilder,
    ListBuilderContext,
    Never,
    Self,
)
from cloudcoil.resources import Resource
from pydantic import AwareDatetime, Field


class CorsRule(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["CorsRule"]:
            return CorsRule

        def build(self) -> "CorsRule":
            return CorsRule(**self._attrs)

        def allowed_headers(self, value: Optional[List[str]], /) -> Self:
            """
            Set of Headers that are specified in the Access-Control-Request-Headers header.
            """
            return self._set("allowed_headers", value)

        def allowed_methods(self, value: Optional[List[str]], /) -> Self:
            """
            Set of HTTP methods that you allow the origin to execute. Valid values are GET, PUT, HEAD, POST, and DELETE.
            """
            return self._set("allowed_methods", value)

        def allowed_origins(self, value: Optional[List[str]], /) -> Self:
            """
            Set of origins you want customers to be able to access the bucket from.
            """
            return self._set("allowed_origins", value)

        def expose_headers(self, value: Optional[List[str]], /) -> Self:
            """
            Set of headers in the response that you want customers to be able to access from their applications (for example, from a JavaScript XMLHttpRequest object).
            """
            return self._set("expose_headers", value)

        def id(self, value: Optional[str], /) -> Self:
            """
            Unique identifier for the rule. The value cannot be longer than 255 characters.
            """
            return self._set("id", value)

        def max_age_seconds(self, value: Optional[float], /) -> Self:
            """
            Time in seconds that your browser is to cache the preflight response for the specified resource.
            """
            return self._set("max_age_seconds", value)

    class BuilderContext(BuilderContextBase["CorsRule.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = CorsRule.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for CorsRule."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["CorsRule", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use CorsRule.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    allowed_headers: Annotated[Optional[List[str]], Field(alias="allowedHeaders")] = None
    """
    Set of Headers that are specified in the Access-Control-Request-Headers header.
    """
    allowed_methods: Annotated[Optional[List[str]], Field(alias="allowedMethods")] = None
    """
    Set of HTTP methods that you allow the origin to execute. Valid values are GET, PUT, HEAD, POST, and DELETE.
    """
    allowed_origins: Annotated[Optional[List[str]], Field(alias="allowedOrigins")] = None
    """
    Set of origins you want customers to be able to access the bucket from.
    """
    expose_headers: Annotated[Optional[List[str]], Field(alias="exposeHeaders")] = None
    """
    Set of headers in the response that you want customers to be able to access from their applications (for example, from a JavaScript XMLHttpRequest object).
    """
    id: Optional[str] = None
    """
    Unique identifier for the rule. The value cannot be longer than 255 characters.
    """
    max_age_seconds: Annotated[Optional[float], Field(alias="maxAgeSeconds")] = None
    """
    Time in seconds that your browser is to cache the preflight response for the specified resource.
    """


class ForProvider(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ForProvider"]:
            return ForProvider

        def build(self) -> "ForProvider":
            return ForProvider(**self._attrs)

        def bucket(self, value: Optional[str], /) -> Self:
            """
            The name of the bucket to which to apply the CORS configuration.
            Bucket ID
            """
            return self._set("bucket", value)

        @overload
        def cors_rule(self, value_or_callback: List[CorsRule], /) -> "ForProvider.Builder": ...

        @overload
        def cors_rule(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[CorsRule, CorsRule.Builder]],
                GenericListBuilder[CorsRule, CorsRule.Builder] | List[CorsRule],
            ],
            /,
        ) -> "ForProvider.Builder": ...

        @overload
        def cors_rule(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[CorsRule.Builder]: ...

        def cors_rule(self, value_or_callback=None, /):
            """
            Set of origins and methods (cross-origin access that you want to allow). See below. You can configure up to 100 rules.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[CorsRule.Builder]()
                context._parent_builder = self
                context._field_name = "cors_rule"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(CorsRule.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("cors_rule", value)

        def region(self, value: Optional[str], /) -> Self:
            """
            The region where the bucket resides.
            """
            return self._set("region", value)

    class BuilderContext(BuilderContextBase["ForProvider.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ForProvider.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ForProvider."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ForProvider", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ForProvider.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    bucket: Optional[str] = None
    """
    The name of the bucket to which to apply the CORS configuration.
    Bucket ID
    """
    cors_rule: Annotated[Optional[List[CorsRule]], Field(alias="corsRule")] = None
    """
    Set of origins and methods (cross-origin access that you want to allow). See below. You can configure up to 100 rules.
    """
    region: Optional[str] = None
    """
    The region where the bucket resides.
    """


class InitProvider(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["InitProvider"]:
            return InitProvider

        def build(self) -> "InitProvider":
            return InitProvider(**self._attrs)

        def bucket(self, value: Optional[str], /) -> Self:
            """
            The name of the bucket to which to apply the CORS configuration.
            Bucket ID
            """
            return self._set("bucket", value)

        @overload
        def cors_rule(self, value_or_callback: List[CorsRule], /) -> "InitProvider.Builder": ...

        @overload
        def cors_rule(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[CorsRule, CorsRule.Builder]],
                GenericListBuilder[CorsRule, CorsRule.Builder] | List[CorsRule],
            ],
            /,
        ) -> "InitProvider.Builder": ...

        @overload
        def cors_rule(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[CorsRule.Builder]: ...

        def cors_rule(self, value_or_callback=None, /):
            """
            Set of origins and methods (cross-origin access that you want to allow). See below. You can configure up to 100 rules.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[CorsRule.Builder]()
                context._parent_builder = self
                context._field_name = "cors_rule"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(CorsRule.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("cors_rule", value)

        def region(self, value: Optional[str], /) -> Self:
            """
            The region where the bucket resides.
            """
            return self._set("region", value)

    class BuilderContext(BuilderContextBase["InitProvider.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = InitProvider.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for InitProvider."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["InitProvider", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use InitProvider.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    bucket: Optional[str] = None
    """
    The name of the bucket to which to apply the CORS configuration.
    Bucket ID
    """
    cors_rule: Annotated[Optional[List[CorsRule]], Field(alias="corsRule")] = None
    """
    Set of origins and methods (cross-origin access that you want to allow). See below. You can configure up to 100 rules.
    """
    region: Optional[str] = None
    """
    The region where the bucket resides.
    """


class Policy(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Policy"]:
            return Policy

        def build(self) -> "Policy":
            return Policy(**self._attrs)

        def resolution(self, value: Optional[Literal["Required", "Optional"]], /) -> Self:
            """
            Resolution specifies whether resolution of this reference is required.
            The default is 'Required', which means the reconcile will fail if the
            reference cannot be resolved. 'Optional' means this reference will be
            a no-op if it cannot be resolved.
            """
            return self._set("resolution", value)

        def resolve(self, value: Optional[Literal["Always", "IfNotPresent"]], /) -> Self:
            """
            Resolve specifies when this reference should be resolved. The default
            is 'IfNotPresent', which will attempt to resolve the reference only when
            the corresponding field is not present. Use 'Always' to resolve the
            reference on every reconcile.
            """
            return self._set("resolve", value)

    class BuilderContext(BuilderContextBase["Policy.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Policy.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Policy."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Policy", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Policy.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    resolution: Optional[Literal["Required", "Optional"]] = "Required"
    """
    Resolution specifies whether resolution of this reference is required.
    The default is 'Required', which means the reconcile will fail if the
    reference cannot be resolved. 'Optional' means this reference will be
    a no-op if it cannot be resolved.
    """
    resolve: Optional[Literal["Always", "IfNotPresent"]] = None
    """
    Resolve specifies when this reference should be resolved. The default
    is 'IfNotPresent', which will attempt to resolve the reference only when
    the corresponding field is not present. Use 'Always' to resolve the
    reference on every reconcile.
    """


class ProviderConfigRef(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ProviderConfigRef"]:
            return ProviderConfigRef

        def build(self) -> "ProviderConfigRef":
            return ProviderConfigRef(**self._attrs)

        def name(self, value: str, /) -> Self:
            """
            Name of the referenced object.
            """
            return self._set("name", value)

        @overload
        def policy(self, value_or_callback: Optional[Policy], /) -> "ProviderConfigRef.Builder": ...

        @overload
        def policy(
            self,
            value_or_callback: Callable[[Policy.Builder], Policy.Builder | Policy],
            /,
        ) -> "ProviderConfigRef.Builder": ...

        @overload
        def policy(self, value_or_callback: Never = ...) -> "Policy.BuilderContext": ...

        def policy(self, value_or_callback=None, /):
            """
            Policies for referencing.
            """
            if self._in_context and value_or_callback is None:
                context = Policy.BuilderContext()
                context._parent_builder = self
                context._field_name = "policy"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Policy.builder())
                if isinstance(output, Policy.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("policy", value)

    class BuilderContext(BuilderContextBase["ProviderConfigRef.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ProviderConfigRef.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ProviderConfigRef."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ProviderConfigRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ProviderConfigRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: str
    """
    Name of the referenced object.
    """
    policy: Optional[Policy] = None
    """
    Policies for referencing.
    """


class ConfigRef(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ConfigRef"]:
            return ConfigRef

        def build(self) -> "ConfigRef":
            return ConfigRef(**self._attrs)

        def name(self, value: str, /) -> Self:
            """
            Name of the referenced object.
            """
            return self._set("name", value)

        @overload
        def policy(self, value_or_callback: Optional[Policy], /) -> "ConfigRef.Builder": ...

        @overload
        def policy(
            self,
            value_or_callback: Callable[[Policy.Builder], Policy.Builder | Policy],
            /,
        ) -> "ConfigRef.Builder": ...

        @overload
        def policy(self, value_or_callback: Never = ...) -> "Policy.BuilderContext": ...

        def policy(self, value_or_callback=None, /):
            """
            Policies for referencing.
            """
            if self._in_context and value_or_callback is None:
                context = Policy.BuilderContext()
                context._parent_builder = self
                context._field_name = "policy"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Policy.builder())
                if isinstance(output, Policy.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("policy", value)

    class BuilderContext(BuilderContextBase["ConfigRef.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ConfigRef.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ConfigRef."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ConfigRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ConfigRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: str
    """
    Name of the referenced object.
    """
    policy: Optional[Policy] = None
    """
    Policies for referencing.
    """


class Metadata(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Metadata"]:
            return Metadata

        def build(self) -> "Metadata":
            return Metadata(**self._attrs)

        def annotations(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            Annotations are the annotations to be added to connection secret.
            - For Kubernetes secrets, this will be used as "metadata.annotations".
            - It is up to Secret Store implementation for others store types.
            """
            return self._set("annotations", value)

        def labels(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            Labels are the labels/tags to be added to connection secret.
            - For Kubernetes secrets, this will be used as "metadata.labels".
            - It is up to Secret Store implementation for others store types.
            """
            return self._set("labels", value)

        def type(self, value: Optional[str], /) -> Self:
            """
            Type is the SecretType for the connection secret.
            - Only valid for Kubernetes Secret Stores.
            """
            return self._set("type", value)

    class BuilderContext(BuilderContextBase["Metadata.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Metadata.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Metadata."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Metadata", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Metadata.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    annotations: Optional[Dict[str, str]] = None
    """
    Annotations are the annotations to be added to connection secret.
    - For Kubernetes secrets, this will be used as "metadata.annotations".
    - It is up to Secret Store implementation for others store types.
    """
    labels: Optional[Dict[str, str]] = None
    """
    Labels are the labels/tags to be added to connection secret.
    - For Kubernetes secrets, this will be used as "metadata.labels".
    - It is up to Secret Store implementation for others store types.
    """
    type: Optional[str] = None
    """
    Type is the SecretType for the connection secret.
    - Only valid for Kubernetes Secret Stores.
    """


class PublishConnectionDetailsTo(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PublishConnectionDetailsTo"]:
            return PublishConnectionDetailsTo

        def build(self) -> "PublishConnectionDetailsTo":
            return PublishConnectionDetailsTo(**self._attrs)

        @overload
        def config_ref(
            self, value_or_callback: Optional[ConfigRef], /
        ) -> "PublishConnectionDetailsTo.Builder": ...

        @overload
        def config_ref(
            self,
            value_or_callback: Callable[[ConfigRef.Builder], ConfigRef.Builder | ConfigRef],
            /,
        ) -> "PublishConnectionDetailsTo.Builder": ...

        @overload
        def config_ref(self, value_or_callback: Never = ...) -> "ConfigRef.BuilderContext": ...

        def config_ref(self, value_or_callback=None, /):
            """
            SecretStoreConfigRef specifies which secret store config should be used
            for this ConnectionSecret.
            """
            if self._in_context and value_or_callback is None:
                context = ConfigRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "config_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ConfigRef.builder())
                if isinstance(output, ConfigRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("config_ref", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[Metadata], /
        ) -> "PublishConnectionDetailsTo.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[[Metadata.Builder], Metadata.Builder | Metadata],
            /,
        ) -> "PublishConnectionDetailsTo.Builder": ...

        @overload
        def metadata(self, value_or_callback: Never = ...) -> "Metadata.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            """
            Metadata is the metadata for connection secret.
            """
            if self._in_context and value_or_callback is None:
                context = Metadata.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Metadata.builder())
                if isinstance(output, Metadata.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        def name(self, value: str, /) -> Self:
            """
            Name is the name of the connection secret.
            """
            return self._set("name", value)

    class BuilderContext(BuilderContextBase["PublishConnectionDetailsTo.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PublishConnectionDetailsTo.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PublishConnectionDetailsTo."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["PublishConnectionDetailsTo", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PublishConnectionDetailsTo.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    config_ref: Annotated[
        Optional[ConfigRef],
        Field(
            default_factory=lambda: ConfigRef.model_validate({"name": "default"}),
            alias="configRef",
        ),
    ] = {"name": "default"}
    """
    SecretStoreConfigRef specifies which secret store config should be used
    for this ConnectionSecret.
    """
    metadata: Optional[Metadata] = None
    """
    Metadata is the metadata for connection secret.
    """
    name: str
    """
    Name is the name of the connection secret.
    """


class WriteConnectionSecretToRef(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["WriteConnectionSecretToRef"]:
            return WriteConnectionSecretToRef

        def build(self) -> "WriteConnectionSecretToRef":
            return WriteConnectionSecretToRef(**self._attrs)

        def name(self, value: str, /) -> Self:
            """
            Name of the secret.
            """
            return self._set("name", value)

        def namespace(self, value: str, /) -> Self:
            """
            Namespace of the secret.
            """
            return self._set("namespace", value)

    class BuilderContext(BuilderContextBase["WriteConnectionSecretToRef.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = WriteConnectionSecretToRef.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for WriteConnectionSecretToRef."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["WriteConnectionSecretToRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use WriteConnectionSecretToRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: str
    """
    Name of the secret.
    """
    namespace: str
    """
    Namespace of the secret.
    """


class BucketCorsConfigurationSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["BucketCorsConfigurationSpec"]:
            return BucketCorsConfigurationSpec

        def build(self) -> "BucketCorsConfigurationSpec":
            return BucketCorsConfigurationSpec(**self._attrs)

        def deletion_policy(self, value: Optional[Literal["Orphan", "Delete"]], /) -> Self:
            """
            DeletionPolicy specifies what will happen to the underlying external
            when this managed resource is deleted - either "Delete" or "Orphan" the
            external resource.
            This field is planned to be deprecated in favor of the ManagementPolicies
            field in a future release. Currently, both could be set independently and
            non-default values would be honored if the feature flag is enabled.
            See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
            """
            return self._set("deletion_policy", value)

        @overload
        def for_provider(
            self, value_or_callback: ForProvider, /
        ) -> "BucketCorsConfigurationSpec.Builder": ...

        @overload
        def for_provider(
            self,
            value_or_callback: Callable[[ForProvider.Builder], ForProvider.Builder | ForProvider],
            /,
        ) -> "BucketCorsConfigurationSpec.Builder": ...

        @overload
        def for_provider(self, value_or_callback: Never = ...) -> "ForProvider.BuilderContext": ...

        def for_provider(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ForProvider.BuilderContext()
                context._parent_builder = self
                context._field_name = "for_provider"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ForProvider.builder())
                if isinstance(output, ForProvider.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("for_provider", value)

        @overload
        def init_provider(
            self, value_or_callback: Optional[InitProvider], /
        ) -> "BucketCorsConfigurationSpec.Builder": ...

        @overload
        def init_provider(
            self,
            value_or_callback: Callable[
                [InitProvider.Builder], InitProvider.Builder | InitProvider
            ],
            /,
        ) -> "BucketCorsConfigurationSpec.Builder": ...

        @overload
        def init_provider(
            self, value_or_callback: Never = ...
        ) -> "InitProvider.BuilderContext": ...

        def init_provider(self, value_or_callback=None, /):
            """
            THIS IS A BETA FIELD. It will be honored
            unless the Management Policies feature flag is disabled.
            InitProvider holds the same fields as ForProvider, with the exception
            of Identifier and other resource reference fields. The fields that are
            in InitProvider are merged into ForProvider when the resource is created.
            The same fields are also added to the terraform ignore_changes hook, to
            avoid updating them after creation. This is useful for fields that are
            required on creation, but we do not desire to update them after creation,
            for example because of an external controller is managing them, like an
            autoscaler.
            """
            if self._in_context and value_or_callback is None:
                context = InitProvider.BuilderContext()
                context._parent_builder = self
                context._field_name = "init_provider"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(InitProvider.builder())
                if isinstance(output, InitProvider.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("init_provider", value)

        def management_policies(
            self,
            value: Optional[
                List[Literal["Observe", "Create", "Update", "Delete", "LateInitialize", "*"]]
            ],
            /,
        ) -> Self:
            """
            THIS IS A BETA FIELD. It is on by default but can be opted out
            through a Crossplane feature flag.
            ManagementPolicies specify the array of actions Crossplane is allowed to
            take on the managed and external resources.
            This field is planned to replace the DeletionPolicy field in a future
            release. Currently, both could be set independently and non-default
            values would be honored if the feature flag is enabled. If both are
            custom, the DeletionPolicy field will be ignored.
            See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
            and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
            """
            return self._set("management_policies", value)

        @overload
        def provider_config_ref(
            self, value_or_callback: Optional[ProviderConfigRef], /
        ) -> "BucketCorsConfigurationSpec.Builder": ...

        @overload
        def provider_config_ref(
            self,
            value_or_callback: Callable[
                [ProviderConfigRef.Builder],
                ProviderConfigRef.Builder | ProviderConfigRef,
            ],
            /,
        ) -> "BucketCorsConfigurationSpec.Builder": ...

        @overload
        def provider_config_ref(
            self, value_or_callback: Never = ...
        ) -> "ProviderConfigRef.BuilderContext": ...

        def provider_config_ref(self, value_or_callback=None, /):
            """
            ProviderConfigReference specifies how the provider that will be used to
            create, observe, update, and delete this managed resource should be
            configured.
            """
            if self._in_context and value_or_callback is None:
                context = ProviderConfigRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "provider_config_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ProviderConfigRef.builder())
                if isinstance(output, ProviderConfigRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("provider_config_ref", value)

        @overload
        def publish_connection_details_to(
            self, value_or_callback: Optional[PublishConnectionDetailsTo], /
        ) -> "BucketCorsConfigurationSpec.Builder": ...

        @overload
        def publish_connection_details_to(
            self,
            value_or_callback: Callable[
                [PublishConnectionDetailsTo.Builder],
                PublishConnectionDetailsTo.Builder | PublishConnectionDetailsTo,
            ],
            /,
        ) -> "BucketCorsConfigurationSpec.Builder": ...

        @overload
        def publish_connection_details_to(
            self, value_or_callback: Never = ...
        ) -> "PublishConnectionDetailsTo.BuilderContext": ...

        def publish_connection_details_to(self, value_or_callback=None, /):
            """
            PublishConnectionDetailsTo specifies the connection secret config which
            contains a name, metadata and a reference to secret store config to
            which any connection details for this managed resource should be written.
            Connection details frequently include the endpoint, username,
            and password required to connect to the managed resource.
            """
            if self._in_context and value_or_callback is None:
                context = PublishConnectionDetailsTo.BuilderContext()
                context._parent_builder = self
                context._field_name = "publish_connection_details_to"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PublishConnectionDetailsTo.builder())
                if isinstance(output, PublishConnectionDetailsTo.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("publish_connection_details_to", value)

        @overload
        def write_connection_secret_to_ref(
            self, value_or_callback: Optional[WriteConnectionSecretToRef], /
        ) -> "BucketCorsConfigurationSpec.Builder": ...

        @overload
        def write_connection_secret_to_ref(
            self,
            value_or_callback: Callable[
                [WriteConnectionSecretToRef.Builder],
                WriteConnectionSecretToRef.Builder | WriteConnectionSecretToRef,
            ],
            /,
        ) -> "BucketCorsConfigurationSpec.Builder": ...

        @overload
        def write_connection_secret_to_ref(
            self, value_or_callback: Never = ...
        ) -> "WriteConnectionSecretToRef.BuilderContext": ...

        def write_connection_secret_to_ref(self, value_or_callback=None, /):
            """
            WriteConnectionSecretToReference specifies the namespace and name of a
            Secret to which any connection details for this managed resource should
            be written. Connection details frequently include the endpoint, username,
            and password required to connect to the managed resource.
            This field is planned to be replaced in a future release in favor of
            PublishConnectionDetailsTo. Currently, both could be set independently
            and connection details would be published to both without affecting
            each other.
            """
            if self._in_context and value_or_callback is None:
                context = WriteConnectionSecretToRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "write_connection_secret_to_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(WriteConnectionSecretToRef.builder())
                if isinstance(output, WriteConnectionSecretToRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("write_connection_secret_to_ref", value)

    class BuilderContext(BuilderContextBase["BucketCorsConfigurationSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = BucketCorsConfigurationSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for BucketCorsConfigurationSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["BucketCorsConfigurationSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use BucketCorsConfigurationSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    deletion_policy: Annotated[
        Optional[Literal["Orphan", "Delete"]], Field(alias="deletionPolicy")
    ] = "Delete"
    """
    DeletionPolicy specifies what will happen to the underlying external
    when this managed resource is deleted - either "Delete" or "Orphan" the
    external resource.
    This field is planned to be deprecated in favor of the ManagementPolicies
    field in a future release. Currently, both could be set independently and
    non-default values would be honored if the feature flag is enabled.
    See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    """
    for_provider: Annotated[ForProvider, Field(alias="forProvider")]
    init_provider: Annotated[Optional[InitProvider], Field(alias="initProvider")] = None
    """
    THIS IS A BETA FIELD. It will be honored
    unless the Management Policies feature flag is disabled.
    InitProvider holds the same fields as ForProvider, with the exception
    of Identifier and other resource reference fields. The fields that are
    in InitProvider are merged into ForProvider when the resource is created.
    The same fields are also added to the terraform ignore_changes hook, to
    avoid updating them after creation. This is useful for fields that are
    required on creation, but we do not desire to update them after creation,
    for example because of an external controller is managing them, like an
    autoscaler.
    """
    management_policies: Annotated[
        Optional[List[Literal["Observe", "Create", "Update", "Delete", "LateInitialize", "*"]]],
        Field(alias="managementPolicies"),
    ] = ["*"]
    """
    THIS IS A BETA FIELD. It is on by default but can be opted out
    through a Crossplane feature flag.
    ManagementPolicies specify the array of actions Crossplane is allowed to
    take on the managed and external resources.
    This field is planned to replace the DeletionPolicy field in a future
    release. Currently, both could be set independently and non-default
    values would be honored if the feature flag is enabled. If both are
    custom, the DeletionPolicy field will be ignored.
    See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
    """
    provider_config_ref: Annotated[
        Optional[ProviderConfigRef],
        Field(
            default_factory=lambda: ProviderConfigRef.model_validate({"name": "default"}),
            alias="providerConfigRef",
        ),
    ] = {"name": "default"}
    """
    ProviderConfigReference specifies how the provider that will be used to
    create, observe, update, and delete this managed resource should be
    configured.
    """
    publish_connection_details_to: Annotated[
        Optional[PublishConnectionDetailsTo], Field(alias="publishConnectionDetailsTo")
    ] = None
    """
    PublishConnectionDetailsTo specifies the connection secret config which
    contains a name, metadata and a reference to secret store config to
    which any connection details for this managed resource should be written.
    Connection details frequently include the endpoint, username,
    and password required to connect to the managed resource.
    """
    write_connection_secret_to_ref: Annotated[
        Optional[WriteConnectionSecretToRef], Field(alias="writeConnectionSecretToRef")
    ] = None
    """
    WriteConnectionSecretToReference specifies the namespace and name of a
    Secret to which any connection details for this managed resource should
    be written. Connection details frequently include the endpoint, username,
    and password required to connect to the managed resource.
    This field is planned to be replaced in a future release in favor of
    PublishConnectionDetailsTo. Currently, both could be set independently
    and connection details would be published to both without affecting
    each other.
    """


class AtProvider(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AtProvider"]:
            return AtProvider

        def build(self) -> "AtProvider":
            return AtProvider(**self._attrs)

        def bucket(self, value: Optional[str], /) -> Self:
            """
            The name of the bucket to which to apply the CORS configuration.
            Bucket ID
            """
            return self._set("bucket", value)

        @overload
        def cors_rule(self, value_or_callback: List[CorsRule], /) -> "AtProvider.Builder": ...

        @overload
        def cors_rule(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[CorsRule, CorsRule.Builder]],
                GenericListBuilder[CorsRule, CorsRule.Builder] | List[CorsRule],
            ],
            /,
        ) -> "AtProvider.Builder": ...

        @overload
        def cors_rule(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[CorsRule.Builder]: ...

        def cors_rule(self, value_or_callback=None, /):
            """
            Set of origins and methods (cross-origin access that you want to allow). See below. You can configure up to 100 rules.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[CorsRule.Builder]()
                context._parent_builder = self
                context._field_name = "cors_rule"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(CorsRule.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("cors_rule", value)

        def id(self, value: Optional[str], /) -> Self:
            """
            Unique identifier for the rule. The value cannot be longer than 255 characters.
            """
            return self._set("id", value)

        def region(self, value: Optional[str], /) -> Self:
            """
            The region where the bucket resides.
            """
            return self._set("region", value)

    class BuilderContext(BuilderContextBase["AtProvider.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AtProvider.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AtProvider."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AtProvider", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AtProvider.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    bucket: Optional[str] = None
    """
    The name of the bucket to which to apply the CORS configuration.
    Bucket ID
    """
    cors_rule: Annotated[Optional[List[CorsRule]], Field(alias="corsRule")] = None
    """
    Set of origins and methods (cross-origin access that you want to allow). See below. You can configure up to 100 rules.
    """
    id: Optional[str] = None
    """
    Unique identifier for the rule. The value cannot be longer than 255 characters.
    """
    region: Optional[str] = None
    """
    The region where the bucket resides.
    """


class Condition(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Condition"]:
            return Condition

        def build(self) -> "Condition":
            return Condition(**self._attrs)

        def last_transition_time(self, value: AwareDatetime, /) -> Self:
            """
            LastTransitionTime is the last time this condition transitioned from one
            status to another.
            """
            return self._set("last_transition_time", value)

        def message(self, value: Optional[str], /) -> Self:
            """
            A Message containing details about this condition's last transition from
            one status to another, if any.
            """
            return self._set("message", value)

        def observed_generation(self, value: Optional[int], /) -> Self:
            """
            ObservedGeneration represents the .metadata.generation that the condition was set based upon.
            For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
            with respect to the current state of the instance.
            """
            return self._set("observed_generation", value)

        def reason(self, value: str, /) -> Self:
            """
            A Reason for this condition's last transition from one status to another.
            """
            return self._set("reason", value)

        def status(self, value: str, /) -> Self:
            """
            Status of this condition; is it currently True, False, or Unknown?
            """
            return self._set("status", value)

        def type(self, value: str, /) -> Self:
            """
            Type of this condition. At most one of each condition type may apply to
            a resource at any point in time.
            """
            return self._set("type", value)

    class BuilderContext(BuilderContextBase["Condition.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Condition.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Condition."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Condition", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Condition.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    last_transition_time: Annotated[AwareDatetime, Field(alias="lastTransitionTime")]
    """
    LastTransitionTime is the last time this condition transitioned from one
    status to another.
    """
    message: Optional[str] = None
    """
    A Message containing details about this condition's last transition from
    one status to another, if any.
    """
    observed_generation: Annotated[Optional[int], Field(alias="observedGeneration")] = None
    """
    ObservedGeneration represents the .metadata.generation that the condition was set based upon.
    For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
    with respect to the current state of the instance.
    """
    reason: str
    """
    A Reason for this condition's last transition from one status to another.
    """
    status: str
    """
    Status of this condition; is it currently True, False, or Unknown?
    """
    type: str
    """
    Type of this condition. At most one of each condition type may apply to
    a resource at any point in time.
    """


class BucketCorsConfigurationStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["BucketCorsConfigurationStatus"]:
            return BucketCorsConfigurationStatus

        def build(self) -> "BucketCorsConfigurationStatus":
            return BucketCorsConfigurationStatus(**self._attrs)

        @overload
        def at_provider(
            self, value_or_callback: Optional[AtProvider], /
        ) -> "BucketCorsConfigurationStatus.Builder": ...

        @overload
        def at_provider(
            self,
            value_or_callback: Callable[[AtProvider.Builder], AtProvider.Builder | AtProvider],
            /,
        ) -> "BucketCorsConfigurationStatus.Builder": ...

        @overload
        def at_provider(self, value_or_callback: Never = ...) -> "AtProvider.BuilderContext": ...

        def at_provider(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = AtProvider.BuilderContext()
                context._parent_builder = self
                context._field_name = "at_provider"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AtProvider.builder())
                if isinstance(output, AtProvider.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("at_provider", value)

        @overload
        def conditions(
            self, value_or_callback: List[Condition], /
        ) -> "BucketCorsConfigurationStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Condition, Condition.Builder]],
                GenericListBuilder[Condition, Condition.Builder] | List[Condition],
            ],
            /,
        ) -> "BucketCorsConfigurationStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            """
            Conditions of the resource.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        def observed_generation(self, value: Optional[int], /) -> Self:
            """
            ObservedGeneration is the latest metadata.generation
            which resulted in either a ready state, or stalled due to error
            it can not recover from without human intervention.
            """
            return self._set("observed_generation", value)

    class BuilderContext(BuilderContextBase["BucketCorsConfigurationStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = BucketCorsConfigurationStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for BucketCorsConfigurationStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["BucketCorsConfigurationStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use BucketCorsConfigurationStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    at_provider: Annotated[Optional[AtProvider], Field(alias="atProvider")] = None
    conditions: Optional[List[Condition]] = None
    """
    Conditions of the resource.
    """
    observed_generation: Annotated[Optional[int], Field(alias="observedGeneration")] = None
    """
    ObservedGeneration is the latest metadata.generation
    which resulted in either a ready state, or stalled due to error
    it can not recover from without human intervention.
    """


class ForProviderModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ForProviderModel"]:
            return ForProviderModel

        def build(self) -> "ForProviderModel":
            return ForProviderModel(**self._attrs)

        def acl(self, value: Optional[str], /) -> Self:
            """
            The canned ACL to apply. DigitalOcean supports "private" and "public-read". (Defaults to "private".)
            """
            return self._set("acl", value)

        def bucket(self, value: Optional[str], /) -> Self:
            """
            The name of the bucket to put the file in.
            """
            return self._set("bucket", value)

        def cache_control(self, value: Optional[str], /) -> Self:
            """
            Specifies caching behavior along the request/reply chain Read w3c cache_control for further details.
            """
            return self._set("cache_control", value)

        def content(self, value: Optional[str], /) -> Self:
            """
            Literal string value to use as the object content, which will be uploaded as UTF-8-encoded text.
            """
            return self._set("content", value)

        def content_base64(self, value: Optional[str], /) -> Self:
            """
            Base64-encoded data that will be decoded and uploaded as raw bytes for the object content. This allows safely uploading non-UTF8 binary data, but is recommended only for small content such as the result of the gzipbase64 function with small text strings. For larger objects, use source to stream the content from a disk file.
            """
            return self._set("content_base64", value)

        def content_disposition(self, value: Optional[str], /) -> Self:
            """
            Specifies presentational information for the object. Read w3c content_disposition for further information.
            """
            return self._set("content_disposition", value)

        def content_encoding(self, value: Optional[str], /) -> Self:
            """
            Specifies what content encodings have been applied to the object and thus what decoding mechanisms must be applied to obtain the media-type referenced by the Content-Type header field. Read w3c content encoding for further information.
            """
            return self._set("content_encoding", value)

        def content_language(self, value: Optional[str], /) -> Self:
            """
            The language the content is in e.g. en-US or en-GB.
            """
            return self._set("content_language", value)

        def content_type(self, value: Optional[str], /) -> Self:
            """
            A standard MIME type describing the format of the object data, e.g. application/octet-stream. All Valid MIME Types are valid for this input.
            """
            return self._set("content_type", value)

        def etag(self, value: Optional[str], /) -> Self:
            """
            Used to trigger updates.11.11.11 or earlier).
            """
            return self._set("etag", value)

        def force_destroy(self, value: Optional[bool], /) -> Self:
            """
            Allow the object to be deleted by removing any legal hold on any object version.
            Default is false. This value should be set to true only if the bucket has S3 object lock enabled.
            """
            return self._set("force_destroy", value)

        def key(self, value: Optional[str], /) -> Self:
            """
            The name of the object once it is in the bucket.
            """
            return self._set("key", value)

        def metadata(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            A mapping of keys/values to provision metadata (will be automatically prefixed by x-amz-meta-, note that only lowercase label are currently supported by the AWS Go API).
            """
            return self._set("metadata", value)

        def region(self, value: Optional[str], /) -> Self:
            """
            The region where the bucket resides (Defaults to nyc3)
            """
            return self._set("region", value)

        def source(self, value: Optional[str], /) -> Self:
            """
            The path to a file that will be read and uploaded as raw bytes for the object content.
            """
            return self._set("source", value)

        def website_redirect(self, value: Optional[str], /) -> Self:
            """
            Specifies a target URL for website redirect.
            """
            return self._set("website_redirect", value)

    class BuilderContext(BuilderContextBase["ForProviderModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ForProviderModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ForProviderModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ForProviderModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ForProviderModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    acl: Optional[str] = None
    """
    The canned ACL to apply. DigitalOcean supports "private" and "public-read". (Defaults to "private".)
    """
    bucket: Optional[str] = None
    """
    The name of the bucket to put the file in.
    """
    cache_control: Annotated[Optional[str], Field(alias="cacheControl")] = None
    """
    Specifies caching behavior along the request/reply chain Read w3c cache_control for further details.
    """
    content: Optional[str] = None
    """
    Literal string value to use as the object content, which will be uploaded as UTF-8-encoded text.
    """
    content_base64: Annotated[Optional[str], Field(alias="contentBase64")] = None
    """
    Base64-encoded data that will be decoded and uploaded as raw bytes for the object content. This allows safely uploading non-UTF8 binary data, but is recommended only for small content such as the result of the gzipbase64 function with small text strings. For larger objects, use source to stream the content from a disk file.
    """
    content_disposition: Annotated[Optional[str], Field(alias="contentDisposition")] = None
    """
    Specifies presentational information for the object. Read w3c content_disposition for further information.
    """
    content_encoding: Annotated[Optional[str], Field(alias="contentEncoding")] = None
    """
    Specifies what content encodings have been applied to the object and thus what decoding mechanisms must be applied to obtain the media-type referenced by the Content-Type header field. Read w3c content encoding for further information.
    """
    content_language: Annotated[Optional[str], Field(alias="contentLanguage")] = None
    """
    The language the content is in e.g. en-US or en-GB.
    """
    content_type: Annotated[Optional[str], Field(alias="contentType")] = None
    """
    A standard MIME type describing the format of the object data, e.g. application/octet-stream. All Valid MIME Types are valid for this input.
    """
    etag: Optional[str] = None
    """
    Used to trigger updates.11.11.11 or earlier).
    """
    force_destroy: Annotated[Optional[bool], Field(alias="forceDestroy")] = None
    """
    Allow the object to be deleted by removing any legal hold on any object version.
    Default is false. This value should be set to true only if the bucket has S3 object lock enabled.
    """
    key: Optional[str] = None
    """
    The name of the object once it is in the bucket.
    """
    metadata: Optional[Dict[str, str]] = None
    """
    A mapping of keys/values to provision metadata (will be automatically prefixed by x-amz-meta-, note that only lowercase label are currently supported by the AWS Go API).
    """
    region: Optional[str] = None
    """
    The region where the bucket resides (Defaults to nyc3)
    """
    source: Optional[str] = None
    """
    The path to a file that will be read and uploaded as raw bytes for the object content.
    """
    website_redirect: Annotated[Optional[str], Field(alias="websiteRedirect")] = None
    """
    Specifies a target URL for website redirect.
    """


class InitProviderModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["InitProviderModel"]:
            return InitProviderModel

        def build(self) -> "InitProviderModel":
            return InitProviderModel(**self._attrs)

        def acl(self, value: Optional[str], /) -> Self:
            """
            The canned ACL to apply. DigitalOcean supports "private" and "public-read". (Defaults to "private".)
            """
            return self._set("acl", value)

        def bucket(self, value: Optional[str], /) -> Self:
            """
            The name of the bucket to put the file in.
            """
            return self._set("bucket", value)

        def cache_control(self, value: Optional[str], /) -> Self:
            """
            Specifies caching behavior along the request/reply chain Read w3c cache_control for further details.
            """
            return self._set("cache_control", value)

        def content(self, value: Optional[str], /) -> Self:
            """
            Literal string value to use as the object content, which will be uploaded as UTF-8-encoded text.
            """
            return self._set("content", value)

        def content_base64(self, value: Optional[str], /) -> Self:
            """
            Base64-encoded data that will be decoded and uploaded as raw bytes for the object content. This allows safely uploading non-UTF8 binary data, but is recommended only for small content such as the result of the gzipbase64 function with small text strings. For larger objects, use source to stream the content from a disk file.
            """
            return self._set("content_base64", value)

        def content_disposition(self, value: Optional[str], /) -> Self:
            """
            Specifies presentational information for the object. Read w3c content_disposition for further information.
            """
            return self._set("content_disposition", value)

        def content_encoding(self, value: Optional[str], /) -> Self:
            """
            Specifies what content encodings have been applied to the object and thus what decoding mechanisms must be applied to obtain the media-type referenced by the Content-Type header field. Read w3c content encoding for further information.
            """
            return self._set("content_encoding", value)

        def content_language(self, value: Optional[str], /) -> Self:
            """
            The language the content is in e.g. en-US or en-GB.
            """
            return self._set("content_language", value)

        def content_type(self, value: Optional[str], /) -> Self:
            """
            A standard MIME type describing the format of the object data, e.g. application/octet-stream. All Valid MIME Types are valid for this input.
            """
            return self._set("content_type", value)

        def etag(self, value: Optional[str], /) -> Self:
            """
            Used to trigger updates.11.11.11 or earlier).
            """
            return self._set("etag", value)

        def force_destroy(self, value: Optional[bool], /) -> Self:
            """
            Allow the object to be deleted by removing any legal hold on any object version.
            Default is false. This value should be set to true only if the bucket has S3 object lock enabled.
            """
            return self._set("force_destroy", value)

        def key(self, value: Optional[str], /) -> Self:
            """
            The name of the object once it is in the bucket.
            """
            return self._set("key", value)

        def metadata(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            A mapping of keys/values to provision metadata (will be automatically prefixed by x-amz-meta-, note that only lowercase label are currently supported by the AWS Go API).
            """
            return self._set("metadata", value)

        def region(self, value: Optional[str], /) -> Self:
            """
            The region where the bucket resides (Defaults to nyc3)
            """
            return self._set("region", value)

        def source(self, value: Optional[str], /) -> Self:
            """
            The path to a file that will be read and uploaded as raw bytes for the object content.
            """
            return self._set("source", value)

        def website_redirect(self, value: Optional[str], /) -> Self:
            """
            Specifies a target URL for website redirect.
            """
            return self._set("website_redirect", value)

    class BuilderContext(BuilderContextBase["InitProviderModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = InitProviderModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for InitProviderModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["InitProviderModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use InitProviderModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    acl: Optional[str] = None
    """
    The canned ACL to apply. DigitalOcean supports "private" and "public-read". (Defaults to "private".)
    """
    bucket: Optional[str] = None
    """
    The name of the bucket to put the file in.
    """
    cache_control: Annotated[Optional[str], Field(alias="cacheControl")] = None
    """
    Specifies caching behavior along the request/reply chain Read w3c cache_control for further details.
    """
    content: Optional[str] = None
    """
    Literal string value to use as the object content, which will be uploaded as UTF-8-encoded text.
    """
    content_base64: Annotated[Optional[str], Field(alias="contentBase64")] = None
    """
    Base64-encoded data that will be decoded and uploaded as raw bytes for the object content. This allows safely uploading non-UTF8 binary data, but is recommended only for small content such as the result of the gzipbase64 function with small text strings. For larger objects, use source to stream the content from a disk file.
    """
    content_disposition: Annotated[Optional[str], Field(alias="contentDisposition")] = None
    """
    Specifies presentational information for the object. Read w3c content_disposition for further information.
    """
    content_encoding: Annotated[Optional[str], Field(alias="contentEncoding")] = None
    """
    Specifies what content encodings have been applied to the object and thus what decoding mechanisms must be applied to obtain the media-type referenced by the Content-Type header field. Read w3c content encoding for further information.
    """
    content_language: Annotated[Optional[str], Field(alias="contentLanguage")] = None
    """
    The language the content is in e.g. en-US or en-GB.
    """
    content_type: Annotated[Optional[str], Field(alias="contentType")] = None
    """
    A standard MIME type describing the format of the object data, e.g. application/octet-stream. All Valid MIME Types are valid for this input.
    """
    etag: Optional[str] = None
    """
    Used to trigger updates.11.11.11 or earlier).
    """
    force_destroy: Annotated[Optional[bool], Field(alias="forceDestroy")] = None
    """
    Allow the object to be deleted by removing any legal hold on any object version.
    Default is false. This value should be set to true only if the bucket has S3 object lock enabled.
    """
    key: Optional[str] = None
    """
    The name of the object once it is in the bucket.
    """
    metadata: Optional[Dict[str, str]] = None
    """
    A mapping of keys/values to provision metadata (will be automatically prefixed by x-amz-meta-, note that only lowercase label are currently supported by the AWS Go API).
    """
    region: Optional[str] = None
    """
    The region where the bucket resides (Defaults to nyc3)
    """
    source: Optional[str] = None
    """
    The path to a file that will be read and uploaded as raw bytes for the object content.
    """
    website_redirect: Annotated[Optional[str], Field(alias="websiteRedirect")] = None
    """
    Specifies a target URL for website redirect.
    """


class BucketObjectSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["BucketObjectSpec"]:
            return BucketObjectSpec

        def build(self) -> "BucketObjectSpec":
            return BucketObjectSpec(**self._attrs)

        def deletion_policy(self, value: Optional[Literal["Orphan", "Delete"]], /) -> Self:
            """
            DeletionPolicy specifies what will happen to the underlying external
            when this managed resource is deleted - either "Delete" or "Orphan" the
            external resource.
            This field is planned to be deprecated in favor of the ManagementPolicies
            field in a future release. Currently, both could be set independently and
            non-default values would be honored if the feature flag is enabled.
            See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
            """
            return self._set("deletion_policy", value)

        @overload
        def for_provider(
            self, value_or_callback: ForProviderModel, /
        ) -> "BucketObjectSpec.Builder": ...

        @overload
        def for_provider(
            self,
            value_or_callback: Callable[
                [ForProviderModel.Builder], ForProviderModel.Builder | ForProviderModel
            ],
            /,
        ) -> "BucketObjectSpec.Builder": ...

        @overload
        def for_provider(
            self, value_or_callback: Never = ...
        ) -> "ForProviderModel.BuilderContext": ...

        def for_provider(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ForProviderModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "for_provider"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ForProviderModel.builder())
                if isinstance(output, ForProviderModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("for_provider", value)

        @overload
        def init_provider(
            self, value_or_callback: Optional[InitProviderModel], /
        ) -> "BucketObjectSpec.Builder": ...

        @overload
        def init_provider(
            self,
            value_or_callback: Callable[
                [InitProviderModel.Builder],
                InitProviderModel.Builder | InitProviderModel,
            ],
            /,
        ) -> "BucketObjectSpec.Builder": ...

        @overload
        def init_provider(
            self, value_or_callback: Never = ...
        ) -> "InitProviderModel.BuilderContext": ...

        def init_provider(self, value_or_callback=None, /):
            """
            THIS IS A BETA FIELD. It will be honored
            unless the Management Policies feature flag is disabled.
            InitProvider holds the same fields as ForProvider, with the exception
            of Identifier and other resource reference fields. The fields that are
            in InitProvider are merged into ForProvider when the resource is created.
            The same fields are also added to the terraform ignore_changes hook, to
            avoid updating them after creation. This is useful for fields that are
            required on creation, but we do not desire to update them after creation,
            for example because of an external controller is managing them, like an
            autoscaler.
            """
            if self._in_context and value_or_callback is None:
                context = InitProviderModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "init_provider"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(InitProviderModel.builder())
                if isinstance(output, InitProviderModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("init_provider", value)

        def management_policies(
            self,
            value: Optional[
                List[Literal["Observe", "Create", "Update", "Delete", "LateInitialize", "*"]]
            ],
            /,
        ) -> Self:
            """
            THIS IS A BETA FIELD. It is on by default but can be opted out
            through a Crossplane feature flag.
            ManagementPolicies specify the array of actions Crossplane is allowed to
            take on the managed and external resources.
            This field is planned to replace the DeletionPolicy field in a future
            release. Currently, both could be set independently and non-default
            values would be honored if the feature flag is enabled. If both are
            custom, the DeletionPolicy field will be ignored.
            See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
            and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
            """
            return self._set("management_policies", value)

        @overload
        def provider_config_ref(
            self, value_or_callback: Optional[ProviderConfigRef], /
        ) -> "BucketObjectSpec.Builder": ...

        @overload
        def provider_config_ref(
            self,
            value_or_callback: Callable[
                [ProviderConfigRef.Builder],
                ProviderConfigRef.Builder | ProviderConfigRef,
            ],
            /,
        ) -> "BucketObjectSpec.Builder": ...

        @overload
        def provider_config_ref(
            self, value_or_callback: Never = ...
        ) -> "ProviderConfigRef.BuilderContext": ...

        def provider_config_ref(self, value_or_callback=None, /):
            """
            ProviderConfigReference specifies how the provider that will be used to
            create, observe, update, and delete this managed resource should be
            configured.
            """
            if self._in_context and value_or_callback is None:
                context = ProviderConfigRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "provider_config_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ProviderConfigRef.builder())
                if isinstance(output, ProviderConfigRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("provider_config_ref", value)

        @overload
        def publish_connection_details_to(
            self, value_or_callback: Optional[PublishConnectionDetailsTo], /
        ) -> "BucketObjectSpec.Builder": ...

        @overload
        def publish_connection_details_to(
            self,
            value_or_callback: Callable[
                [PublishConnectionDetailsTo.Builder],
                PublishConnectionDetailsTo.Builder | PublishConnectionDetailsTo,
            ],
            /,
        ) -> "BucketObjectSpec.Builder": ...

        @overload
        def publish_connection_details_to(
            self, value_or_callback: Never = ...
        ) -> "PublishConnectionDetailsTo.BuilderContext": ...

        def publish_connection_details_to(self, value_or_callback=None, /):
            """
            PublishConnectionDetailsTo specifies the connection secret config which
            contains a name, metadata and a reference to secret store config to
            which any connection details for this managed resource should be written.
            Connection details frequently include the endpoint, username,
            and password required to connect to the managed resource.
            """
            if self._in_context and value_or_callback is None:
                context = PublishConnectionDetailsTo.BuilderContext()
                context._parent_builder = self
                context._field_name = "publish_connection_details_to"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PublishConnectionDetailsTo.builder())
                if isinstance(output, PublishConnectionDetailsTo.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("publish_connection_details_to", value)

        @overload
        def write_connection_secret_to_ref(
            self, value_or_callback: Optional[WriteConnectionSecretToRef], /
        ) -> "BucketObjectSpec.Builder": ...

        @overload
        def write_connection_secret_to_ref(
            self,
            value_or_callback: Callable[
                [WriteConnectionSecretToRef.Builder],
                WriteConnectionSecretToRef.Builder | WriteConnectionSecretToRef,
            ],
            /,
        ) -> "BucketObjectSpec.Builder": ...

        @overload
        def write_connection_secret_to_ref(
            self, value_or_callback: Never = ...
        ) -> "WriteConnectionSecretToRef.BuilderContext": ...

        def write_connection_secret_to_ref(self, value_or_callback=None, /):
            """
            WriteConnectionSecretToReference specifies the namespace and name of a
            Secret to which any connection details for this managed resource should
            be written. Connection details frequently include the endpoint, username,
            and password required to connect to the managed resource.
            This field is planned to be replaced in a future release in favor of
            PublishConnectionDetailsTo. Currently, both could be set independently
            and connection details would be published to both without affecting
            each other.
            """
            if self._in_context and value_or_callback is None:
                context = WriteConnectionSecretToRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "write_connection_secret_to_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(WriteConnectionSecretToRef.builder())
                if isinstance(output, WriteConnectionSecretToRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("write_connection_secret_to_ref", value)

    class BuilderContext(BuilderContextBase["BucketObjectSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = BucketObjectSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for BucketObjectSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["BucketObjectSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use BucketObjectSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    deletion_policy: Annotated[
        Optional[Literal["Orphan", "Delete"]], Field(alias="deletionPolicy")
    ] = "Delete"
    """
    DeletionPolicy specifies what will happen to the underlying external
    when this managed resource is deleted - either "Delete" or "Orphan" the
    external resource.
    This field is planned to be deprecated in favor of the ManagementPolicies
    field in a future release. Currently, both could be set independently and
    non-default values would be honored if the feature flag is enabled.
    See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    """
    for_provider: Annotated[ForProviderModel, Field(alias="forProvider")]
    init_provider: Annotated[Optional[InitProviderModel], Field(alias="initProvider")] = None
    """
    THIS IS A BETA FIELD. It will be honored
    unless the Management Policies feature flag is disabled.
    InitProvider holds the same fields as ForProvider, with the exception
    of Identifier and other resource reference fields. The fields that are
    in InitProvider are merged into ForProvider when the resource is created.
    The same fields are also added to the terraform ignore_changes hook, to
    avoid updating them after creation. This is useful for fields that are
    required on creation, but we do not desire to update them after creation,
    for example because of an external controller is managing them, like an
    autoscaler.
    """
    management_policies: Annotated[
        Optional[List[Literal["Observe", "Create", "Update", "Delete", "LateInitialize", "*"]]],
        Field(alias="managementPolicies"),
    ] = ["*"]
    """
    THIS IS A BETA FIELD. It is on by default but can be opted out
    through a Crossplane feature flag.
    ManagementPolicies specify the array of actions Crossplane is allowed to
    take on the managed and external resources.
    This field is planned to replace the DeletionPolicy field in a future
    release. Currently, both could be set independently and non-default
    values would be honored if the feature flag is enabled. If both are
    custom, the DeletionPolicy field will be ignored.
    See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
    """
    provider_config_ref: Annotated[
        Optional[ProviderConfigRef],
        Field(
            default_factory=lambda: ProviderConfigRef.model_validate({"name": "default"}),
            alias="providerConfigRef",
        ),
    ] = {"name": "default"}
    """
    ProviderConfigReference specifies how the provider that will be used to
    create, observe, update, and delete this managed resource should be
    configured.
    """
    publish_connection_details_to: Annotated[
        Optional[PublishConnectionDetailsTo], Field(alias="publishConnectionDetailsTo")
    ] = None
    """
    PublishConnectionDetailsTo specifies the connection secret config which
    contains a name, metadata and a reference to secret store config to
    which any connection details for this managed resource should be written.
    Connection details frequently include the endpoint, username,
    and password required to connect to the managed resource.
    """
    write_connection_secret_to_ref: Annotated[
        Optional[WriteConnectionSecretToRef], Field(alias="writeConnectionSecretToRef")
    ] = None
    """
    WriteConnectionSecretToReference specifies the namespace and name of a
    Secret to which any connection details for this managed resource should
    be written. Connection details frequently include the endpoint, username,
    and password required to connect to the managed resource.
    This field is planned to be replaced in a future release in favor of
    PublishConnectionDetailsTo. Currently, both could be set independently
    and connection details would be published to both without affecting
    each other.
    """


class AtProviderModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AtProviderModel"]:
            return AtProviderModel

        def build(self) -> "AtProviderModel":
            return AtProviderModel(**self._attrs)

        def acl(self, value: Optional[str], /) -> Self:
            """
            The canned ACL to apply. DigitalOcean supports "private" and "public-read". (Defaults to "private".)
            """
            return self._set("acl", value)

        def bucket(self, value: Optional[str], /) -> Self:
            """
            The name of the bucket to put the file in.
            """
            return self._set("bucket", value)

        def cache_control(self, value: Optional[str], /) -> Self:
            """
            Specifies caching behavior along the request/reply chain Read w3c cache_control for further details.
            """
            return self._set("cache_control", value)

        def content(self, value: Optional[str], /) -> Self:
            """
            Literal string value to use as the object content, which will be uploaded as UTF-8-encoded text.
            """
            return self._set("content", value)

        def content_base64(self, value: Optional[str], /) -> Self:
            """
            Base64-encoded data that will be decoded and uploaded as raw bytes for the object content. This allows safely uploading non-UTF8 binary data, but is recommended only for small content such as the result of the gzipbase64 function with small text strings. For larger objects, use source to stream the content from a disk file.
            """
            return self._set("content_base64", value)

        def content_disposition(self, value: Optional[str], /) -> Self:
            """
            Specifies presentational information for the object. Read w3c content_disposition for further information.
            """
            return self._set("content_disposition", value)

        def content_encoding(self, value: Optional[str], /) -> Self:
            """
            Specifies what content encodings have been applied to the object and thus what decoding mechanisms must be applied to obtain the media-type referenced by the Content-Type header field. Read w3c content encoding for further information.
            """
            return self._set("content_encoding", value)

        def content_language(self, value: Optional[str], /) -> Self:
            """
            The language the content is in e.g. en-US or en-GB.
            """
            return self._set("content_language", value)

        def content_type(self, value: Optional[str], /) -> Self:
            """
            A standard MIME type describing the format of the object data, e.g. application/octet-stream. All Valid MIME Types are valid for this input.
            """
            return self._set("content_type", value)

        def etag(self, value: Optional[str], /) -> Self:
            """
            Used to trigger updates.11.11.11 or earlier).
            """
            return self._set("etag", value)

        def force_destroy(self, value: Optional[bool], /) -> Self:
            """
            Allow the object to be deleted by removing any legal hold on any object version.
            Default is false. This value should be set to true only if the bucket has S3 object lock enabled.
            """
            return self._set("force_destroy", value)

        def id(self, value: Optional[str], /) -> Self:
            return self._set("id", value)

        def key(self, value: Optional[str], /) -> Self:
            """
            The name of the object once it is in the bucket.
            """
            return self._set("key", value)

        def metadata(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            A mapping of keys/values to provision metadata (will be automatically prefixed by x-amz-meta-, note that only lowercase label are currently supported by the AWS Go API).
            """
            return self._set("metadata", value)

        def region(self, value: Optional[str], /) -> Self:
            """
            The region where the bucket resides (Defaults to nyc3)
            """
            return self._set("region", value)

        def source(self, value: Optional[str], /) -> Self:
            """
            The path to a file that will be read and uploaded as raw bytes for the object content.
            """
            return self._set("source", value)

        def version_id(self, value: Optional[str], /) -> Self:
            """
            A unique version ID value for the object, if bucket versioning is enabled.
            """
            return self._set("version_id", value)

        def website_redirect(self, value: Optional[str], /) -> Self:
            """
            Specifies a target URL for website redirect.
            """
            return self._set("website_redirect", value)

    class BuilderContext(BuilderContextBase["AtProviderModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AtProviderModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AtProviderModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AtProviderModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AtProviderModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    acl: Optional[str] = None
    """
    The canned ACL to apply. DigitalOcean supports "private" and "public-read". (Defaults to "private".)
    """
    bucket: Optional[str] = None
    """
    The name of the bucket to put the file in.
    """
    cache_control: Annotated[Optional[str], Field(alias="cacheControl")] = None
    """
    Specifies caching behavior along the request/reply chain Read w3c cache_control for further details.
    """
    content: Optional[str] = None
    """
    Literal string value to use as the object content, which will be uploaded as UTF-8-encoded text.
    """
    content_base64: Annotated[Optional[str], Field(alias="contentBase64")] = None
    """
    Base64-encoded data that will be decoded and uploaded as raw bytes for the object content. This allows safely uploading non-UTF8 binary data, but is recommended only for small content such as the result of the gzipbase64 function with small text strings. For larger objects, use source to stream the content from a disk file.
    """
    content_disposition: Annotated[Optional[str], Field(alias="contentDisposition")] = None
    """
    Specifies presentational information for the object. Read w3c content_disposition for further information.
    """
    content_encoding: Annotated[Optional[str], Field(alias="contentEncoding")] = None
    """
    Specifies what content encodings have been applied to the object and thus what decoding mechanisms must be applied to obtain the media-type referenced by the Content-Type header field. Read w3c content encoding for further information.
    """
    content_language: Annotated[Optional[str], Field(alias="contentLanguage")] = None
    """
    The language the content is in e.g. en-US or en-GB.
    """
    content_type: Annotated[Optional[str], Field(alias="contentType")] = None
    """
    A standard MIME type describing the format of the object data, e.g. application/octet-stream. All Valid MIME Types are valid for this input.
    """
    etag: Optional[str] = None
    """
    Used to trigger updates.11.11.11 or earlier).
    """
    force_destroy: Annotated[Optional[bool], Field(alias="forceDestroy")] = None
    """
    Allow the object to be deleted by removing any legal hold on any object version.
    Default is false. This value should be set to true only if the bucket has S3 object lock enabled.
    """
    id: Optional[str] = None
    key: Optional[str] = None
    """
    The name of the object once it is in the bucket.
    """
    metadata: Optional[Dict[str, str]] = None
    """
    A mapping of keys/values to provision metadata (will be automatically prefixed by x-amz-meta-, note that only lowercase label are currently supported by the AWS Go API).
    """
    region: Optional[str] = None
    """
    The region where the bucket resides (Defaults to nyc3)
    """
    source: Optional[str] = None
    """
    The path to a file that will be read and uploaded as raw bytes for the object content.
    """
    version_id: Annotated[Optional[str], Field(alias="versionId")] = None
    """
    A unique version ID value for the object, if bucket versioning is enabled.
    """
    website_redirect: Annotated[Optional[str], Field(alias="websiteRedirect")] = None
    """
    Specifies a target URL for website redirect.
    """


class BucketObjectStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["BucketObjectStatus"]:
            return BucketObjectStatus

        def build(self) -> "BucketObjectStatus":
            return BucketObjectStatus(**self._attrs)

        @overload
        def at_provider(
            self, value_or_callback: Optional[AtProviderModel], /
        ) -> "BucketObjectStatus.Builder": ...

        @overload
        def at_provider(
            self,
            value_or_callback: Callable[
                [AtProviderModel.Builder], AtProviderModel.Builder | AtProviderModel
            ],
            /,
        ) -> "BucketObjectStatus.Builder": ...

        @overload
        def at_provider(
            self, value_or_callback: Never = ...
        ) -> "AtProviderModel.BuilderContext": ...

        def at_provider(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = AtProviderModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "at_provider"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AtProviderModel.builder())
                if isinstance(output, AtProviderModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("at_provider", value)

        @overload
        def conditions(
            self, value_or_callback: List[Condition], /
        ) -> "BucketObjectStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Condition, Condition.Builder]],
                GenericListBuilder[Condition, Condition.Builder] | List[Condition],
            ],
            /,
        ) -> "BucketObjectStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            """
            Conditions of the resource.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        def observed_generation(self, value: Optional[int], /) -> Self:
            """
            ObservedGeneration is the latest metadata.generation
            which resulted in either a ready state, or stalled due to error
            it can not recover from without human intervention.
            """
            return self._set("observed_generation", value)

    class BuilderContext(BuilderContextBase["BucketObjectStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = BucketObjectStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for BucketObjectStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["BucketObjectStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use BucketObjectStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    at_provider: Annotated[Optional[AtProviderModel], Field(alias="atProvider")] = None
    conditions: Optional[List[Condition]] = None
    """
    Conditions of the resource.
    """
    observed_generation: Annotated[Optional[int], Field(alias="observedGeneration")] = None
    """
    ObservedGeneration is the latest metadata.generation
    which resulted in either a ready state, or stalled due to error
    it can not recover from without human intervention.
    """


class ForProviderModel1(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ForProviderModel1"]:
            return ForProviderModel1

        def build(self) -> "ForProviderModel1":
            return ForProviderModel1(**self._attrs)

        def bucket(self, value: Optional[str], /) -> Self:
            """
            The name of the bucket to which to apply the policy.
            """
            return self._set("bucket", value)

        def policy(self, value: Optional[str], /) -> Self:
            """
            The text of the policy.
            """
            return self._set("policy", value)

        def region(self, value: Optional[str], /) -> Self:
            """
            The region where the bucket resides.
            """
            return self._set("region", value)

    class BuilderContext(BuilderContextBase["ForProviderModel1.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ForProviderModel1.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ForProviderModel1."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ForProviderModel1", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ForProviderModel1.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    bucket: Optional[str] = None
    """
    The name of the bucket to which to apply the policy.
    """
    policy: Optional[str] = None
    """
    The text of the policy.
    """
    region: Optional[str] = None
    """
    The region where the bucket resides.
    """


class InitProviderModel1(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["InitProviderModel1"]:
            return InitProviderModel1

        def build(self) -> "InitProviderModel1":
            return InitProviderModel1(**self._attrs)

        def bucket(self, value: Optional[str], /) -> Self:
            """
            The name of the bucket to which to apply the policy.
            """
            return self._set("bucket", value)

        def policy(self, value: Optional[str], /) -> Self:
            """
            The text of the policy.
            """
            return self._set("policy", value)

        def region(self, value: Optional[str], /) -> Self:
            """
            The region where the bucket resides.
            """
            return self._set("region", value)

    class BuilderContext(BuilderContextBase["InitProviderModel1.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = InitProviderModel1.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for InitProviderModel1."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["InitProviderModel1", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use InitProviderModel1.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    bucket: Optional[str] = None
    """
    The name of the bucket to which to apply the policy.
    """
    policy: Optional[str] = None
    """
    The text of the policy.
    """
    region: Optional[str] = None
    """
    The region where the bucket resides.
    """


class BucketPolicySpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["BucketPolicySpec"]:
            return BucketPolicySpec

        def build(self) -> "BucketPolicySpec":
            return BucketPolicySpec(**self._attrs)

        def deletion_policy(self, value: Optional[Literal["Orphan", "Delete"]], /) -> Self:
            """
            DeletionPolicy specifies what will happen to the underlying external
            when this managed resource is deleted - either "Delete" or "Orphan" the
            external resource.
            This field is planned to be deprecated in favor of the ManagementPolicies
            field in a future release. Currently, both could be set independently and
            non-default values would be honored if the feature flag is enabled.
            See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
            """
            return self._set("deletion_policy", value)

        @overload
        def for_provider(
            self, value_or_callback: ForProviderModel1, /
        ) -> "BucketPolicySpec.Builder": ...

        @overload
        def for_provider(
            self,
            value_or_callback: Callable[
                [ForProviderModel1.Builder],
                ForProviderModel1.Builder | ForProviderModel1,
            ],
            /,
        ) -> "BucketPolicySpec.Builder": ...

        @overload
        def for_provider(
            self, value_or_callback: Never = ...
        ) -> "ForProviderModel1.BuilderContext": ...

        def for_provider(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ForProviderModel1.BuilderContext()
                context._parent_builder = self
                context._field_name = "for_provider"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ForProviderModel1.builder())
                if isinstance(output, ForProviderModel1.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("for_provider", value)

        @overload
        def init_provider(
            self, value_or_callback: Optional[InitProviderModel1], /
        ) -> "BucketPolicySpec.Builder": ...

        @overload
        def init_provider(
            self,
            value_or_callback: Callable[
                [InitProviderModel1.Builder],
                InitProviderModel1.Builder | InitProviderModel1,
            ],
            /,
        ) -> "BucketPolicySpec.Builder": ...

        @overload
        def init_provider(
            self, value_or_callback: Never = ...
        ) -> "InitProviderModel1.BuilderContext": ...

        def init_provider(self, value_or_callback=None, /):
            """
            THIS IS A BETA FIELD. It will be honored
            unless the Management Policies feature flag is disabled.
            InitProvider holds the same fields as ForProvider, with the exception
            of Identifier and other resource reference fields. The fields that are
            in InitProvider are merged into ForProvider when the resource is created.
            The same fields are also added to the terraform ignore_changes hook, to
            avoid updating them after creation. This is useful for fields that are
            required on creation, but we do not desire to update them after creation,
            for example because of an external controller is managing them, like an
            autoscaler.
            """
            if self._in_context and value_or_callback is None:
                context = InitProviderModel1.BuilderContext()
                context._parent_builder = self
                context._field_name = "init_provider"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(InitProviderModel1.builder())
                if isinstance(output, InitProviderModel1.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("init_provider", value)

        def management_policies(
            self,
            value: Optional[
                List[Literal["Observe", "Create", "Update", "Delete", "LateInitialize", "*"]]
            ],
            /,
        ) -> Self:
            """
            THIS IS A BETA FIELD. It is on by default but can be opted out
            through a Crossplane feature flag.
            ManagementPolicies specify the array of actions Crossplane is allowed to
            take on the managed and external resources.
            This field is planned to replace the DeletionPolicy field in a future
            release. Currently, both could be set independently and non-default
            values would be honored if the feature flag is enabled. If both are
            custom, the DeletionPolicy field will be ignored.
            See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
            and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
            """
            return self._set("management_policies", value)

        @overload
        def provider_config_ref(
            self, value_or_callback: Optional[ProviderConfigRef], /
        ) -> "BucketPolicySpec.Builder": ...

        @overload
        def provider_config_ref(
            self,
            value_or_callback: Callable[
                [ProviderConfigRef.Builder],
                ProviderConfigRef.Builder | ProviderConfigRef,
            ],
            /,
        ) -> "BucketPolicySpec.Builder": ...

        @overload
        def provider_config_ref(
            self, value_or_callback: Never = ...
        ) -> "ProviderConfigRef.BuilderContext": ...

        def provider_config_ref(self, value_or_callback=None, /):
            """
            ProviderConfigReference specifies how the provider that will be used to
            create, observe, update, and delete this managed resource should be
            configured.
            """
            if self._in_context and value_or_callback is None:
                context = ProviderConfigRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "provider_config_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ProviderConfigRef.builder())
                if isinstance(output, ProviderConfigRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("provider_config_ref", value)

        @overload
        def publish_connection_details_to(
            self, value_or_callback: Optional[PublishConnectionDetailsTo], /
        ) -> "BucketPolicySpec.Builder": ...

        @overload
        def publish_connection_details_to(
            self,
            value_or_callback: Callable[
                [PublishConnectionDetailsTo.Builder],
                PublishConnectionDetailsTo.Builder | PublishConnectionDetailsTo,
            ],
            /,
        ) -> "BucketPolicySpec.Builder": ...

        @overload
        def publish_connection_details_to(
            self, value_or_callback: Never = ...
        ) -> "PublishConnectionDetailsTo.BuilderContext": ...

        def publish_connection_details_to(self, value_or_callback=None, /):
            """
            PublishConnectionDetailsTo specifies the connection secret config which
            contains a name, metadata and a reference to secret store config to
            which any connection details for this managed resource should be written.
            Connection details frequently include the endpoint, username,
            and password required to connect to the managed resource.
            """
            if self._in_context and value_or_callback is None:
                context = PublishConnectionDetailsTo.BuilderContext()
                context._parent_builder = self
                context._field_name = "publish_connection_details_to"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PublishConnectionDetailsTo.builder())
                if isinstance(output, PublishConnectionDetailsTo.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("publish_connection_details_to", value)

        @overload
        def write_connection_secret_to_ref(
            self, value_or_callback: Optional[WriteConnectionSecretToRef], /
        ) -> "BucketPolicySpec.Builder": ...

        @overload
        def write_connection_secret_to_ref(
            self,
            value_or_callback: Callable[
                [WriteConnectionSecretToRef.Builder],
                WriteConnectionSecretToRef.Builder | WriteConnectionSecretToRef,
            ],
            /,
        ) -> "BucketPolicySpec.Builder": ...

        @overload
        def write_connection_secret_to_ref(
            self, value_or_callback: Never = ...
        ) -> "WriteConnectionSecretToRef.BuilderContext": ...

        def write_connection_secret_to_ref(self, value_or_callback=None, /):
            """
            WriteConnectionSecretToReference specifies the namespace and name of a
            Secret to which any connection details for this managed resource should
            be written. Connection details frequently include the endpoint, username,
            and password required to connect to the managed resource.
            This field is planned to be replaced in a future release in favor of
            PublishConnectionDetailsTo. Currently, both could be set independently
            and connection details would be published to both without affecting
            each other.
            """
            if self._in_context and value_or_callback is None:
                context = WriteConnectionSecretToRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "write_connection_secret_to_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(WriteConnectionSecretToRef.builder())
                if isinstance(output, WriteConnectionSecretToRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("write_connection_secret_to_ref", value)

    class BuilderContext(BuilderContextBase["BucketPolicySpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = BucketPolicySpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for BucketPolicySpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["BucketPolicySpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use BucketPolicySpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    deletion_policy: Annotated[
        Optional[Literal["Orphan", "Delete"]], Field(alias="deletionPolicy")
    ] = "Delete"
    """
    DeletionPolicy specifies what will happen to the underlying external
    when this managed resource is deleted - either "Delete" or "Orphan" the
    external resource.
    This field is planned to be deprecated in favor of the ManagementPolicies
    field in a future release. Currently, both could be set independently and
    non-default values would be honored if the feature flag is enabled.
    See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    """
    for_provider: Annotated[ForProviderModel1, Field(alias="forProvider")]
    init_provider: Annotated[Optional[InitProviderModel1], Field(alias="initProvider")] = None
    """
    THIS IS A BETA FIELD. It will be honored
    unless the Management Policies feature flag is disabled.
    InitProvider holds the same fields as ForProvider, with the exception
    of Identifier and other resource reference fields. The fields that are
    in InitProvider are merged into ForProvider when the resource is created.
    The same fields are also added to the terraform ignore_changes hook, to
    avoid updating them after creation. This is useful for fields that are
    required on creation, but we do not desire to update them after creation,
    for example because of an external controller is managing them, like an
    autoscaler.
    """
    management_policies: Annotated[
        Optional[List[Literal["Observe", "Create", "Update", "Delete", "LateInitialize", "*"]]],
        Field(alias="managementPolicies"),
    ] = ["*"]
    """
    THIS IS A BETA FIELD. It is on by default but can be opted out
    through a Crossplane feature flag.
    ManagementPolicies specify the array of actions Crossplane is allowed to
    take on the managed and external resources.
    This field is planned to replace the DeletionPolicy field in a future
    release. Currently, both could be set independently and non-default
    values would be honored if the feature flag is enabled. If both are
    custom, the DeletionPolicy field will be ignored.
    See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
    """
    provider_config_ref: Annotated[
        Optional[ProviderConfigRef],
        Field(
            default_factory=lambda: ProviderConfigRef.model_validate({"name": "default"}),
            alias="providerConfigRef",
        ),
    ] = {"name": "default"}
    """
    ProviderConfigReference specifies how the provider that will be used to
    create, observe, update, and delete this managed resource should be
    configured.
    """
    publish_connection_details_to: Annotated[
        Optional[PublishConnectionDetailsTo], Field(alias="publishConnectionDetailsTo")
    ] = None
    """
    PublishConnectionDetailsTo specifies the connection secret config which
    contains a name, metadata and a reference to secret store config to
    which any connection details for this managed resource should be written.
    Connection details frequently include the endpoint, username,
    and password required to connect to the managed resource.
    """
    write_connection_secret_to_ref: Annotated[
        Optional[WriteConnectionSecretToRef], Field(alias="writeConnectionSecretToRef")
    ] = None
    """
    WriteConnectionSecretToReference specifies the namespace and name of a
    Secret to which any connection details for this managed resource should
    be written. Connection details frequently include the endpoint, username,
    and password required to connect to the managed resource.
    This field is planned to be replaced in a future release in favor of
    PublishConnectionDetailsTo. Currently, both could be set independently
    and connection details would be published to both without affecting
    each other.
    """


class AtProviderModel1(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AtProviderModel1"]:
            return AtProviderModel1

        def build(self) -> "AtProviderModel1":
            return AtProviderModel1(**self._attrs)

        def bucket(self, value: Optional[str], /) -> Self:
            """
            The name of the bucket to which to apply the policy.
            """
            return self._set("bucket", value)

        def id(self, value: Optional[str], /) -> Self:
            return self._set("id", value)

        def policy(self, value: Optional[str], /) -> Self:
            """
            The text of the policy.
            """
            return self._set("policy", value)

        def region(self, value: Optional[str], /) -> Self:
            """
            The region where the bucket resides.
            """
            return self._set("region", value)

    class BuilderContext(BuilderContextBase["AtProviderModel1.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AtProviderModel1.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AtProviderModel1."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AtProviderModel1", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AtProviderModel1.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    bucket: Optional[str] = None
    """
    The name of the bucket to which to apply the policy.
    """
    id: Optional[str] = None
    policy: Optional[str] = None
    """
    The text of the policy.
    """
    region: Optional[str] = None
    """
    The region where the bucket resides.
    """


class BucketPolicyStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["BucketPolicyStatus"]:
            return BucketPolicyStatus

        def build(self) -> "BucketPolicyStatus":
            return BucketPolicyStatus(**self._attrs)

        @overload
        def at_provider(
            self, value_or_callback: Optional[AtProviderModel1], /
        ) -> "BucketPolicyStatus.Builder": ...

        @overload
        def at_provider(
            self,
            value_or_callback: Callable[
                [AtProviderModel1.Builder], AtProviderModel1.Builder | AtProviderModel1
            ],
            /,
        ) -> "BucketPolicyStatus.Builder": ...

        @overload
        def at_provider(
            self, value_or_callback: Never = ...
        ) -> "AtProviderModel1.BuilderContext": ...

        def at_provider(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = AtProviderModel1.BuilderContext()
                context._parent_builder = self
                context._field_name = "at_provider"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AtProviderModel1.builder())
                if isinstance(output, AtProviderModel1.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("at_provider", value)

        @overload
        def conditions(
            self, value_or_callback: List[Condition], /
        ) -> "BucketPolicyStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Condition, Condition.Builder]],
                GenericListBuilder[Condition, Condition.Builder] | List[Condition],
            ],
            /,
        ) -> "BucketPolicyStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            """
            Conditions of the resource.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        def observed_generation(self, value: Optional[int], /) -> Self:
            """
            ObservedGeneration is the latest metadata.generation
            which resulted in either a ready state, or stalled due to error
            it can not recover from without human intervention.
            """
            return self._set("observed_generation", value)

    class BuilderContext(BuilderContextBase["BucketPolicyStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = BucketPolicyStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for BucketPolicyStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["BucketPolicyStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use BucketPolicyStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    at_provider: Annotated[Optional[AtProviderModel1], Field(alias="atProvider")] = None
    conditions: Optional[List[Condition]] = None
    """
    Conditions of the resource.
    """
    observed_generation: Annotated[Optional[int], Field(alias="observedGeneration")] = None
    """
    ObservedGeneration is the latest metadata.generation
    which resulted in either a ready state, or stalled due to error
    it can not recover from without human intervention.
    """


class CorsRuleModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["CorsRuleModel"]:
            return CorsRuleModel

        def build(self) -> "CorsRuleModel":
            return CorsRuleModel(**self._attrs)

        def allowed_headers(self, value: Optional[List[str]], /) -> Self:
            """
            A list of headers that will be included in the CORS preflight request's Access-Control-Request-Headers. A header may contain one wildcard (e.g. x-amz-*).
            A list of headers that will be included in the CORS preflight request's Access-Control-Request-Headers. A header may contain one wildcard (e.g. x-amz-*).
            """
            return self._set("allowed_headers", value)

        def allowed_methods(self, value: Optional[List[str]], /) -> Self:
            """
            A list of HTTP methods (e.g. GET) which are allowed from the specified origin.
            A list of HTTP methods (e.g. GET) which are allowed from the specified origin.
            """
            return self._set("allowed_methods", value)

        def allowed_origins(self, value: Optional[List[str]], /) -> Self:
            """
            A list of hosts from which requests using the specified methods are allowed. A host may contain one wildcard (e.g. http://*.example.com).
            A list of hosts from which requests using the specified methods are allowed. A host may contain one wildcard (e.g. http://*.example.com).
            """
            return self._set("allowed_origins", value)

        def max_age_seconds(self, value: Optional[float], /) -> Self:
            """
            The time in seconds that browser can cache the response for a preflight request.
            """
            return self._set("max_age_seconds", value)

    class BuilderContext(BuilderContextBase["CorsRuleModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = CorsRuleModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for CorsRuleModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["CorsRuleModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use CorsRuleModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    allowed_headers: Annotated[Optional[List[str]], Field(alias="allowedHeaders")] = None
    """
    A list of headers that will be included in the CORS preflight request's Access-Control-Request-Headers. A header may contain one wildcard (e.g. x-amz-*).
    A list of headers that will be included in the CORS preflight request's Access-Control-Request-Headers. A header may contain one wildcard (e.g. x-amz-*).
    """
    allowed_methods: Annotated[Optional[List[str]], Field(alias="allowedMethods")] = None
    """
    A list of HTTP methods (e.g. GET) which are allowed from the specified origin.
    A list of HTTP methods (e.g. GET) which are allowed from the specified origin.
    """
    allowed_origins: Annotated[Optional[List[str]], Field(alias="allowedOrigins")] = None
    """
    A list of hosts from which requests using the specified methods are allowed. A host may contain one wildcard (e.g. http://*.example.com).
    A list of hosts from which requests using the specified methods are allowed. A host may contain one wildcard (e.g. http://*.example.com).
    """
    max_age_seconds: Annotated[Optional[float], Field(alias="maxAgeSeconds")] = None
    """
    The time in seconds that browser can cache the response for a preflight request.
    """


class Expiration(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Expiration"]:
            return Expiration

        def build(self) -> "Expiration":
            return Expiration(**self._attrs)

        def date(self, value: Optional[str], /) -> Self:
            """
            Specifies the date/time after which you want applicable objects to expire. The argument uses
            RFC3339 format, e.g. "2020-03-22T15:03:55Z" or parts thereof e.g. "2019-02-28".
            """
            return self._set("date", value)

        def days(self, value: Optional[float], /) -> Self:
            """
            Specifies the number of days after object creation when the applicable objects will expire.
            """
            return self._set("days", value)

        def expired_object_delete_marker(self, value: Optional[bool], /) -> Self:
            """
            On a versioned bucket (versioning-enabled or versioning-suspended
            bucket), setting this to true directs Spaces to delete expired object delete markers.
            """
            return self._set("expired_object_delete_marker", value)

    class BuilderContext(BuilderContextBase["Expiration.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Expiration.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Expiration."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Expiration", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Expiration.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    date: Optional[str] = None
    """
    Specifies the date/time after which you want applicable objects to expire. The argument uses
    RFC3339 format, e.g. "2020-03-22T15:03:55Z" or parts thereof e.g. "2019-02-28".
    """
    days: Optional[float] = None
    """
    Specifies the number of days after object creation when the applicable objects will expire.
    """
    expired_object_delete_marker: Annotated[
        Optional[bool], Field(alias="expiredObjectDeleteMarker")
    ] = None
    """
    On a versioned bucket (versioning-enabled or versioning-suspended
    bucket), setting this to true directs Spaces to delete expired object delete markers.
    """


class NoncurrentVersionExpiration(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["NoncurrentVersionExpiration"]:
            return NoncurrentVersionExpiration

        def build(self) -> "NoncurrentVersionExpiration":
            return NoncurrentVersionExpiration(**self._attrs)

        def days(self, value: Optional[float], /) -> Self:
            """
            Specifies the number of days after object creation when the applicable objects will expire.
            """
            return self._set("days", value)

    class BuilderContext(BuilderContextBase["NoncurrentVersionExpiration.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = NoncurrentVersionExpiration.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for NoncurrentVersionExpiration."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["NoncurrentVersionExpiration", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use NoncurrentVersionExpiration.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    days: Optional[float] = None
    """
    Specifies the number of days after object creation when the applicable objects will expire.
    """


class LifecycleRule(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["LifecycleRule"]:
            return LifecycleRule

        def build(self) -> "LifecycleRule":
            return LifecycleRule(**self._attrs)

        def abort_incomplete_multipart_upload_days(self, value: Optional[float], /) -> Self:
            """
            Specifies the number of days after initiating a multipart
            upload when the multipart upload must be completed or else Spaces will abort the upload.
            """
            return self._set("abort_incomplete_multipart_upload_days", value)

        def enabled(self, value: Optional[bool], /) -> Self:
            """
            Specifies lifecycle rule status.
            """
            return self._set("enabled", value)

        @overload
        def expiration(self, value_or_callback: List[Expiration], /) -> "LifecycleRule.Builder": ...

        @overload
        def expiration(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Expiration, Expiration.Builder]],
                GenericListBuilder[Expiration, Expiration.Builder] | List[Expiration],
            ],
            /,
        ) -> "LifecycleRule.Builder": ...

        @overload
        def expiration(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Expiration.Builder]: ...

        def expiration(self, value_or_callback=None, /):
            """
            Specifies a time period after which applicable objects expire (documented below).
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Expiration.Builder]()
                context._parent_builder = self
                context._field_name = "expiration"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Expiration.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("expiration", value)

        def id(self, value: Optional[str], /) -> Self:
            """
            Unique identifier for the rule.
            """
            return self._set("id", value)

        @overload
        def noncurrent_version_expiration(
            self, value_or_callback: List[NoncurrentVersionExpiration], /
        ) -> "LifecycleRule.Builder": ...

        @overload
        def noncurrent_version_expiration(
            self,
            value_or_callback: Callable[
                [
                    GenericListBuilder[
                        NoncurrentVersionExpiration, NoncurrentVersionExpiration.Builder
                    ]
                ],
                GenericListBuilder[NoncurrentVersionExpiration, NoncurrentVersionExpiration.Builder]
                | List[NoncurrentVersionExpiration],
            ],
            /,
        ) -> "LifecycleRule.Builder": ...

        @overload
        def noncurrent_version_expiration(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[NoncurrentVersionExpiration.Builder]: ...

        def noncurrent_version_expiration(self, value_or_callback=None, /):
            """
            Specifies when non-current object versions expire (documented below).
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[NoncurrentVersionExpiration.Builder]()
                context._parent_builder = self
                context._field_name = "noncurrent_version_expiration"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(NoncurrentVersionExpiration.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("noncurrent_version_expiration", value)

        def prefix(self, value: Optional[str], /) -> Self:
            """
            Object key prefix identifying one or more objects to which the rule applies.
            """
            return self._set("prefix", value)

    class BuilderContext(BuilderContextBase["LifecycleRule.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = LifecycleRule.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for LifecycleRule."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["LifecycleRule", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use LifecycleRule.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    abort_incomplete_multipart_upload_days: Annotated[
        Optional[float], Field(alias="abortIncompleteMultipartUploadDays")
    ] = None
    """
    Specifies the number of days after initiating a multipart
    upload when the multipart upload must be completed or else Spaces will abort the upload.
    """
    enabled: Optional[bool] = None
    """
    Specifies lifecycle rule status.
    """
    expiration: Optional[List[Expiration]] = None
    """
    Specifies a time period after which applicable objects expire (documented below).
    """
    id: Optional[str] = None
    """
    Unique identifier for the rule.
    """
    noncurrent_version_expiration: Annotated[
        Optional[List[NoncurrentVersionExpiration]],
        Field(alias="noncurrentVersionExpiration"),
    ] = None
    """
    Specifies when non-current object versions expire (documented below).
    """
    prefix: Optional[str] = None
    """
    Object key prefix identifying one or more objects to which the rule applies.
    """


class Versioning(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Versioning"]:
            return Versioning

        def build(self) -> "Versioning":
            return Versioning(**self._attrs)

        def enabled(self, value: Optional[bool], /) -> Self:
            """
            Specifies lifecycle rule status.
            """
            return self._set("enabled", value)

    class BuilderContext(BuilderContextBase["Versioning.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Versioning.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Versioning."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Versioning", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Versioning.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    enabled: Optional[bool] = None
    """
    Specifies lifecycle rule status.
    """


class ForProviderModel2(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ForProviderModel2"]:
            return ForProviderModel2

        def build(self) -> "ForProviderModel2":
            return ForProviderModel2(**self._attrs)

        def acl(self, value: Optional[str], /) -> Self:
            """
            Canned ACL applied on bucket creation: private or public-read (Defaults to private)
            Canned ACL applied on bucket creation
            """
            return self._set("acl", value)

        @overload
        def cors_rule(
            self, value_or_callback: List[CorsRuleModel], /
        ) -> "ForProviderModel2.Builder": ...

        @overload
        def cors_rule(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[CorsRuleModel, CorsRuleModel.Builder]],
                GenericListBuilder[CorsRuleModel, CorsRuleModel.Builder] | List[CorsRuleModel],
            ],
            /,
        ) -> "ForProviderModel2.Builder": ...

        @overload
        def cors_rule(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[CorsRuleModel.Builder]: ...

        def cors_rule(self, value_or_callback=None, /):
            """
            A rule of Cross-Origin Resource Sharing (documented below).
            A container holding a list of elements describing allowed methods for a specific origin.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[CorsRuleModel.Builder]()
                context._parent_builder = self
                context._field_name = "cors_rule"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(CorsRuleModel.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("cors_rule", value)

        def force_destroy(self, value: Optional[bool], /) -> Self:
            """
            Unless true, the bucket will only be destroyed if empty (Defaults to false)
            Unless true, the bucket will only be destroyed if empty
            """
            return self._set("force_destroy", value)

        @overload
        def lifecycle_rule(
            self, value_or_callback: List[LifecycleRule], /
        ) -> "ForProviderModel2.Builder": ...

        @overload
        def lifecycle_rule(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[LifecycleRule, LifecycleRule.Builder]],
                GenericListBuilder[LifecycleRule, LifecycleRule.Builder] | List[LifecycleRule],
            ],
            /,
        ) -> "ForProviderModel2.Builder": ...

        @overload
        def lifecycle_rule(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[LifecycleRule.Builder]: ...

        def lifecycle_rule(self, value_or_callback=None, /):
            """
            A configuration of object lifecycle management (documented below).
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[LifecycleRule.Builder]()
                context._parent_builder = self
                context._field_name = "lifecycle_rule"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(LifecycleRule.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("lifecycle_rule", value)

        def region(self, value: Optional[str], /) -> Self:
            """
            The region where the bucket resides (Defaults to nyc3)
            Bucket region
            """
            return self._set("region", value)

        @overload
        def versioning(
            self, value_or_callback: List[Versioning], /
        ) -> "ForProviderModel2.Builder": ...

        @overload
        def versioning(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Versioning, Versioning.Builder]],
                GenericListBuilder[Versioning, Versioning.Builder] | List[Versioning],
            ],
            /,
        ) -> "ForProviderModel2.Builder": ...

        @overload
        def versioning(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Versioning.Builder]: ...

        def versioning(self, value_or_callback=None, /):
            """
            A state of versioning (documented below)
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Versioning.Builder]()
                context._parent_builder = self
                context._field_name = "versioning"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Versioning.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("versioning", value)

    class BuilderContext(BuilderContextBase["ForProviderModel2.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ForProviderModel2.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ForProviderModel2."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ForProviderModel2", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ForProviderModel2.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    acl: Optional[str] = None
    """
    Canned ACL applied on bucket creation: private or public-read (Defaults to private)
    Canned ACL applied on bucket creation
    """
    cors_rule: Annotated[Optional[List[CorsRuleModel]], Field(alias="corsRule")] = None
    """
    A rule of Cross-Origin Resource Sharing (documented below).
    A container holding a list of elements describing allowed methods for a specific origin.
    """
    force_destroy: Annotated[Optional[bool], Field(alias="forceDestroy")] = None
    """
    Unless true, the bucket will only be destroyed if empty (Defaults to false)
    Unless true, the bucket will only be destroyed if empty
    """
    lifecycle_rule: Annotated[Optional[List[LifecycleRule]], Field(alias="lifecycleRule")] = None
    """
    A configuration of object lifecycle management (documented below).
    """
    region: Optional[str] = None
    """
    The region where the bucket resides (Defaults to nyc3)
    Bucket region
    """
    versioning: Optional[List[Versioning]] = None
    """
    A state of versioning (documented below)
    """


class InitProviderModel2(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["InitProviderModel2"]:
            return InitProviderModel2

        def build(self) -> "InitProviderModel2":
            return InitProviderModel2(**self._attrs)

        def acl(self, value: Optional[str], /) -> Self:
            """
            Canned ACL applied on bucket creation: private or public-read (Defaults to private)
            Canned ACL applied on bucket creation
            """
            return self._set("acl", value)

        @overload
        def cors_rule(
            self, value_or_callback: List[CorsRuleModel], /
        ) -> "InitProviderModel2.Builder": ...

        @overload
        def cors_rule(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[CorsRuleModel, CorsRuleModel.Builder]],
                GenericListBuilder[CorsRuleModel, CorsRuleModel.Builder] | List[CorsRuleModel],
            ],
            /,
        ) -> "InitProviderModel2.Builder": ...

        @overload
        def cors_rule(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[CorsRuleModel.Builder]: ...

        def cors_rule(self, value_or_callback=None, /):
            """
            A rule of Cross-Origin Resource Sharing (documented below).
            A container holding a list of elements describing allowed methods for a specific origin.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[CorsRuleModel.Builder]()
                context._parent_builder = self
                context._field_name = "cors_rule"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(CorsRuleModel.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("cors_rule", value)

        def force_destroy(self, value: Optional[bool], /) -> Self:
            """
            Unless true, the bucket will only be destroyed if empty (Defaults to false)
            Unless true, the bucket will only be destroyed if empty
            """
            return self._set("force_destroy", value)

        @overload
        def lifecycle_rule(
            self, value_or_callback: List[LifecycleRule], /
        ) -> "InitProviderModel2.Builder": ...

        @overload
        def lifecycle_rule(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[LifecycleRule, LifecycleRule.Builder]],
                GenericListBuilder[LifecycleRule, LifecycleRule.Builder] | List[LifecycleRule],
            ],
            /,
        ) -> "InitProviderModel2.Builder": ...

        @overload
        def lifecycle_rule(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[LifecycleRule.Builder]: ...

        def lifecycle_rule(self, value_or_callback=None, /):
            """
            A configuration of object lifecycle management (documented below).
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[LifecycleRule.Builder]()
                context._parent_builder = self
                context._field_name = "lifecycle_rule"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(LifecycleRule.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("lifecycle_rule", value)

        def region(self, value: Optional[str], /) -> Self:
            """
            The region where the bucket resides (Defaults to nyc3)
            Bucket region
            """
            return self._set("region", value)

        @overload
        def versioning(
            self, value_or_callback: List[Versioning], /
        ) -> "InitProviderModel2.Builder": ...

        @overload
        def versioning(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Versioning, Versioning.Builder]],
                GenericListBuilder[Versioning, Versioning.Builder] | List[Versioning],
            ],
            /,
        ) -> "InitProviderModel2.Builder": ...

        @overload
        def versioning(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Versioning.Builder]: ...

        def versioning(self, value_or_callback=None, /):
            """
            A state of versioning (documented below)
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Versioning.Builder]()
                context._parent_builder = self
                context._field_name = "versioning"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Versioning.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("versioning", value)

    class BuilderContext(BuilderContextBase["InitProviderModel2.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = InitProviderModel2.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for InitProviderModel2."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["InitProviderModel2", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use InitProviderModel2.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    acl: Optional[str] = None
    """
    Canned ACL applied on bucket creation: private or public-read (Defaults to private)
    Canned ACL applied on bucket creation
    """
    cors_rule: Annotated[Optional[List[CorsRuleModel]], Field(alias="corsRule")] = None
    """
    A rule of Cross-Origin Resource Sharing (documented below).
    A container holding a list of elements describing allowed methods for a specific origin.
    """
    force_destroy: Annotated[Optional[bool], Field(alias="forceDestroy")] = None
    """
    Unless true, the bucket will only be destroyed if empty (Defaults to false)
    Unless true, the bucket will only be destroyed if empty
    """
    lifecycle_rule: Annotated[Optional[List[LifecycleRule]], Field(alias="lifecycleRule")] = None
    """
    A configuration of object lifecycle management (documented below).
    """
    region: Optional[str] = None
    """
    The region where the bucket resides (Defaults to nyc3)
    Bucket region
    """
    versioning: Optional[List[Versioning]] = None
    """
    A state of versioning (documented below)
    """


class BucketSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["BucketSpec"]:
            return BucketSpec

        def build(self) -> "BucketSpec":
            return BucketSpec(**self._attrs)

        def deletion_policy(self, value: Optional[Literal["Orphan", "Delete"]], /) -> Self:
            """
            DeletionPolicy specifies what will happen to the underlying external
            when this managed resource is deleted - either "Delete" or "Orphan" the
            external resource.
            This field is planned to be deprecated in favor of the ManagementPolicies
            field in a future release. Currently, both could be set independently and
            non-default values would be honored if the feature flag is enabled.
            See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
            """
            return self._set("deletion_policy", value)

        @overload
        def for_provider(self, value_or_callback: ForProviderModel2, /) -> "BucketSpec.Builder": ...

        @overload
        def for_provider(
            self,
            value_or_callback: Callable[
                [ForProviderModel2.Builder],
                ForProviderModel2.Builder | ForProviderModel2,
            ],
            /,
        ) -> "BucketSpec.Builder": ...

        @overload
        def for_provider(
            self, value_or_callback: Never = ...
        ) -> "ForProviderModel2.BuilderContext": ...

        def for_provider(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ForProviderModel2.BuilderContext()
                context._parent_builder = self
                context._field_name = "for_provider"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ForProviderModel2.builder())
                if isinstance(output, ForProviderModel2.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("for_provider", value)

        @overload
        def init_provider(
            self, value_or_callback: Optional[InitProviderModel2], /
        ) -> "BucketSpec.Builder": ...

        @overload
        def init_provider(
            self,
            value_or_callback: Callable[
                [InitProviderModel2.Builder],
                InitProviderModel2.Builder | InitProviderModel2,
            ],
            /,
        ) -> "BucketSpec.Builder": ...

        @overload
        def init_provider(
            self, value_or_callback: Never = ...
        ) -> "InitProviderModel2.BuilderContext": ...

        def init_provider(self, value_or_callback=None, /):
            """
            THIS IS A BETA FIELD. It will be honored
            unless the Management Policies feature flag is disabled.
            InitProvider holds the same fields as ForProvider, with the exception
            of Identifier and other resource reference fields. The fields that are
            in InitProvider are merged into ForProvider when the resource is created.
            The same fields are also added to the terraform ignore_changes hook, to
            avoid updating them after creation. This is useful for fields that are
            required on creation, but we do not desire to update them after creation,
            for example because of an external controller is managing them, like an
            autoscaler.
            """
            if self._in_context and value_or_callback is None:
                context = InitProviderModel2.BuilderContext()
                context._parent_builder = self
                context._field_name = "init_provider"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(InitProviderModel2.builder())
                if isinstance(output, InitProviderModel2.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("init_provider", value)

        def management_policies(
            self,
            value: Optional[
                List[Literal["Observe", "Create", "Update", "Delete", "LateInitialize", "*"]]
            ],
            /,
        ) -> Self:
            """
            THIS IS A BETA FIELD. It is on by default but can be opted out
            through a Crossplane feature flag.
            ManagementPolicies specify the array of actions Crossplane is allowed to
            take on the managed and external resources.
            This field is planned to replace the DeletionPolicy field in a future
            release. Currently, both could be set independently and non-default
            values would be honored if the feature flag is enabled. If both are
            custom, the DeletionPolicy field will be ignored.
            See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
            and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
            """
            return self._set("management_policies", value)

        @overload
        def provider_config_ref(
            self, value_or_callback: Optional[ProviderConfigRef], /
        ) -> "BucketSpec.Builder": ...

        @overload
        def provider_config_ref(
            self,
            value_or_callback: Callable[
                [ProviderConfigRef.Builder],
                ProviderConfigRef.Builder | ProviderConfigRef,
            ],
            /,
        ) -> "BucketSpec.Builder": ...

        @overload
        def provider_config_ref(
            self, value_or_callback: Never = ...
        ) -> "ProviderConfigRef.BuilderContext": ...

        def provider_config_ref(self, value_or_callback=None, /):
            """
            ProviderConfigReference specifies how the provider that will be used to
            create, observe, update, and delete this managed resource should be
            configured.
            """
            if self._in_context and value_or_callback is None:
                context = ProviderConfigRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "provider_config_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ProviderConfigRef.builder())
                if isinstance(output, ProviderConfigRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("provider_config_ref", value)

        @overload
        def publish_connection_details_to(
            self, value_or_callback: Optional[PublishConnectionDetailsTo], /
        ) -> "BucketSpec.Builder": ...

        @overload
        def publish_connection_details_to(
            self,
            value_or_callback: Callable[
                [PublishConnectionDetailsTo.Builder],
                PublishConnectionDetailsTo.Builder | PublishConnectionDetailsTo,
            ],
            /,
        ) -> "BucketSpec.Builder": ...

        @overload
        def publish_connection_details_to(
            self, value_or_callback: Never = ...
        ) -> "PublishConnectionDetailsTo.BuilderContext": ...

        def publish_connection_details_to(self, value_or_callback=None, /):
            """
            PublishConnectionDetailsTo specifies the connection secret config which
            contains a name, metadata and a reference to secret store config to
            which any connection details for this managed resource should be written.
            Connection details frequently include the endpoint, username,
            and password required to connect to the managed resource.
            """
            if self._in_context and value_or_callback is None:
                context = PublishConnectionDetailsTo.BuilderContext()
                context._parent_builder = self
                context._field_name = "publish_connection_details_to"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PublishConnectionDetailsTo.builder())
                if isinstance(output, PublishConnectionDetailsTo.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("publish_connection_details_to", value)

        @overload
        def write_connection_secret_to_ref(
            self, value_or_callback: Optional[WriteConnectionSecretToRef], /
        ) -> "BucketSpec.Builder": ...

        @overload
        def write_connection_secret_to_ref(
            self,
            value_or_callback: Callable[
                [WriteConnectionSecretToRef.Builder],
                WriteConnectionSecretToRef.Builder | WriteConnectionSecretToRef,
            ],
            /,
        ) -> "BucketSpec.Builder": ...

        @overload
        def write_connection_secret_to_ref(
            self, value_or_callback: Never = ...
        ) -> "WriteConnectionSecretToRef.BuilderContext": ...

        def write_connection_secret_to_ref(self, value_or_callback=None, /):
            """
            WriteConnectionSecretToReference specifies the namespace and name of a
            Secret to which any connection details for this managed resource should
            be written. Connection details frequently include the endpoint, username,
            and password required to connect to the managed resource.
            This field is planned to be replaced in a future release in favor of
            PublishConnectionDetailsTo. Currently, both could be set independently
            and connection details would be published to both without affecting
            each other.
            """
            if self._in_context and value_or_callback is None:
                context = WriteConnectionSecretToRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "write_connection_secret_to_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(WriteConnectionSecretToRef.builder())
                if isinstance(output, WriteConnectionSecretToRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("write_connection_secret_to_ref", value)

    class BuilderContext(BuilderContextBase["BucketSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = BucketSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for BucketSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["BucketSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use BucketSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    deletion_policy: Annotated[
        Optional[Literal["Orphan", "Delete"]], Field(alias="deletionPolicy")
    ] = "Delete"
    """
    DeletionPolicy specifies what will happen to the underlying external
    when this managed resource is deleted - either "Delete" or "Orphan" the
    external resource.
    This field is planned to be deprecated in favor of the ManagementPolicies
    field in a future release. Currently, both could be set independently and
    non-default values would be honored if the feature flag is enabled.
    See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    """
    for_provider: Annotated[ForProviderModel2, Field(alias="forProvider")]
    init_provider: Annotated[Optional[InitProviderModel2], Field(alias="initProvider")] = None
    """
    THIS IS A BETA FIELD. It will be honored
    unless the Management Policies feature flag is disabled.
    InitProvider holds the same fields as ForProvider, with the exception
    of Identifier and other resource reference fields. The fields that are
    in InitProvider are merged into ForProvider when the resource is created.
    The same fields are also added to the terraform ignore_changes hook, to
    avoid updating them after creation. This is useful for fields that are
    required on creation, but we do not desire to update them after creation,
    for example because of an external controller is managing them, like an
    autoscaler.
    """
    management_policies: Annotated[
        Optional[List[Literal["Observe", "Create", "Update", "Delete", "LateInitialize", "*"]]],
        Field(alias="managementPolicies"),
    ] = ["*"]
    """
    THIS IS A BETA FIELD. It is on by default but can be opted out
    through a Crossplane feature flag.
    ManagementPolicies specify the array of actions Crossplane is allowed to
    take on the managed and external resources.
    This field is planned to replace the DeletionPolicy field in a future
    release. Currently, both could be set independently and non-default
    values would be honored if the feature flag is enabled. If both are
    custom, the DeletionPolicy field will be ignored.
    See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
    """
    provider_config_ref: Annotated[
        Optional[ProviderConfigRef],
        Field(
            default_factory=lambda: ProviderConfigRef.model_validate({"name": "default"}),
            alias="providerConfigRef",
        ),
    ] = {"name": "default"}
    """
    ProviderConfigReference specifies how the provider that will be used to
    create, observe, update, and delete this managed resource should be
    configured.
    """
    publish_connection_details_to: Annotated[
        Optional[PublishConnectionDetailsTo], Field(alias="publishConnectionDetailsTo")
    ] = None
    """
    PublishConnectionDetailsTo specifies the connection secret config which
    contains a name, metadata and a reference to secret store config to
    which any connection details for this managed resource should be written.
    Connection details frequently include the endpoint, username,
    and password required to connect to the managed resource.
    """
    write_connection_secret_to_ref: Annotated[
        Optional[WriteConnectionSecretToRef], Field(alias="writeConnectionSecretToRef")
    ] = None
    """
    WriteConnectionSecretToReference specifies the namespace and name of a
    Secret to which any connection details for this managed resource should
    be written. Connection details frequently include the endpoint, username,
    and password required to connect to the managed resource.
    This field is planned to be replaced in a future release in favor of
    PublishConnectionDetailsTo. Currently, both could be set independently
    and connection details would be published to both without affecting
    each other.
    """


class AtProviderModel2(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AtProviderModel2"]:
            return AtProviderModel2

        def build(self) -> "AtProviderModel2":
            return AtProviderModel2(**self._attrs)

        def acl(self, value: Optional[str], /) -> Self:
            """
            Canned ACL applied on bucket creation: private or public-read (Defaults to private)
            Canned ACL applied on bucket creation
            """
            return self._set("acl", value)

        def bucket_domain_name(self, value: Optional[str], /) -> Self:
            """
            The FQDN of the bucket (e.g. bucket-name.nyc3.digitaloceanspaces.com)
            The FQDN of the bucket
            """
            return self._set("bucket_domain_name", value)

        @overload
        def cors_rule(
            self, value_or_callback: List[CorsRuleModel], /
        ) -> "AtProviderModel2.Builder": ...

        @overload
        def cors_rule(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[CorsRuleModel, CorsRuleModel.Builder]],
                GenericListBuilder[CorsRuleModel, CorsRuleModel.Builder] | List[CorsRuleModel],
            ],
            /,
        ) -> "AtProviderModel2.Builder": ...

        @overload
        def cors_rule(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[CorsRuleModel.Builder]: ...

        def cors_rule(self, value_or_callback=None, /):
            """
            A rule of Cross-Origin Resource Sharing (documented below).
            A container holding a list of elements describing allowed methods for a specific origin.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[CorsRuleModel.Builder]()
                context._parent_builder = self
                context._field_name = "cors_rule"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(CorsRuleModel.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("cors_rule", value)

        def endpoint(self, value: Optional[str], /) -> Self:
            """
            The FQDN of the bucket without the bucket name (e.g. nyc3.digitaloceanspaces.com)
            The FQDN of the bucket without the bucket name
            """
            return self._set("endpoint", value)

        def force_destroy(self, value: Optional[bool], /) -> Self:
            """
            Unless true, the bucket will only be destroyed if empty (Defaults to false)
            Unless true, the bucket will only be destroyed if empty
            """
            return self._set("force_destroy", value)

        def id(self, value: Optional[str], /) -> Self:
            """
            Unique identifier for the rule.
            """
            return self._set("id", value)

        @overload
        def lifecycle_rule(
            self, value_or_callback: List[LifecycleRule], /
        ) -> "AtProviderModel2.Builder": ...

        @overload
        def lifecycle_rule(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[LifecycleRule, LifecycleRule.Builder]],
                GenericListBuilder[LifecycleRule, LifecycleRule.Builder] | List[LifecycleRule],
            ],
            /,
        ) -> "AtProviderModel2.Builder": ...

        @overload
        def lifecycle_rule(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[LifecycleRule.Builder]: ...

        def lifecycle_rule(self, value_or_callback=None, /):
            """
            A configuration of object lifecycle management (documented below).
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[LifecycleRule.Builder]()
                context._parent_builder = self
                context._field_name = "lifecycle_rule"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(LifecycleRule.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("lifecycle_rule", value)

        def region(self, value: Optional[str], /) -> Self:
            """
            The region where the bucket resides (Defaults to nyc3)
            Bucket region
            """
            return self._set("region", value)

        def urn(self, value: Optional[str], /) -> Self:
            """
            The uniform resource name for the bucket
            the uniform resource name for the bucket
            """
            return self._set("urn", value)

        @overload
        def versioning(
            self, value_or_callback: List[Versioning], /
        ) -> "AtProviderModel2.Builder": ...

        @overload
        def versioning(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Versioning, Versioning.Builder]],
                GenericListBuilder[Versioning, Versioning.Builder] | List[Versioning],
            ],
            /,
        ) -> "AtProviderModel2.Builder": ...

        @overload
        def versioning(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Versioning.Builder]: ...

        def versioning(self, value_or_callback=None, /):
            """
            A state of versioning (documented below)
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Versioning.Builder]()
                context._parent_builder = self
                context._field_name = "versioning"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Versioning.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("versioning", value)

    class BuilderContext(BuilderContextBase["AtProviderModel2.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AtProviderModel2.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AtProviderModel2."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AtProviderModel2", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AtProviderModel2.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    acl: Optional[str] = None
    """
    Canned ACL applied on bucket creation: private or public-read (Defaults to private)
    Canned ACL applied on bucket creation
    """
    bucket_domain_name: Annotated[Optional[str], Field(alias="bucketDomainName")] = None
    """
    The FQDN of the bucket (e.g. bucket-name.nyc3.digitaloceanspaces.com)
    The FQDN of the bucket
    """
    cors_rule: Annotated[Optional[List[CorsRuleModel]], Field(alias="corsRule")] = None
    """
    A rule of Cross-Origin Resource Sharing (documented below).
    A container holding a list of elements describing allowed methods for a specific origin.
    """
    endpoint: Optional[str] = None
    """
    The FQDN of the bucket without the bucket name (e.g. nyc3.digitaloceanspaces.com)
    The FQDN of the bucket without the bucket name
    """
    force_destroy: Annotated[Optional[bool], Field(alias="forceDestroy")] = None
    """
    Unless true, the bucket will only be destroyed if empty (Defaults to false)
    Unless true, the bucket will only be destroyed if empty
    """
    id: Optional[str] = None
    """
    Unique identifier for the rule.
    """
    lifecycle_rule: Annotated[Optional[List[LifecycleRule]], Field(alias="lifecycleRule")] = None
    """
    A configuration of object lifecycle management (documented below).
    """
    region: Optional[str] = None
    """
    The region where the bucket resides (Defaults to nyc3)
    Bucket region
    """
    urn: Optional[str] = None
    """
    The uniform resource name for the bucket
    the uniform resource name for the bucket
    """
    versioning: Optional[List[Versioning]] = None
    """
    A state of versioning (documented below)
    """


class BucketStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["BucketStatus"]:
            return BucketStatus

        def build(self) -> "BucketStatus":
            return BucketStatus(**self._attrs)

        @overload
        def at_provider(
            self, value_or_callback: Optional[AtProviderModel2], /
        ) -> "BucketStatus.Builder": ...

        @overload
        def at_provider(
            self,
            value_or_callback: Callable[
                [AtProviderModel2.Builder], AtProviderModel2.Builder | AtProviderModel2
            ],
            /,
        ) -> "BucketStatus.Builder": ...

        @overload
        def at_provider(
            self, value_or_callback: Never = ...
        ) -> "AtProviderModel2.BuilderContext": ...

        def at_provider(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = AtProviderModel2.BuilderContext()
                context._parent_builder = self
                context._field_name = "at_provider"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AtProviderModel2.builder())
                if isinstance(output, AtProviderModel2.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("at_provider", value)

        @overload
        def conditions(self, value_or_callback: List[Condition], /) -> "BucketStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Condition, Condition.Builder]],
                GenericListBuilder[Condition, Condition.Builder] | List[Condition],
            ],
            /,
        ) -> "BucketStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            """
            Conditions of the resource.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        def observed_generation(self, value: Optional[int], /) -> Self:
            """
            ObservedGeneration is the latest metadata.generation
            which resulted in either a ready state, or stalled due to error
            it can not recover from without human intervention.
            """
            return self._set("observed_generation", value)

    class BuilderContext(BuilderContextBase["BucketStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = BucketStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for BucketStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["BucketStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use BucketStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    at_provider: Annotated[Optional[AtProviderModel2], Field(alias="atProvider")] = None
    conditions: Optional[List[Condition]] = None
    """
    Conditions of the resource.
    """
    observed_generation: Annotated[Optional[int], Field(alias="observedGeneration")] = None
    """
    ObservedGeneration is the latest metadata.generation
    which resulted in either a ready state, or stalled due to error
    it can not recover from without human intervention.
    """


class BucketDomainName(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["BucketDomainName"]:
            return BucketDomainName

        def build(self) -> "BucketDomainName":
            return BucketDomainName(**self._attrs)

        def match_controller_ref(self, value: Optional[bool], /) -> Self:
            """
            MatchControllerRef ensures an object with the same controller reference
            as the selecting object is selected.
            """
            return self._set("match_controller_ref", value)

        def match_labels(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            MatchLabels ensures an object with matching labels is selected.
            """
            return self._set("match_labels", value)

        @overload
        def policy(self, value_or_callback: Optional[Policy], /) -> "BucketDomainName.Builder": ...

        @overload
        def policy(
            self,
            value_or_callback: Callable[[Policy.Builder], Policy.Builder | Policy],
            /,
        ) -> "BucketDomainName.Builder": ...

        @overload
        def policy(self, value_or_callback: Never = ...) -> "Policy.BuilderContext": ...

        def policy(self, value_or_callback=None, /):
            """
            Policies for selection.
            """
            if self._in_context and value_or_callback is None:
                context = Policy.BuilderContext()
                context._parent_builder = self
                context._field_name = "policy"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Policy.builder())
                if isinstance(output, Policy.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("policy", value)

    class BuilderContext(BuilderContextBase["BucketDomainName.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = BucketDomainName.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for BucketDomainName."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["BucketDomainName", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use BucketDomainName.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    match_controller_ref: Annotated[Optional[bool], Field(alias="matchControllerRef")] = None
    """
    MatchControllerRef ensures an object with the same controller reference
    as the selecting object is selected.
    """
    match_labels: Annotated[Optional[Dict[str, str]], Field(alias="matchLabels")] = None
    """
    MatchLabels ensures an object with matching labels is selected.
    """
    policy: Optional[Policy] = None
    """
    Policies for selection.
    """


class CertificateNameRef(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["CertificateNameRef"]:
            return CertificateNameRef

        def build(self) -> "CertificateNameRef":
            return CertificateNameRef(**self._attrs)

        def name(self, value: str, /) -> Self:
            """
            Name of the referenced object.
            """
            return self._set("name", value)

        @overload
        def policy(
            self, value_or_callback: Optional[Policy], /
        ) -> "CertificateNameRef.Builder": ...

        @overload
        def policy(
            self,
            value_or_callback: Callable[[Policy.Builder], Policy.Builder | Policy],
            /,
        ) -> "CertificateNameRef.Builder": ...

        @overload
        def policy(self, value_or_callback: Never = ...) -> "Policy.BuilderContext": ...

        def policy(self, value_or_callback=None, /):
            """
            Policies for referencing.
            """
            if self._in_context and value_or_callback is None:
                context = Policy.BuilderContext()
                context._parent_builder = self
                context._field_name = "policy"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Policy.builder())
                if isinstance(output, Policy.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("policy", value)

    class BuilderContext(BuilderContextBase["CertificateNameRef.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = CertificateNameRef.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for CertificateNameRef."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["CertificateNameRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use CertificateNameRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: str
    """
    Name of the referenced object.
    """
    policy: Optional[Policy] = None
    """
    Policies for referencing.
    """


class CustomDomainRef(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["CustomDomainRef"]:
            return CustomDomainRef

        def build(self) -> "CustomDomainRef":
            return CustomDomainRef(**self._attrs)

        def name(self, value: str, /) -> Self:
            """
            Name of the referenced object.
            """
            return self._set("name", value)

        @overload
        def policy(self, value_or_callback: Optional[Policy], /) -> "CustomDomainRef.Builder": ...

        @overload
        def policy(
            self,
            value_or_callback: Callable[[Policy.Builder], Policy.Builder | Policy],
            /,
        ) -> "CustomDomainRef.Builder": ...

        @overload
        def policy(self, value_or_callback: Never = ...) -> "Policy.BuilderContext": ...

        def policy(self, value_or_callback=None, /):
            """
            Policies for referencing.
            """
            if self._in_context and value_or_callback is None:
                context = Policy.BuilderContext()
                context._parent_builder = self
                context._field_name = "policy"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Policy.builder())
                if isinstance(output, Policy.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("policy", value)

    class BuilderContext(BuilderContextBase["CustomDomainRef.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = CustomDomainRef.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for CustomDomainRef."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["CustomDomainRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use CustomDomainRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: str
    """
    Name of the referenced object.
    """
    policy: Optional[Policy] = None
    """
    Policies for referencing.
    """


class Id(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Id"]:
            return Id

        def build(self) -> "Id":
            return Id(**self._attrs)

        def match_controller_ref(self, value: Optional[bool], /) -> Self:
            """
            MatchControllerRef ensures an object with the same controller reference
            as the selecting object is selected.
            """
            return self._set("match_controller_ref", value)

        def match_labels(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            MatchLabels ensures an object with matching labels is selected.
            """
            return self._set("match_labels", value)

        @overload
        def policy(self, value_or_callback: Optional[Policy], /) -> "Id.Builder": ...

        @overload
        def policy(
            self,
            value_or_callback: Callable[[Policy.Builder], Policy.Builder | Policy],
            /,
        ) -> "Id.Builder": ...

        @overload
        def policy(self, value_or_callback: Never = ...) -> "Policy.BuilderContext": ...

        def policy(self, value_or_callback=None, /):
            """
            Policies for selection.
            """
            if self._in_context and value_or_callback is None:
                context = Policy.BuilderContext()
                context._parent_builder = self
                context._field_name = "policy"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Policy.builder())
                if isinstance(output, Policy.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("policy", value)

    class BuilderContext(BuilderContextBase["Id.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Id.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Id."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Id", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Id.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    match_controller_ref: Annotated[Optional[bool], Field(alias="matchControllerRef")] = None
    """
    MatchControllerRef ensures an object with the same controller reference
    as the selecting object is selected.
    """
    match_labels: Annotated[Optional[Dict[str, str]], Field(alias="matchLabels")] = None
    """
    MatchLabels ensures an object with matching labels is selected.
    """
    policy: Optional[Policy] = None
    """
    Policies for selection.
    """


class Name(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Name"]:
            return Name

        def build(self) -> "Name":
            return Name(**self._attrs)

        def match_controller_ref(self, value: Optional[bool], /) -> Self:
            """
            MatchControllerRef ensures an object with the same controller reference
            as the selecting object is selected.
            """
            return self._set("match_controller_ref", value)

        def match_labels(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            MatchLabels ensures an object with matching labels is selected.
            """
            return self._set("match_labels", value)

        @overload
        def policy(self, value_or_callback: Optional[Policy], /) -> "Name.Builder": ...

        @overload
        def policy(
            self,
            value_or_callback: Callable[[Policy.Builder], Policy.Builder | Policy],
            /,
        ) -> "Name.Builder": ...

        @overload
        def policy(self, value_or_callback: Never = ...) -> "Policy.BuilderContext": ...

        def policy(self, value_or_callback=None, /):
            """
            Policies for selection.
            """
            if self._in_context and value_or_callback is None:
                context = Policy.BuilderContext()
                context._parent_builder = self
                context._field_name = "policy"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Policy.builder())
                if isinstance(output, Policy.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("policy", value)

    class BuilderContext(BuilderContextBase["Name.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Name.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Name."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Name", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Name.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    match_controller_ref: Annotated[Optional[bool], Field(alias="matchControllerRef")] = None
    """
    MatchControllerRef ensures an object with the same controller reference
    as the selecting object is selected.
    """
    match_labels: Annotated[Optional[Dict[str, str]], Field(alias="matchLabels")] = None
    """
    MatchLabels ensures an object with matching labels is selected.
    """
    policy: Optional[Policy] = None
    """
    Policies for selection.
    """


class OriginRef(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["OriginRef"]:
            return OriginRef

        def build(self) -> "OriginRef":
            return OriginRef(**self._attrs)

        def name(self, value: str, /) -> Self:
            """
            Name of the referenced object.
            """
            return self._set("name", value)

        @overload
        def policy(self, value_or_callback: Optional[Policy], /) -> "OriginRef.Builder": ...

        @overload
        def policy(
            self,
            value_or_callback: Callable[[Policy.Builder], Policy.Builder | Policy],
            /,
        ) -> "OriginRef.Builder": ...

        @overload
        def policy(self, value_or_callback: Never = ...) -> "Policy.BuilderContext": ...

        def policy(self, value_or_callback=None, /):
            """
            Policies for referencing.
            """
            if self._in_context and value_or_callback is None:
                context = Policy.BuilderContext()
                context._parent_builder = self
                context._field_name = "policy"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Policy.builder())
                if isinstance(output, Policy.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("policy", value)

    class BuilderContext(BuilderContextBase["OriginRef.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = OriginRef.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for OriginRef."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["OriginRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use OriginRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: str
    """
    Name of the referenced object.
    """
    policy: Optional[Policy] = None
    """
    Policies for referencing.
    """


class ForProviderModel3(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ForProviderModel3"]:
            return ForProviderModel3

        def build(self) -> "ForProviderModel3":
            return ForProviderModel3(**self._attrs)

        @overload
        def bucket_domain_name(
            self, value_or_callback: Optional[BucketDomainName], /
        ) -> "ForProviderModel3.Builder": ...

        @overload
        def bucket_domain_name(
            self,
            value_or_callback: Callable[
                [BucketDomainName.Builder], BucketDomainName.Builder | BucketDomainName
            ],
            /,
        ) -> "ForProviderModel3.Builder": ...

        @overload
        def bucket_domain_name(
            self, value_or_callback: Never = ...
        ) -> "BucketDomainName.BuilderContext": ...

        def bucket_domain_name(self, value_or_callback=None, /):
            """
            Selector for a Bucket in spaces to populate origin.
            """
            if self._in_context and value_or_callback is None:
                context = BucketDomainName.BuilderContext()
                context._parent_builder = self
                context._field_name = "bucket_domain_name"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(BucketDomainName.builder())
                if isinstance(output, BucketDomainName.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("bucket_domain_name", value)

        def certificate_id(self, value: Optional[str], /) -> Self:
            """
            Deprecated The ID of a DigitalOcean managed TLS certificate used for SSL when a custom subdomain is provided.
            ID of a DigitalOcean managed TLS certificate for use with custom domains
            """
            return self._set("certificate_id", value)

        def certificate_name(self, value: Optional[str], /) -> Self:
            """
            The unique name of a DigitalOcean managed TLS certificate used for SSL when a custom subdomain is provided.
            """
            return self._set("certificate_name", value)

        @overload
        def certificate_name_ref(
            self, value_or_callback: Optional[CertificateNameRef], /
        ) -> "ForProviderModel3.Builder": ...

        @overload
        def certificate_name_ref(
            self,
            value_or_callback: Callable[
                [CertificateNameRef.Builder],
                CertificateNameRef.Builder | CertificateNameRef,
            ],
            /,
        ) -> "ForProviderModel3.Builder": ...

        @overload
        def certificate_name_ref(
            self, value_or_callback: Never = ...
        ) -> "CertificateNameRef.BuilderContext": ...

        def certificate_name_ref(self, value_or_callback=None, /):
            """
            Reference to a Certificate in networking to populate certificateName.
            """
            if self._in_context and value_or_callback is None:
                context = CertificateNameRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "certificate_name_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(CertificateNameRef.builder())
                if isinstance(output, CertificateNameRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("certificate_name_ref", value)

        def custom_domain(self, value: Optional[str], /) -> Self:
            """
            The fully qualified domain name (FQDN) of the custom subdomain used with the CDN Endpoint.
            fully qualified domain name (FQDN) for custom subdomain, (requires certificate_id)
            """
            return self._set("custom_domain", value)

        @overload
        def custom_domain_ref(
            self, value_or_callback: Optional[CustomDomainRef], /
        ) -> "ForProviderModel3.Builder": ...

        @overload
        def custom_domain_ref(
            self,
            value_or_callback: Callable[
                [CustomDomainRef.Builder], CustomDomainRef.Builder | CustomDomainRef
            ],
            /,
        ) -> "ForProviderModel3.Builder": ...

        @overload
        def custom_domain_ref(
            self, value_or_callback: Never = ...
        ) -> "CustomDomainRef.BuilderContext": ...

        def custom_domain_ref(self, value_or_callback=None, /):
            """
            Reference to a Domain in dns to populate customDomain.
            """
            if self._in_context and value_or_callback is None:
                context = CustomDomainRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "custom_domain_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(CustomDomainRef.builder())
                if isinstance(output, CustomDomainRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("custom_domain_ref", value)

        @overload
        def id(self, value_or_callback: Optional[Id], /) -> "ForProviderModel3.Builder": ...

        @overload
        def id(
            self, value_or_callback: Callable[[Id.Builder], Id.Builder | Id], /
        ) -> "ForProviderModel3.Builder": ...

        @overload
        def id(self, value_or_callback: Never = ...) -> "Id.BuilderContext": ...

        def id(self, value_or_callback=None, /):
            """
            A unique ID that can be used to identify and reference a CDN Endpoint.
            """
            if self._in_context and value_or_callback is None:
                context = Id.BuilderContext()
                context._parent_builder = self
                context._field_name = "id"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Id.builder())
                if isinstance(output, Id.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("id", value)

        @overload
        def name(self, value_or_callback: Optional[Name], /) -> "ForProviderModel3.Builder": ...

        @overload
        def name(
            self, value_or_callback: Callable[[Name.Builder], Name.Builder | Name], /
        ) -> "ForProviderModel3.Builder": ...

        @overload
        def name(self, value_or_callback: Never = ...) -> "Name.BuilderContext": ...

        def name(self, value_or_callback=None, /):
            """
            Selector for a Certificate in networking to populate certificateName.
            """
            if self._in_context and value_or_callback is None:
                context = Name.BuilderContext()
                context._parent_builder = self
                context._field_name = "name"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Name.builder())
                if isinstance(output, Name.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("name", value)

        def origin(self, value: Optional[str], /) -> Self:
            """
            The fully qualified domain name, (FQDN) for a Space.
            fully qualified domain name (FQDN) for the origin server
            """
            return self._set("origin", value)

        @overload
        def origin_ref(
            self, value_or_callback: Optional[OriginRef], /
        ) -> "ForProviderModel3.Builder": ...

        @overload
        def origin_ref(
            self,
            value_or_callback: Callable[[OriginRef.Builder], OriginRef.Builder | OriginRef],
            /,
        ) -> "ForProviderModel3.Builder": ...

        @overload
        def origin_ref(self, value_or_callback: Never = ...) -> "OriginRef.BuilderContext": ...

        def origin_ref(self, value_or_callback=None, /):
            """
            Reference to a Bucket in spaces to populate origin.
            """
            if self._in_context and value_or_callback is None:
                context = OriginRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "origin_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(OriginRef.builder())
                if isinstance(output, OriginRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("origin_ref", value)

        def ttl(self, value: Optional[float], /) -> Self:
            """
            The time to live for the CDN Endpoint, in seconds. Default is 3600 seconds.
            The amount of time the content is cached in the CDN
            """
            return self._set("ttl", value)

    class BuilderContext(BuilderContextBase["ForProviderModel3.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ForProviderModel3.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ForProviderModel3."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ForProviderModel3", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ForProviderModel3.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    bucket_domain_name: Annotated[Optional[BucketDomainName], Field(alias="bucketDomainName")] = (
        None
    )
    """
    Selector for a Bucket in spaces to populate origin.
    """
    certificate_id: Annotated[Optional[str], Field(alias="certificateId")] = None
    """
    Deprecated The ID of a DigitalOcean managed TLS certificate used for SSL when a custom subdomain is provided.
    ID of a DigitalOcean managed TLS certificate for use with custom domains
    """
    certificate_name: Annotated[Optional[str], Field(alias="certificateName")] = None
    """
    The unique name of a DigitalOcean managed TLS certificate used for SSL when a custom subdomain is provided.
    """
    certificate_name_ref: Annotated[
        Optional[CertificateNameRef], Field(alias="certificateNameRef")
    ] = None
    """
    Reference to a Certificate in networking to populate certificateName.
    """
    custom_domain: Annotated[Optional[str], Field(alias="customDomain")] = None
    """
    The fully qualified domain name (FQDN) of the custom subdomain used with the CDN Endpoint.
    fully qualified domain name (FQDN) for custom subdomain, (requires certificate_id)
    """
    custom_domain_ref: Annotated[Optional[CustomDomainRef], Field(alias="customDomainRef")] = None
    """
    Reference to a Domain in dns to populate customDomain.
    """
    id: Optional[Id] = None
    """
    A unique ID that can be used to identify and reference a CDN Endpoint.
    """
    name: Optional[Name] = None
    """
    Selector for a Certificate in networking to populate certificateName.
    """
    origin: Optional[str] = None
    """
    The fully qualified domain name, (FQDN) for a Space.
    fully qualified domain name (FQDN) for the origin server
    """
    origin_ref: Annotated[Optional[OriginRef], Field(alias="originRef")] = None
    """
    Reference to a Bucket in spaces to populate origin.
    """
    ttl: Optional[float] = None
    """
    The time to live for the CDN Endpoint, in seconds. Default is 3600 seconds.
    The amount of time the content is cached in the CDN
    """


class InitProviderModel3(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["InitProviderModel3"]:
            return InitProviderModel3

        def build(self) -> "InitProviderModel3":
            return InitProviderModel3(**self._attrs)

        @overload
        def bucket_domain_name(
            self, value_or_callback: Optional[BucketDomainName], /
        ) -> "InitProviderModel3.Builder": ...

        @overload
        def bucket_domain_name(
            self,
            value_or_callback: Callable[
                [BucketDomainName.Builder], BucketDomainName.Builder | BucketDomainName
            ],
            /,
        ) -> "InitProviderModel3.Builder": ...

        @overload
        def bucket_domain_name(
            self, value_or_callback: Never = ...
        ) -> "BucketDomainName.BuilderContext": ...

        def bucket_domain_name(self, value_or_callback=None, /):
            """
            Selector for a Bucket in spaces to populate origin.
            """
            if self._in_context and value_or_callback is None:
                context = BucketDomainName.BuilderContext()
                context._parent_builder = self
                context._field_name = "bucket_domain_name"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(BucketDomainName.builder())
                if isinstance(output, BucketDomainName.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("bucket_domain_name", value)

        def certificate_id(self, value: Optional[str], /) -> Self:
            """
            Deprecated The ID of a DigitalOcean managed TLS certificate used for SSL when a custom subdomain is provided.
            ID of a DigitalOcean managed TLS certificate for use with custom domains
            """
            return self._set("certificate_id", value)

        def certificate_name(self, value: Optional[str], /) -> Self:
            """
            The unique name of a DigitalOcean managed TLS certificate used for SSL when a custom subdomain is provided.
            """
            return self._set("certificate_name", value)

        @overload
        def certificate_name_ref(
            self, value_or_callback: Optional[CertificateNameRef], /
        ) -> "InitProviderModel3.Builder": ...

        @overload
        def certificate_name_ref(
            self,
            value_or_callback: Callable[
                [CertificateNameRef.Builder],
                CertificateNameRef.Builder | CertificateNameRef,
            ],
            /,
        ) -> "InitProviderModel3.Builder": ...

        @overload
        def certificate_name_ref(
            self, value_or_callback: Never = ...
        ) -> "CertificateNameRef.BuilderContext": ...

        def certificate_name_ref(self, value_or_callback=None, /):
            """
            Reference to a Certificate in networking to populate certificateName.
            """
            if self._in_context and value_or_callback is None:
                context = CertificateNameRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "certificate_name_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(CertificateNameRef.builder())
                if isinstance(output, CertificateNameRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("certificate_name_ref", value)

        def custom_domain(self, value: Optional[str], /) -> Self:
            """
            The fully qualified domain name (FQDN) of the custom subdomain used with the CDN Endpoint.
            fully qualified domain name (FQDN) for custom subdomain, (requires certificate_id)
            """
            return self._set("custom_domain", value)

        @overload
        def custom_domain_ref(
            self, value_or_callback: Optional[CustomDomainRef], /
        ) -> "InitProviderModel3.Builder": ...

        @overload
        def custom_domain_ref(
            self,
            value_or_callback: Callable[
                [CustomDomainRef.Builder], CustomDomainRef.Builder | CustomDomainRef
            ],
            /,
        ) -> "InitProviderModel3.Builder": ...

        @overload
        def custom_domain_ref(
            self, value_or_callback: Never = ...
        ) -> "CustomDomainRef.BuilderContext": ...

        def custom_domain_ref(self, value_or_callback=None, /):
            """
            Reference to a Domain in dns to populate customDomain.
            """
            if self._in_context and value_or_callback is None:
                context = CustomDomainRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "custom_domain_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(CustomDomainRef.builder())
                if isinstance(output, CustomDomainRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("custom_domain_ref", value)

        @overload
        def id(self, value_or_callback: Optional[Id], /) -> "InitProviderModel3.Builder": ...

        @overload
        def id(
            self, value_or_callback: Callable[[Id.Builder], Id.Builder | Id], /
        ) -> "InitProviderModel3.Builder": ...

        @overload
        def id(self, value_or_callback: Never = ...) -> "Id.BuilderContext": ...

        def id(self, value_or_callback=None, /):
            """
            A unique ID that can be used to identify and reference a CDN Endpoint.
            """
            if self._in_context and value_or_callback is None:
                context = Id.BuilderContext()
                context._parent_builder = self
                context._field_name = "id"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Id.builder())
                if isinstance(output, Id.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("id", value)

        @overload
        def name(self, value_or_callback: Optional[Name], /) -> "InitProviderModel3.Builder": ...

        @overload
        def name(
            self, value_or_callback: Callable[[Name.Builder], Name.Builder | Name], /
        ) -> "InitProviderModel3.Builder": ...

        @overload
        def name(self, value_or_callback: Never = ...) -> "Name.BuilderContext": ...

        def name(self, value_or_callback=None, /):
            """
            Selector for a Certificate in networking to populate certificateName.
            """
            if self._in_context and value_or_callback is None:
                context = Name.BuilderContext()
                context._parent_builder = self
                context._field_name = "name"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Name.builder())
                if isinstance(output, Name.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("name", value)

        def origin(self, value: Optional[str], /) -> Self:
            """
            The fully qualified domain name, (FQDN) for a Space.
            fully qualified domain name (FQDN) for the origin server
            """
            return self._set("origin", value)

        @overload
        def origin_ref(
            self, value_or_callback: Optional[OriginRef], /
        ) -> "InitProviderModel3.Builder": ...

        @overload
        def origin_ref(
            self,
            value_or_callback: Callable[[OriginRef.Builder], OriginRef.Builder | OriginRef],
            /,
        ) -> "InitProviderModel3.Builder": ...

        @overload
        def origin_ref(self, value_or_callback: Never = ...) -> "OriginRef.BuilderContext": ...

        def origin_ref(self, value_or_callback=None, /):
            """
            Reference to a Bucket in spaces to populate origin.
            """
            if self._in_context and value_or_callback is None:
                context = OriginRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "origin_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(OriginRef.builder())
                if isinstance(output, OriginRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("origin_ref", value)

        def ttl(self, value: Optional[float], /) -> Self:
            """
            The time to live for the CDN Endpoint, in seconds. Default is 3600 seconds.
            The amount of time the content is cached in the CDN
            """
            return self._set("ttl", value)

    class BuilderContext(BuilderContextBase["InitProviderModel3.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = InitProviderModel3.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for InitProviderModel3."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["InitProviderModel3", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use InitProviderModel3.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    bucket_domain_name: Annotated[Optional[BucketDomainName], Field(alias="bucketDomainName")] = (
        None
    )
    """
    Selector for a Bucket in spaces to populate origin.
    """
    certificate_id: Annotated[Optional[str], Field(alias="certificateId")] = None
    """
    Deprecated The ID of a DigitalOcean managed TLS certificate used for SSL when a custom subdomain is provided.
    ID of a DigitalOcean managed TLS certificate for use with custom domains
    """
    certificate_name: Annotated[Optional[str], Field(alias="certificateName")] = None
    """
    The unique name of a DigitalOcean managed TLS certificate used for SSL when a custom subdomain is provided.
    """
    certificate_name_ref: Annotated[
        Optional[CertificateNameRef], Field(alias="certificateNameRef")
    ] = None
    """
    Reference to a Certificate in networking to populate certificateName.
    """
    custom_domain: Annotated[Optional[str], Field(alias="customDomain")] = None
    """
    The fully qualified domain name (FQDN) of the custom subdomain used with the CDN Endpoint.
    fully qualified domain name (FQDN) for custom subdomain, (requires certificate_id)
    """
    custom_domain_ref: Annotated[Optional[CustomDomainRef], Field(alias="customDomainRef")] = None
    """
    Reference to a Domain in dns to populate customDomain.
    """
    id: Optional[Id] = None
    """
    A unique ID that can be used to identify and reference a CDN Endpoint.
    """
    name: Optional[Name] = None
    """
    Selector for a Certificate in networking to populate certificateName.
    """
    origin: Optional[str] = None
    """
    The fully qualified domain name, (FQDN) for a Space.
    fully qualified domain name (FQDN) for the origin server
    """
    origin_ref: Annotated[Optional[OriginRef], Field(alias="originRef")] = None
    """
    Reference to a Bucket in spaces to populate origin.
    """
    ttl: Optional[float] = None
    """
    The time to live for the CDN Endpoint, in seconds. Default is 3600 seconds.
    The amount of time the content is cached in the CDN
    """


class CdnSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["CdnSpec"]:
            return CdnSpec

        def build(self) -> "CdnSpec":
            return CdnSpec(**self._attrs)

        def deletion_policy(self, value: Optional[Literal["Orphan", "Delete"]], /) -> Self:
            """
            DeletionPolicy specifies what will happen to the underlying external
            when this managed resource is deleted - either "Delete" or "Orphan" the
            external resource.
            This field is planned to be deprecated in favor of the ManagementPolicies
            field in a future release. Currently, both could be set independently and
            non-default values would be honored if the feature flag is enabled.
            See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
            """
            return self._set("deletion_policy", value)

        @overload
        def for_provider(self, value_or_callback: ForProviderModel3, /) -> "CdnSpec.Builder": ...

        @overload
        def for_provider(
            self,
            value_or_callback: Callable[
                [ForProviderModel3.Builder],
                ForProviderModel3.Builder | ForProviderModel3,
            ],
            /,
        ) -> "CdnSpec.Builder": ...

        @overload
        def for_provider(
            self, value_or_callback: Never = ...
        ) -> "ForProviderModel3.BuilderContext": ...

        def for_provider(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ForProviderModel3.BuilderContext()
                context._parent_builder = self
                context._field_name = "for_provider"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ForProviderModel3.builder())
                if isinstance(output, ForProviderModel3.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("for_provider", value)

        @overload
        def init_provider(
            self, value_or_callback: Optional[InitProviderModel3], /
        ) -> "CdnSpec.Builder": ...

        @overload
        def init_provider(
            self,
            value_or_callback: Callable[
                [InitProviderModel3.Builder],
                InitProviderModel3.Builder | InitProviderModel3,
            ],
            /,
        ) -> "CdnSpec.Builder": ...

        @overload
        def init_provider(
            self, value_or_callback: Never = ...
        ) -> "InitProviderModel3.BuilderContext": ...

        def init_provider(self, value_or_callback=None, /):
            """
            THIS IS A BETA FIELD. It will be honored
            unless the Management Policies feature flag is disabled.
            InitProvider holds the same fields as ForProvider, with the exception
            of Identifier and other resource reference fields. The fields that are
            in InitProvider are merged into ForProvider when the resource is created.
            The same fields are also added to the terraform ignore_changes hook, to
            avoid updating them after creation. This is useful for fields that are
            required on creation, but we do not desire to update them after creation,
            for example because of an external controller is managing them, like an
            autoscaler.
            """
            if self._in_context and value_or_callback is None:
                context = InitProviderModel3.BuilderContext()
                context._parent_builder = self
                context._field_name = "init_provider"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(InitProviderModel3.builder())
                if isinstance(output, InitProviderModel3.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("init_provider", value)

        def management_policies(
            self,
            value: Optional[
                List[Literal["Observe", "Create", "Update", "Delete", "LateInitialize", "*"]]
            ],
            /,
        ) -> Self:
            """
            THIS IS A BETA FIELD. It is on by default but can be opted out
            through a Crossplane feature flag.
            ManagementPolicies specify the array of actions Crossplane is allowed to
            take on the managed and external resources.
            This field is planned to replace the DeletionPolicy field in a future
            release. Currently, both could be set independently and non-default
            values would be honored if the feature flag is enabled. If both are
            custom, the DeletionPolicy field will be ignored.
            See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
            and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
            """
            return self._set("management_policies", value)

        @overload
        def provider_config_ref(
            self, value_or_callback: Optional[ProviderConfigRef], /
        ) -> "CdnSpec.Builder": ...

        @overload
        def provider_config_ref(
            self,
            value_or_callback: Callable[
                [ProviderConfigRef.Builder],
                ProviderConfigRef.Builder | ProviderConfigRef,
            ],
            /,
        ) -> "CdnSpec.Builder": ...

        @overload
        def provider_config_ref(
            self, value_or_callback: Never = ...
        ) -> "ProviderConfigRef.BuilderContext": ...

        def provider_config_ref(self, value_or_callback=None, /):
            """
            ProviderConfigReference specifies how the provider that will be used to
            create, observe, update, and delete this managed resource should be
            configured.
            """
            if self._in_context and value_or_callback is None:
                context = ProviderConfigRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "provider_config_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ProviderConfigRef.builder())
                if isinstance(output, ProviderConfigRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("provider_config_ref", value)

        @overload
        def publish_connection_details_to(
            self, value_or_callback: Optional[PublishConnectionDetailsTo], /
        ) -> "CdnSpec.Builder": ...

        @overload
        def publish_connection_details_to(
            self,
            value_or_callback: Callable[
                [PublishConnectionDetailsTo.Builder],
                PublishConnectionDetailsTo.Builder | PublishConnectionDetailsTo,
            ],
            /,
        ) -> "CdnSpec.Builder": ...

        @overload
        def publish_connection_details_to(
            self, value_or_callback: Never = ...
        ) -> "PublishConnectionDetailsTo.BuilderContext": ...

        def publish_connection_details_to(self, value_or_callback=None, /):
            """
            PublishConnectionDetailsTo specifies the connection secret config which
            contains a name, metadata and a reference to secret store config to
            which any connection details for this managed resource should be written.
            Connection details frequently include the endpoint, username,
            and password required to connect to the managed resource.
            """
            if self._in_context and value_or_callback is None:
                context = PublishConnectionDetailsTo.BuilderContext()
                context._parent_builder = self
                context._field_name = "publish_connection_details_to"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PublishConnectionDetailsTo.builder())
                if isinstance(output, PublishConnectionDetailsTo.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("publish_connection_details_to", value)

        @overload
        def write_connection_secret_to_ref(
            self, value_or_callback: Optional[WriteConnectionSecretToRef], /
        ) -> "CdnSpec.Builder": ...

        @overload
        def write_connection_secret_to_ref(
            self,
            value_or_callback: Callable[
                [WriteConnectionSecretToRef.Builder],
                WriteConnectionSecretToRef.Builder | WriteConnectionSecretToRef,
            ],
            /,
        ) -> "CdnSpec.Builder": ...

        @overload
        def write_connection_secret_to_ref(
            self, value_or_callback: Never = ...
        ) -> "WriteConnectionSecretToRef.BuilderContext": ...

        def write_connection_secret_to_ref(self, value_or_callback=None, /):
            """
            WriteConnectionSecretToReference specifies the namespace and name of a
            Secret to which any connection details for this managed resource should
            be written. Connection details frequently include the endpoint, username,
            and password required to connect to the managed resource.
            This field is planned to be replaced in a future release in favor of
            PublishConnectionDetailsTo. Currently, both could be set independently
            and connection details would be published to both without affecting
            each other.
            """
            if self._in_context and value_or_callback is None:
                context = WriteConnectionSecretToRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "write_connection_secret_to_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(WriteConnectionSecretToRef.builder())
                if isinstance(output, WriteConnectionSecretToRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("write_connection_secret_to_ref", value)

    class BuilderContext(BuilderContextBase["CdnSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = CdnSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for CdnSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["CdnSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use CdnSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    deletion_policy: Annotated[
        Optional[Literal["Orphan", "Delete"]], Field(alias="deletionPolicy")
    ] = "Delete"
    """
    DeletionPolicy specifies what will happen to the underlying external
    when this managed resource is deleted - either "Delete" or "Orphan" the
    external resource.
    This field is planned to be deprecated in favor of the ManagementPolicies
    field in a future release. Currently, both could be set independently and
    non-default values would be honored if the feature flag is enabled.
    See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    """
    for_provider: Annotated[ForProviderModel3, Field(alias="forProvider")]
    init_provider: Annotated[Optional[InitProviderModel3], Field(alias="initProvider")] = None
    """
    THIS IS A BETA FIELD. It will be honored
    unless the Management Policies feature flag is disabled.
    InitProvider holds the same fields as ForProvider, with the exception
    of Identifier and other resource reference fields. The fields that are
    in InitProvider are merged into ForProvider when the resource is created.
    The same fields are also added to the terraform ignore_changes hook, to
    avoid updating them after creation. This is useful for fields that are
    required on creation, but we do not desire to update them after creation,
    for example because of an external controller is managing them, like an
    autoscaler.
    """
    management_policies: Annotated[
        Optional[List[Literal["Observe", "Create", "Update", "Delete", "LateInitialize", "*"]]],
        Field(alias="managementPolicies"),
    ] = ["*"]
    """
    THIS IS A BETA FIELD. It is on by default but can be opted out
    through a Crossplane feature flag.
    ManagementPolicies specify the array of actions Crossplane is allowed to
    take on the managed and external resources.
    This field is planned to replace the DeletionPolicy field in a future
    release. Currently, both could be set independently and non-default
    values would be honored if the feature flag is enabled. If both are
    custom, the DeletionPolicy field will be ignored.
    See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
    """
    provider_config_ref: Annotated[
        Optional[ProviderConfigRef],
        Field(
            default_factory=lambda: ProviderConfigRef.model_validate({"name": "default"}),
            alias="providerConfigRef",
        ),
    ] = {"name": "default"}
    """
    ProviderConfigReference specifies how the provider that will be used to
    create, observe, update, and delete this managed resource should be
    configured.
    """
    publish_connection_details_to: Annotated[
        Optional[PublishConnectionDetailsTo], Field(alias="publishConnectionDetailsTo")
    ] = None
    """
    PublishConnectionDetailsTo specifies the connection secret config which
    contains a name, metadata and a reference to secret store config to
    which any connection details for this managed resource should be written.
    Connection details frequently include the endpoint, username,
    and password required to connect to the managed resource.
    """
    write_connection_secret_to_ref: Annotated[
        Optional[WriteConnectionSecretToRef], Field(alias="writeConnectionSecretToRef")
    ] = None
    """
    WriteConnectionSecretToReference specifies the namespace and name of a
    Secret to which any connection details for this managed resource should
    be written. Connection details frequently include the endpoint, username,
    and password required to connect to the managed resource.
    This field is planned to be replaced in a future release in favor of
    PublishConnectionDetailsTo. Currently, both could be set independently
    and connection details would be published to both without affecting
    each other.
    """


class AtProviderModel3(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AtProviderModel3"]:
            return AtProviderModel3

        def build(self) -> "AtProviderModel3":
            return AtProviderModel3(**self._attrs)

        def certificate_id(self, value: Optional[str], /) -> Self:
            """
            Deprecated The ID of a DigitalOcean managed TLS certificate used for SSL when a custom subdomain is provided.
            ID of a DigitalOcean managed TLS certificate for use with custom domains
            """
            return self._set("certificate_id", value)

        def certificate_name(self, value: Optional[str], /) -> Self:
            """
            The unique name of a DigitalOcean managed TLS certificate used for SSL when a custom subdomain is provided.
            """
            return self._set("certificate_name", value)

        def created_at(self, value: Optional[str], /) -> Self:
            """
            The date and time when the CDN Endpoint was created.
            The date and time (ISO8601) of when the CDN endpoint was created.
            """
            return self._set("created_at", value)

        def custom_domain(self, value: Optional[str], /) -> Self:
            """
            The fully qualified domain name (FQDN) of the custom subdomain used with the CDN Endpoint.
            fully qualified domain name (FQDN) for custom subdomain, (requires certificate_id)
            """
            return self._set("custom_domain", value)

        def endpoint(self, value: Optional[str], /) -> Self:
            """
            The fully qualified domain name (FQDN) from which the CDN-backed content is served.
            fully qualified domain name (FQDN) to serve the CDN content
            """
            return self._set("endpoint", value)

        def id(self, value: Optional[str], /) -> Self:
            """
            A unique ID that can be used to identify and reference a CDN Endpoint.
            """
            return self._set("id", value)

        def origin(self, value: Optional[str], /) -> Self:
            """
            The fully qualified domain name, (FQDN) for a Space.
            fully qualified domain name (FQDN) for the origin server
            """
            return self._set("origin", value)

        def ttl(self, value: Optional[float], /) -> Self:
            """
            The time to live for the CDN Endpoint, in seconds. Default is 3600 seconds.
            The amount of time the content is cached in the CDN
            """
            return self._set("ttl", value)

    class BuilderContext(BuilderContextBase["AtProviderModel3.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AtProviderModel3.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AtProviderModel3."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AtProviderModel3", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AtProviderModel3.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    certificate_id: Annotated[Optional[str], Field(alias="certificateId")] = None
    """
    Deprecated The ID of a DigitalOcean managed TLS certificate used for SSL when a custom subdomain is provided.
    ID of a DigitalOcean managed TLS certificate for use with custom domains
    """
    certificate_name: Annotated[Optional[str], Field(alias="certificateName")] = None
    """
    The unique name of a DigitalOcean managed TLS certificate used for SSL when a custom subdomain is provided.
    """
    created_at: Annotated[Optional[str], Field(alias="createdAt")] = None
    """
    The date and time when the CDN Endpoint was created.
    The date and time (ISO8601) of when the CDN endpoint was created.
    """
    custom_domain: Annotated[Optional[str], Field(alias="customDomain")] = None
    """
    The fully qualified domain name (FQDN) of the custom subdomain used with the CDN Endpoint.
    fully qualified domain name (FQDN) for custom subdomain, (requires certificate_id)
    """
    endpoint: Optional[str] = None
    """
    The fully qualified domain name (FQDN) from which the CDN-backed content is served.
    fully qualified domain name (FQDN) to serve the CDN content
    """
    id: Optional[str] = None
    """
    A unique ID that can be used to identify and reference a CDN Endpoint.
    """
    origin: Optional[str] = None
    """
    The fully qualified domain name, (FQDN) for a Space.
    fully qualified domain name (FQDN) for the origin server
    """
    ttl: Optional[float] = None
    """
    The time to live for the CDN Endpoint, in seconds. Default is 3600 seconds.
    The amount of time the content is cached in the CDN
    """


class CdnStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["CdnStatus"]:
            return CdnStatus

        def build(self) -> "CdnStatus":
            return CdnStatus(**self._attrs)

        @overload
        def at_provider(
            self, value_or_callback: Optional[AtProviderModel3], /
        ) -> "CdnStatus.Builder": ...

        @overload
        def at_provider(
            self,
            value_or_callback: Callable[
                [AtProviderModel3.Builder], AtProviderModel3.Builder | AtProviderModel3
            ],
            /,
        ) -> "CdnStatus.Builder": ...

        @overload
        def at_provider(
            self, value_or_callback: Never = ...
        ) -> "AtProviderModel3.BuilderContext": ...

        def at_provider(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = AtProviderModel3.BuilderContext()
                context._parent_builder = self
                context._field_name = "at_provider"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AtProviderModel3.builder())
                if isinstance(output, AtProviderModel3.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("at_provider", value)

        @overload
        def conditions(self, value_or_callback: List[Condition], /) -> "CdnStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Condition, Condition.Builder]],
                GenericListBuilder[Condition, Condition.Builder] | List[Condition],
            ],
            /,
        ) -> "CdnStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            """
            Conditions of the resource.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        def observed_generation(self, value: Optional[int], /) -> Self:
            """
            ObservedGeneration is the latest metadata.generation
            which resulted in either a ready state, or stalled due to error
            it can not recover from without human intervention.
            """
            return self._set("observed_generation", value)

    class BuilderContext(BuilderContextBase["CdnStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = CdnStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for CdnStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["CdnStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use CdnStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    at_provider: Annotated[Optional[AtProviderModel3], Field(alias="atProvider")] = None
    conditions: Optional[List[Condition]] = None
    """
    Conditions of the resource.
    """
    observed_generation: Annotated[Optional[int], Field(alias="observedGeneration")] = None
    """
    ObservedGeneration is the latest metadata.generation
    which resulted in either a ready state, or stalled due to error
    it can not recover from without human intervention.
    """


class BucketCorsConfiguration(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["BucketCorsConfiguration"]:
            return BucketCorsConfiguration

        def build(self) -> "BucketCorsConfiguration":
            return BucketCorsConfiguration(**self._attrs)

        def api_version(
            self,
            value: Optional[Literal["spaces.digitalocean.crossplane.io/v1alpha1"]],
            /,
        ) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["BucketCorsConfiguration"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "BucketCorsConfiguration.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "BucketCorsConfiguration.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(
            self, value_or_callback: BucketCorsConfigurationSpec, /
        ) -> "BucketCorsConfiguration.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [BucketCorsConfigurationSpec.Builder],
                BucketCorsConfigurationSpec.Builder | BucketCorsConfigurationSpec,
            ],
            /,
        ) -> "BucketCorsConfiguration.Builder": ...

        @overload
        def spec(
            self, value_or_callback: Never = ...
        ) -> "BucketCorsConfigurationSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = BucketCorsConfigurationSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(BucketCorsConfigurationSpec.builder())
                if isinstance(output, BucketCorsConfigurationSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(
            self, value_or_callback: Optional[BucketCorsConfigurationStatus], /
        ) -> "BucketCorsConfiguration.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [BucketCorsConfigurationStatus.Builder],
                BucketCorsConfigurationStatus.Builder | BucketCorsConfigurationStatus,
            ],
            /,
        ) -> "BucketCorsConfiguration.Builder": ...

        @overload
        def status(
            self, value_or_callback: Never = ...
        ) -> "BucketCorsConfigurationStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = BucketCorsConfigurationStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(BucketCorsConfigurationStatus.builder())
                if isinstance(output, BucketCorsConfigurationStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["BucketCorsConfiguration.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = BucketCorsConfiguration.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for BucketCorsConfiguration."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["BucketCorsConfiguration", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use BucketCorsConfiguration.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[
        Optional[Literal["spaces.digitalocean.crossplane.io/v1alpha1"]],
        Field(alias="apiVersion"),
    ] = "spaces.digitalocean.crossplane.io/v1alpha1"
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["BucketCorsConfiguration"]] = "BucketCorsConfiguration"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: BucketCorsConfigurationSpec
    status: Optional[BucketCorsConfigurationStatus] = None


class BucketObject(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["BucketObject"]:
            return BucketObject

        def build(self) -> "BucketObject":
            return BucketObject(**self._attrs)

        def api_version(
            self,
            value: Optional[Literal["spaces.digitalocean.crossplane.io/v1alpha1"]],
            /,
        ) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["BucketObject"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "BucketObject.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "BucketObject.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(self, value_or_callback: BucketObjectSpec, /) -> "BucketObject.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [BucketObjectSpec.Builder], BucketObjectSpec.Builder | BucketObjectSpec
            ],
            /,
        ) -> "BucketObject.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "BucketObjectSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = BucketObjectSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(BucketObjectSpec.builder())
                if isinstance(output, BucketObjectSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(
            self, value_or_callback: Optional[BucketObjectStatus], /
        ) -> "BucketObject.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [BucketObjectStatus.Builder],
                BucketObjectStatus.Builder | BucketObjectStatus,
            ],
            /,
        ) -> "BucketObject.Builder": ...

        @overload
        def status(self, value_or_callback: Never = ...) -> "BucketObjectStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = BucketObjectStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(BucketObjectStatus.builder())
                if isinstance(output, BucketObjectStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["BucketObject.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = BucketObject.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for BucketObject."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["BucketObject", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use BucketObject.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[
        Optional[Literal["spaces.digitalocean.crossplane.io/v1alpha1"]],
        Field(alias="apiVersion"),
    ] = "spaces.digitalocean.crossplane.io/v1alpha1"
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["BucketObject"]] = "BucketObject"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: BucketObjectSpec
    status: Optional[BucketObjectStatus] = None


class BucketPolicy(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["BucketPolicy"]:
            return BucketPolicy

        def build(self) -> "BucketPolicy":
            return BucketPolicy(**self._attrs)

        def api_version(
            self,
            value: Optional[Literal["spaces.digitalocean.crossplane.io/v1alpha1"]],
            /,
        ) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["BucketPolicy"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "BucketPolicy.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "BucketPolicy.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(self, value_or_callback: BucketPolicySpec, /) -> "BucketPolicy.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [BucketPolicySpec.Builder], BucketPolicySpec.Builder | BucketPolicySpec
            ],
            /,
        ) -> "BucketPolicy.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "BucketPolicySpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = BucketPolicySpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(BucketPolicySpec.builder())
                if isinstance(output, BucketPolicySpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(
            self, value_or_callback: Optional[BucketPolicyStatus], /
        ) -> "BucketPolicy.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [BucketPolicyStatus.Builder],
                BucketPolicyStatus.Builder | BucketPolicyStatus,
            ],
            /,
        ) -> "BucketPolicy.Builder": ...

        @overload
        def status(self, value_or_callback: Never = ...) -> "BucketPolicyStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = BucketPolicyStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(BucketPolicyStatus.builder())
                if isinstance(output, BucketPolicyStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["BucketPolicy.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = BucketPolicy.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for BucketPolicy."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["BucketPolicy", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use BucketPolicy.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[
        Optional[Literal["spaces.digitalocean.crossplane.io/v1alpha1"]],
        Field(alias="apiVersion"),
    ] = "spaces.digitalocean.crossplane.io/v1alpha1"
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["BucketPolicy"]] = "BucketPolicy"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: BucketPolicySpec
    status: Optional[BucketPolicyStatus] = None


class Bucket(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Bucket"]:
            return Bucket

        def build(self) -> "Bucket":
            return Bucket(**self._attrs)

        def api_version(
            self,
            value: Optional[Literal["spaces.digitalocean.crossplane.io/v1alpha1"]],
            /,
        ) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["Bucket"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "Bucket.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "Bucket.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(self, value_or_callback: BucketSpec, /) -> "Bucket.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[[BucketSpec.Builder], BucketSpec.Builder | BucketSpec],
            /,
        ) -> "Bucket.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "BucketSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = BucketSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(BucketSpec.builder())
                if isinstance(output, BucketSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(self, value_or_callback: Optional[BucketStatus], /) -> "Bucket.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [BucketStatus.Builder], BucketStatus.Builder | BucketStatus
            ],
            /,
        ) -> "Bucket.Builder": ...

        @overload
        def status(self, value_or_callback: Never = ...) -> "BucketStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = BucketStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(BucketStatus.builder())
                if isinstance(output, BucketStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["Bucket.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Bucket.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Bucket."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Bucket", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Bucket.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[
        Optional[Literal["spaces.digitalocean.crossplane.io/v1alpha1"]],
        Field(alias="apiVersion"),
    ] = "spaces.digitalocean.crossplane.io/v1alpha1"
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["Bucket"]] = "Bucket"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: BucketSpec
    status: Optional[BucketStatus] = None


class Cdn(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Cdn"]:
            return Cdn

        def build(self) -> "Cdn":
            return Cdn(**self._attrs)

        def api_version(
            self,
            value: Optional[Literal["spaces.digitalocean.crossplane.io/v1alpha1"]],
            /,
        ) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["Cdn"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "Cdn.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "Cdn.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(self, value_or_callback: CdnSpec, /) -> "Cdn.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[[CdnSpec.Builder], CdnSpec.Builder | CdnSpec],
            /,
        ) -> "Cdn.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "CdnSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = CdnSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(CdnSpec.builder())
                if isinstance(output, CdnSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(self, value_or_callback: Optional[CdnStatus], /) -> "Cdn.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[[CdnStatus.Builder], CdnStatus.Builder | CdnStatus],
            /,
        ) -> "Cdn.Builder": ...

        @overload
        def status(self, value_or_callback: Never = ...) -> "CdnStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = CdnStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(CdnStatus.builder())
                if isinstance(output, CdnStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["Cdn.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Cdn.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Cdn."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Cdn", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Cdn.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[
        Optional[Literal["spaces.digitalocean.crossplane.io/v1alpha1"]],
        Field(alias="apiVersion"),
    ] = "spaces.digitalocean.crossplane.io/v1alpha1"
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["Cdn"]] = "Cdn"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: CdnSpec
    status: Optional[CdnStatus] = None
