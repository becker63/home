# Generated by cloudcoil-model-codegen v0.5.8
# DO NOT EDIT


from __future__ import annotations

from typing import (
    Annotated,
    Any,
    Callable,
    Dict,
    List,
    Literal,
    Optional,
    Type,
    overload,
)

from cloudcoil import apimachinery
from cloudcoil.pydantic import (
    BaseModel,
    BaseModelBuilder,
    BuilderContextBase,
    GenericListBuilder,
    ListBuilderContext,
    Never,
    Self,
)
from cloudcoil.resources import Resource
from pydantic import AwareDatetime, Field


class EnvironmentConfig(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["EnvironmentConfig"]:
            return EnvironmentConfig

        def build(self) -> "EnvironmentConfig":
            return EnvironmentConfig(**self._attrs)

        def api_version(
            self, value: Optional[Literal["apiextensions.crossplane.io/v1beta1"]], /
        ) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def data(self, value: Optional[Dict[str, Any]], /) -> Self:
            """
            The data of this EnvironmentConfig.
            This may contain any kind of structure that can be serialized into JSON.
            """
            return self._set("data", value)

        def kind(self, value: Optional[Literal["EnvironmentConfig"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "EnvironmentConfig.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "EnvironmentConfig.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

    class BuilderContext(BuilderContextBase["EnvironmentConfig.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = EnvironmentConfig.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for EnvironmentConfig."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["EnvironmentConfig", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use EnvironmentConfig.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[
        Optional[Literal["apiextensions.crossplane.io/v1beta1"]],
        Field(alias="apiVersion"),
    ] = "apiextensions.crossplane.io/v1beta1"
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    data: Optional[Dict[str, Any]] = None
    """
    The data of this EnvironmentConfig.
    This may contain any kind of structure that can be serialized into JSON.
    """
    kind: Optional[Literal["EnvironmentConfig"]] = "EnvironmentConfig"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None


class ResourceRef(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ResourceRef"]:
            return ResourceRef

        def build(self) -> "ResourceRef":
            return ResourceRef(**self._attrs)

        def name(self, value: str, /) -> Self:
            """
            Name of the referent.
            """
            return self._set("name", value)

    class BuilderContext(BuilderContextBase["ResourceRef.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ResourceRef.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ResourceRef."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ResourceRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ResourceRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: str
    """
    Name of the referent.
    """


class ResourceSelector(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ResourceSelector"]:
            return ResourceSelector

        def build(self) -> "ResourceSelector":
            return ResourceSelector(**self._attrs)

        def match_controller_ref(self, value: Optional[bool], /) -> Self:
            """
            MatchControllerRef ensures an object with the same controller reference
            as the selecting object is selected.
            """
            return self._set("match_controller_ref", value)

        def match_labels(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            MatchLabels ensures an object with matching labels is selected.
            """
            return self._set("match_labels", value)

    class BuilderContext(BuilderContextBase["ResourceSelector.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ResourceSelector.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ResourceSelector."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ResourceSelector", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ResourceSelector.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    match_controller_ref: Annotated[Optional[bool], Field(alias="matchControllerRef")] = None
    """
    MatchControllerRef ensures an object with the same controller reference
    as the selecting object is selected.
    """
    match_labels: Annotated[Optional[Dict[str, str]], Field(alias="matchLabels")] = None
    """
    MatchLabels ensures an object with matching labels is selected.
    """


class By(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["By"]:
            return By

        def build(self) -> "By":
            return By(**self._attrs)

        def api_version(self, value: Optional[str], /) -> Self:
            """
            API version of the referent.
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[str], /) -> Self:
            """
            Kind of the referent.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def resource_ref(self, value_or_callback: Optional[ResourceRef], /) -> "By.Builder": ...

        @overload
        def resource_ref(
            self,
            value_or_callback: Callable[[ResourceRef.Builder], ResourceRef.Builder | ResourceRef],
            /,
        ) -> "By.Builder": ...

        @overload
        def resource_ref(self, value_or_callback: Never = ...) -> "ResourceRef.BuilderContext": ...

        def resource_ref(self, value_or_callback=None, /):
            """
            Reference to the resource.
            """
            if self._in_context and value_or_callback is None:
                context = ResourceRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "resource_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ResourceRef.builder())
                if isinstance(output, ResourceRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("resource_ref", value)

        @overload
        def resource_selector(
            self, value_or_callback: Optional[ResourceSelector], /
        ) -> "By.Builder": ...

        @overload
        def resource_selector(
            self,
            value_or_callback: Callable[
                [ResourceSelector.Builder], ResourceSelector.Builder | ResourceSelector
            ],
            /,
        ) -> "By.Builder": ...

        @overload
        def resource_selector(
            self, value_or_callback: Never = ...
        ) -> "ResourceSelector.BuilderContext": ...

        def resource_selector(self, value_or_callback=None, /):
            """
            Selector to the resource.
            This field will be ignored if ResourceRef is set.
            """
            if self._in_context and value_or_callback is None:
                context = ResourceSelector.BuilderContext()
                context._parent_builder = self
                context._field_name = "resource_selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ResourceSelector.builder())
                if isinstance(output, ResourceSelector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("resource_selector", value)

    class BuilderContext(BuilderContextBase["By.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = By.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for By."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["By", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use By.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[str], Field(alias="apiVersion")] = None
    """
    API version of the referent.
    """
    kind: Optional[str] = None
    """
    Kind of the referent.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    resource_ref: Annotated[Optional[ResourceRef], Field(alias="resourceRef")] = None
    """
    Reference to the resource.
    """
    resource_selector: Annotated[Optional[ResourceSelector], Field(alias="resourceSelector")] = None
    """
    Selector to the resource.
    This field will be ignored if ResourceRef is set.
    """


class Of(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Of"]:
            return Of

        def build(self) -> "Of":
            return Of(**self._attrs)

        def api_version(self, value: Optional[str], /) -> Self:
            """
            API version of the referent.
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[str], /) -> Self:
            """
            Kind of the referent.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def resource_ref(self, value_or_callback: Optional[ResourceRef], /) -> "Of.Builder": ...

        @overload
        def resource_ref(
            self,
            value_or_callback: Callable[[ResourceRef.Builder], ResourceRef.Builder | ResourceRef],
            /,
        ) -> "Of.Builder": ...

        @overload
        def resource_ref(self, value_or_callback: Never = ...) -> "ResourceRef.BuilderContext": ...

        def resource_ref(self, value_or_callback=None, /):
            """
            Reference to the resource.
            """
            if self._in_context and value_or_callback is None:
                context = ResourceRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "resource_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ResourceRef.builder())
                if isinstance(output, ResourceRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("resource_ref", value)

        @overload
        def resource_selector(
            self, value_or_callback: Optional[ResourceSelector], /
        ) -> "Of.Builder": ...

        @overload
        def resource_selector(
            self,
            value_or_callback: Callable[
                [ResourceSelector.Builder], ResourceSelector.Builder | ResourceSelector
            ],
            /,
        ) -> "Of.Builder": ...

        @overload
        def resource_selector(
            self, value_or_callback: Never = ...
        ) -> "ResourceSelector.BuilderContext": ...

        def resource_selector(self, value_or_callback=None, /):
            """
            Selector to the resource.
            This field will be ignored if ResourceRef is set.
            """
            if self._in_context and value_or_callback is None:
                context = ResourceSelector.BuilderContext()
                context._parent_builder = self
                context._field_name = "resource_selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ResourceSelector.builder())
                if isinstance(output, ResourceSelector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("resource_selector", value)

    class BuilderContext(BuilderContextBase["Of.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Of.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Of."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Of", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Of.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[str], Field(alias="apiVersion")] = None
    """
    API version of the referent.
    """
    kind: Optional[str] = None
    """
    Kind of the referent.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    resource_ref: Annotated[Optional[ResourceRef], Field(alias="resourceRef")] = None
    """
    Reference to the resource.
    """
    resource_selector: Annotated[Optional[ResourceSelector], Field(alias="resourceSelector")] = None
    """
    Selector to the resource.
    This field will be ignored if ResourceRef is set.
    """


class UsageSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["UsageSpec"]:
            return UsageSpec

        def build(self) -> "UsageSpec":
            return UsageSpec(**self._attrs)

        @overload
        def by(self, value_or_callback: Optional[By], /) -> "UsageSpec.Builder": ...

        @overload
        def by(
            self, value_or_callback: Callable[[By.Builder], By.Builder | By], /
        ) -> "UsageSpec.Builder": ...

        @overload
        def by(self, value_or_callback: Never = ...) -> "By.BuilderContext": ...

        def by(self, value_or_callback=None, /):
            """
            By is the resource that is "using the other resource".
            """
            if self._in_context and value_or_callback is None:
                context = By.BuilderContext()
                context._parent_builder = self
                context._field_name = "by"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(By.builder())
                if isinstance(output, By.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("by", value)

        @overload
        def of(self, value_or_callback: Of, /) -> "UsageSpec.Builder": ...

        @overload
        def of(
            self, value_or_callback: Callable[[Of.Builder], Of.Builder | Of], /
        ) -> "UsageSpec.Builder": ...

        @overload
        def of(self, value_or_callback: Never = ...) -> "Of.BuilderContext": ...

        def of(self, value_or_callback=None, /):
            """
            Of is the resource that is "being used".
            """
            if self._in_context and value_or_callback is None:
                context = Of.BuilderContext()
                context._parent_builder = self
                context._field_name = "of"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Of.builder())
                if isinstance(output, Of.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("of", value)

        def reason(self, value: Optional[str], /) -> Self:
            """
            Reason is the reason for blocking deletion of the resource.
            """
            return self._set("reason", value)

        def replay_deletion(self, value: Optional[bool], /) -> Self:
            """
            ReplayDeletion will trigger a deletion on the used resource during the deletion of the usage itself, if it was attempted to be deleted at least once.
            """
            return self._set("replay_deletion", value)

    class BuilderContext(BuilderContextBase["UsageSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = UsageSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for UsageSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["UsageSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use UsageSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    by: Optional[By] = None
    """
    By is the resource that is "using the other resource".
    """
    of: Of
    """
    Of is the resource that is "being used".
    """
    reason: Optional[str] = None
    """
    Reason is the reason for blocking deletion of the resource.
    """
    replay_deletion: Annotated[Optional[bool], Field(alias="replayDeletion")] = None
    """
    ReplayDeletion will trigger a deletion on the used resource during the deletion of the usage itself, if it was attempted to be deleted at least once.
    """


class Condition(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Condition"]:
            return Condition

        def build(self) -> "Condition":
            return Condition(**self._attrs)

        def last_transition_time(self, value: AwareDatetime, /) -> Self:
            """
            LastTransitionTime is the last time this condition transitioned from one
            status to another.
            """
            return self._set("last_transition_time", value)

        def message(self, value: Optional[str], /) -> Self:
            """
            A Message containing details about this condition's last transition from
            one status to another, if any.
            """
            return self._set("message", value)

        def observed_generation(self, value: Optional[int], /) -> Self:
            """
            ObservedGeneration represents the .metadata.generation that the condition was set based upon.
            For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
            with respect to the current state of the instance.
            """
            return self._set("observed_generation", value)

        def reason(self, value: str, /) -> Self:
            """
            A Reason for this condition's last transition from one status to another.
            """
            return self._set("reason", value)

        def status(self, value: str, /) -> Self:
            """
            Status of this condition; is it currently True, False, or Unknown?
            """
            return self._set("status", value)

        def type(self, value: str, /) -> Self:
            """
            Type of this condition. At most one of each condition type may apply to
            a resource at any point in time.
            """
            return self._set("type", value)

    class BuilderContext(BuilderContextBase["Condition.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Condition.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Condition."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Condition", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Condition.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    last_transition_time: Annotated[AwareDatetime, Field(alias="lastTransitionTime")]
    """
    LastTransitionTime is the last time this condition transitioned from one
    status to another.
    """
    message: Optional[str] = None
    """
    A Message containing details about this condition's last transition from
    one status to another, if any.
    """
    observed_generation: Annotated[Optional[int], Field(alias="observedGeneration")] = None
    """
    ObservedGeneration represents the .metadata.generation that the condition was set based upon.
    For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
    with respect to the current state of the instance.
    """
    reason: str
    """
    A Reason for this condition's last transition from one status to another.
    """
    status: str
    """
    Status of this condition; is it currently True, False, or Unknown?
    """
    type: str
    """
    Type of this condition. At most one of each condition type may apply to
    a resource at any point in time.
    """


class UsageStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["UsageStatus"]:
            return UsageStatus

        def build(self) -> "UsageStatus":
            return UsageStatus(**self._attrs)

        @overload
        def conditions(self, value_or_callback: List[Condition], /) -> "UsageStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Condition, Condition.Builder]],
                GenericListBuilder[Condition, Condition.Builder] | List[Condition],
            ],
            /,
        ) -> "UsageStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            """
            Conditions of the resource.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

    class BuilderContext(BuilderContextBase["UsageStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = UsageStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for UsageStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["UsageStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use UsageStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    conditions: Optional[List[Condition]] = None
    """
    Conditions of the resource.
    """


class Usage(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Usage"]:
            return Usage

        def build(self) -> "Usage":
            return Usage(**self._attrs)

        def api_version(
            self, value: Optional[Literal["apiextensions.crossplane.io/v1beta1"]], /
        ) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["Usage"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "Usage.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "Usage.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(self, value_or_callback: UsageSpec, /) -> "Usage.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[[UsageSpec.Builder], UsageSpec.Builder | UsageSpec],
            /,
        ) -> "Usage.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "UsageSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = UsageSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(UsageSpec.builder())
                if isinstance(output, UsageSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(self, value_or_callback: Optional[UsageStatus], /) -> "Usage.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[[UsageStatus.Builder], UsageStatus.Builder | UsageStatus],
            /,
        ) -> "Usage.Builder": ...

        @overload
        def status(self, value_or_callback: Never = ...) -> "UsageStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = UsageStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(UsageStatus.builder())
                if isinstance(output, UsageStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["Usage.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Usage.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Usage."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Usage", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Usage.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[
        Optional[Literal["apiextensions.crossplane.io/v1beta1"]],
        Field(alias="apiVersion"),
    ] = "apiextensions.crossplane.io/v1beta1"
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["Usage"]] = "Usage"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: UsageSpec
    status: Optional[UsageStatus] = None
