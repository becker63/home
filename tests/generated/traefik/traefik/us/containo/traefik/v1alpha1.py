# Generated by cloudcoil-model-codegen v0.5.8
# DO NOT EDIT


from __future__ import annotations

from typing import (
    Annotated,
    Callable,
    List,
    Literal,
    Optional,
    Type,
    overload,
)

from cloudcoil.pydantic import (
    BaseModel,
    BaseModelBuilder,
    BuilderContextBase,
    GenericListBuilder,
    Never,
    Self,
)
from cloudcoil.resources import Resource
from pydantic import Field

from .....cloudcoil import apimachinery


class ClientAuth(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ClientAuth"]:
            return ClientAuth

        def build(self) -> "ClientAuth":
            return ClientAuth(**self._attrs)

        def client_auth_type(
            self,
            value: Optional[
                Literal[
                    "NoClientCert",
                    "RequestClientCert",
                    "RequireAnyClientCert",
                    "VerifyClientCertIfGiven",
                    "RequireAndVerifyClientCert",
                ]
            ],
            /,
        ) -> Self:
            """
            ClientAuthType defines the client authentication type to apply.
            """
            return self._set("client_auth_type", value)

        def secret_names(self, value: Optional[List[str]], /) -> Self:
            """
            SecretNames defines the names of the referenced Kubernetes Secret storing certificate details.
            """
            return self._set("secret_names", value)

    class BuilderContext(BuilderContextBase["ClientAuth.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ClientAuth.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ClientAuth."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ClientAuth", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ClientAuth.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    client_auth_type: Annotated[
        Optional[
            Literal[
                "NoClientCert",
                "RequestClientCert",
                "RequireAnyClientCert",
                "VerifyClientCertIfGiven",
                "RequireAndVerifyClientCert",
            ]
        ],
        Field(alias="clientAuthType"),
    ] = None
    """
    ClientAuthType defines the client authentication type to apply.
    """
    secret_names: Annotated[Optional[List[str]], Field(alias="secretNames")] = None
    """
    SecretNames defines the names of the referenced Kubernetes Secret storing certificate details.
    """


class TLSOptionSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["TLSOptionSpec"]:
            return TLSOptionSpec

        def build(self) -> "TLSOptionSpec":
            return TLSOptionSpec(**self._attrs)

        def alpn_protocols(self, value: Optional[List[str]], /) -> Self:
            """
            ALPNProtocols defines the list of supported application level protocols for the TLS handshake, in order of preference.
            More info: https://doc.traefik.io/traefik/v2.11/https/tls/#alpn-protocols
            """
            return self._set("alpn_protocols", value)

        def cipher_suites(self, value: Optional[List[str]], /) -> Self:
            """
            CipherSuites defines the list of supported cipher suites for TLS versions up to TLS 1.2.
            More info: https://doc.traefik.io/traefik/v2.11/https/tls/#cipher-suites
            """
            return self._set("cipher_suites", value)

        @overload
        def client_auth(
            self, value_or_callback: Optional[ClientAuth], /
        ) -> "TLSOptionSpec.Builder": ...

        @overload
        def client_auth(
            self,
            value_or_callback: Callable[[ClientAuth.Builder], ClientAuth.Builder | ClientAuth],
            /,
        ) -> "TLSOptionSpec.Builder": ...

        @overload
        def client_auth(self, value_or_callback: Never = ...) -> "ClientAuth.BuilderContext": ...

        def client_auth(self, value_or_callback=None, /):
            """
            ClientAuth defines the server's policy for TLS Client Authentication.
            """
            if self._in_context and value_or_callback is None:
                context = ClientAuth.BuilderContext()
                context._parent_builder = self
                context._field_name = "client_auth"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ClientAuth.builder())
                if isinstance(output, ClientAuth.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("client_auth", value)

        def curve_preferences(self, value: Optional[List[str]], /) -> Self:
            """
            CurvePreferences defines the preferred elliptic curves.
            More info: https://doc.traefik.io/traefik/v2.11/https/tls/#curve-preferences
            """
            return self._set("curve_preferences", value)

        def max_version(self, value: Optional[str], /) -> Self:
            """
            MaxVersion defines the maximum TLS version that Traefik will accept.
            Possible values: VersionTLS10, VersionTLS11, VersionTLS12, VersionTLS13.
            Default: None.
            """
            return self._set("max_version", value)

        def min_version(self, value: Optional[str], /) -> Self:
            """
            MinVersion defines the minimum TLS version that Traefik will accept.
            Possible values: VersionTLS10, VersionTLS11, VersionTLS12, VersionTLS13.
            Default: VersionTLS10.
            """
            return self._set("min_version", value)

        def prefer_server_cipher_suites(self, value: Optional[bool], /) -> Self:
            """
            PreferServerCipherSuites defines whether the server chooses a cipher suite among his own instead of among the client's.
            It is enabled automatically when minVersion or maxVersion is set.
            Deprecated: https://github.com/golang/go/issues/45430
            """
            return self._set("prefer_server_cipher_suites", value)

        def sni_strict(self, value: Optional[bool], /) -> Self:
            """
            SniStrict defines whether Traefik allows connections from clients connections that do not specify a server_name extension.
            """
            return self._set("sni_strict", value)

    class BuilderContext(BuilderContextBase["TLSOptionSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = TLSOptionSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for TLSOptionSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["TLSOptionSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use TLSOptionSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    alpn_protocols: Annotated[Optional[List[str]], Field(alias="alpnProtocols")] = None
    """
    ALPNProtocols defines the list of supported application level protocols for the TLS handshake, in order of preference.
    More info: https://doc.traefik.io/traefik/v2.11/https/tls/#alpn-protocols
    """
    cipher_suites: Annotated[Optional[List[str]], Field(alias="cipherSuites")] = None
    """
    CipherSuites defines the list of supported cipher suites for TLS versions up to TLS 1.2.
    More info: https://doc.traefik.io/traefik/v2.11/https/tls/#cipher-suites
    """
    client_auth: Annotated[Optional[ClientAuth], Field(alias="clientAuth")] = None
    """
    ClientAuth defines the server's policy for TLS Client Authentication.
    """
    curve_preferences: Annotated[Optional[List[str]], Field(alias="curvePreferences")] = None
    """
    CurvePreferences defines the preferred elliptic curves.
    More info: https://doc.traefik.io/traefik/v2.11/https/tls/#curve-preferences
    """
    max_version: Annotated[Optional[str], Field(alias="maxVersion")] = None
    """
    MaxVersion defines the maximum TLS version that Traefik will accept.
    Possible values: VersionTLS10, VersionTLS11, VersionTLS12, VersionTLS13.
    Default: None.
    """
    min_version: Annotated[Optional[str], Field(alias="minVersion")] = None
    """
    MinVersion defines the minimum TLS version that Traefik will accept.
    Possible values: VersionTLS10, VersionTLS11, VersionTLS12, VersionTLS13.
    Default: VersionTLS10.
    """
    prefer_server_cipher_suites: Annotated[
        Optional[bool], Field(alias="preferServerCipherSuites")
    ] = None
    """
    PreferServerCipherSuites defines whether the server chooses a cipher suite among his own instead of among the client's.
    It is enabled automatically when minVersion or maxVersion is set.
    Deprecated: https://github.com/golang/go/issues/45430
    """
    sni_strict: Annotated[Optional[bool], Field(alias="sniStrict")] = None
    """
    SniStrict defines whether Traefik allows connections from clients connections that do not specify a server_name extension.
    """


class TLSOption(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["TLSOption"]:
            return TLSOption

        def build(self) -> "TLSOption":
            return TLSOption(**self._attrs)

        def api_version(self, value: Optional[Literal["traefik.containo.us/v1alpha1"]], /) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["TLSOption"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "TLSOption.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "TLSOption.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(self, value_or_callback: TLSOptionSpec, /) -> "TLSOption.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [TLSOptionSpec.Builder], TLSOptionSpec.Builder | TLSOptionSpec
            ],
            /,
        ) -> "TLSOption.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "TLSOptionSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = TLSOptionSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(TLSOptionSpec.builder())
                if isinstance(output, TLSOptionSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

    class BuilderContext(BuilderContextBase["TLSOption.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = TLSOption.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for TLSOption."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["TLSOption", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use TLSOption.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[
        Optional[Literal["traefik.containo.us/v1alpha1"]], Field(alias="apiVersion")
    ] = "traefik.containo.us/v1alpha1"
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["TLSOption"]] = "TLSOption"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: TLSOptionSpec
