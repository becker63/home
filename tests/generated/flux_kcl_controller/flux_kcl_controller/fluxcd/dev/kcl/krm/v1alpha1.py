# Generated by cloudcoil-model-codegen v0.5.8
# DO NOT EDIT


from __future__ import annotations

from typing import (
    Annotated,
    Callable,
    Dict,
    List,
    Literal,
    Optional,
    Type,
    overload,
)

from cloudcoil import apimachinery
from cloudcoil.pydantic import (
    BaseModel,
    BaseModelBuilder,
    BuilderContextBase,
    GenericListBuilder,
    ListBuilderContext,
    Never,
    Self,
)
from cloudcoil.resources import Resource
from pydantic import AwareDatetime, Field


class ArgumentsReference(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ArgumentsReference"]:
            return ArgumentsReference

        def build(self) -> "ArgumentsReference":
            return ArgumentsReference(**self._attrs)

        def kind(self, value: Literal["Secret", "ConfigMap"], /) -> Self:
            """
            Kind of the values referent, valid values are ('Secret', 'ConfigMap').
            """
            return self._set("kind", value)

        def name(self, value: str, /) -> Self:
            """
            Name of the values referent. Should reside in the same namespace as the
            referring resource.
            """
            return self._set("name", value)

        def optional(self, value: Optional[bool], /) -> Self:
            """
            Optional indicates whether the referenced resource must exist, or whether to
            tolerate its absence. If true and the referenced resource is absent, proceed
            as if the resource was present but empty, without any variables defined.
            """
            return self._set("optional", value)

    class BuilderContext(BuilderContextBase["ArgumentsReference.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ArgumentsReference.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ArgumentsReference."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ArgumentsReference", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ArgumentsReference.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    kind: Literal["Secret", "ConfigMap"]
    """
    Kind of the values referent, valid values are ('Secret', 'ConfigMap').
    """
    name: Annotated[str, Field(max_length=253, min_length=1)]
    """
    Name of the values referent. Should reside in the same namespace as the
    referring resource.
    """
    optional: Optional[bool] = False
    """
    Optional indicates whether the referenced resource must exist, or whether to
    tolerate its absence. If true and the referenced resource is absent, proceed
    as if the resource was present but empty, without any variables defined.
    """


class CommonMetadata(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["CommonMetadata"]:
            return CommonMetadata

        def build(self) -> "CommonMetadata":
            return CommonMetadata(**self._attrs)

        def annotations(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            Annotations to be added to the object's metadata.
            """
            return self._set("annotations", value)

        def labels(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            Labels to be added to the object's metadata.
            """
            return self._set("labels", value)

    class BuilderContext(BuilderContextBase["CommonMetadata.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = CommonMetadata.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for CommonMetadata."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["CommonMetadata", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use CommonMetadata.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    annotations: Optional[Dict[str, str]] = None
    """
    Annotations to be added to the object's metadata.
    """
    labels: Optional[Dict[str, str]] = None
    """
    Labels to be added to the object's metadata.
    """


class Config(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Config"]:
            return Config

        def build(self) -> "Config":
            return Config(**self._attrs)

        def arguments(self, value: Optional[List[str]], /) -> Self:
            """
            Arguments is the list of top level dynamic arguments for the kcl option function, e.g., env="prod"
            """
            return self._set("arguments", value)

        def disable_none(self, value: Optional[bool], /) -> Self:
            """
            DisableNone denotes running kcl and disable dumping None values.
            """
            return self._set("disable_none", value)

        def overrides(self, value: Optional[List[str]], /) -> Self:
            """
            Overrides is the list of override paths and values, e.g., app.image="v2"
            """
            return self._set("overrides", value)

        def path_selectors(self, value: Optional[List[str]], /) -> Self:
            """
            PathSelectors is the list of path selectors to select output result, e.g., a.b.c
            """
            return self._set("path_selectors", value)

        def settings(self, value: Optional[List[str]], /) -> Self:
            """
            Settings is the list of kcl setting files including all of the CLI config.
            """
            return self._set("settings", value)

        def show_hidden(self, value: Optional[bool], /) -> Self:
            """
            ShowHidden denotes output the hidden attribute in the result.
            """
            return self._set("show_hidden", value)

        def sort_keys(self, value: Optional[bool], /) -> Self:
            """
            SortKeys denotes sorting the output result keys, e.g., `{b = 1, a = 2} => {a = 2, b = 1}`.
            """
            return self._set("sort_keys", value)

        def vendor(self, value: Optional[bool], /) -> Self:
            """
            Vendor denotes running kcl in the vendor mode.
            """
            return self._set("vendor", value)

    class BuilderContext(BuilderContextBase["Config.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Config.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Config."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Config", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Config.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    arguments: Optional[List[str]] = None
    """
    Arguments is the list of top level dynamic arguments for the kcl option function, e.g., env="prod"
    """
    disable_none: Annotated[Optional[bool], Field(alias="disableNone")] = None
    """
    DisableNone denotes running kcl and disable dumping None values.
    """
    overrides: Optional[List[str]] = None
    """
    Overrides is the list of override paths and values, e.g., app.image="v2"
    """
    path_selectors: Annotated[Optional[List[str]], Field(alias="pathSelectors")] = None
    """
    PathSelectors is the list of path selectors to select output result, e.g., a.b.c
    """
    settings: Optional[List[str]] = None
    """
    Settings is the list of kcl setting files including all of the CLI config.
    """
    show_hidden: Annotated[Optional[bool], Field(alias="showHidden")] = None
    """
    ShowHidden denotes output the hidden attribute in the result.
    """
    sort_keys: Annotated[Optional[bool], Field(alias="sortKeys")] = None
    """
    SortKeys denotes sorting the output result keys, e.g., `{b = 1, a = 2} => {a = 2, b = 1}`.
    """
    vendor: Optional[bool] = None
    """
    Vendor denotes running kcl in the vendor mode.
    """


class DependsOn(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["DependsOn"]:
            return DependsOn

        def build(self) -> "DependsOn":
            return DependsOn(**self._attrs)

        def name(self, value: str, /) -> Self:
            """
            Name of the referent.
            """
            return self._set("name", value)

        def namespace(self, value: Optional[str], /) -> Self:
            """
            Namespace of the referent, when not specified it acts as LocalObjectReference.
            """
            return self._set("namespace", value)

    class BuilderContext(BuilderContextBase["DependsOn.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DependsOn.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DependsOn."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["DependsOn", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use DependsOn.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: str
    """
    Name of the referent.
    """
    namespace: Optional[str] = None
    """
    Namespace of the referent, when not specified it acts as LocalObjectReference.
    """


class HealthCheck(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["HealthCheck"]:
            return HealthCheck

        def build(self) -> "HealthCheck":
            return HealthCheck(**self._attrs)

        def api_version(self, value: Optional[str], /) -> Self:
            """
            API version of the referent, if not specified the Kubernetes preferred version will be used.
            """
            return self._set("api_version", value)

        def kind(self, value: str, /) -> Self:
            """
            Kind of the referent.
            """
            return self._set("kind", value)

        def name(self, value: str, /) -> Self:
            """
            Name of the referent.
            """
            return self._set("name", value)

        def namespace(self, value: Optional[str], /) -> Self:
            """
            Namespace of the referent, when not specified it acts as LocalObjectReference.
            """
            return self._set("namespace", value)

    class BuilderContext(BuilderContextBase["HealthCheck.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = HealthCheck.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for HealthCheck."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["HealthCheck", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use HealthCheck.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[str], Field(alias="apiVersion")] = None
    """
    API version of the referent, if not specified the Kubernetes preferred version will be used.
    """
    kind: str
    """
    Kind of the referent.
    """
    name: str
    """
    Name of the referent.
    """
    namespace: Optional[str] = None
    """
    Namespace of the referent, when not specified it acts as LocalObjectReference.
    """


class SecretRef(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["SecretRef"]:
            return SecretRef

        def build(self) -> "SecretRef":
            return SecretRef(**self._attrs)

        def key(self, value: Optional[str], /) -> Self:
            """
            Key in the Secret, when not specified an implementation-specific default key is used.
            """
            return self._set("key", value)

        def name(self, value: str, /) -> Self:
            """
            Name of the Secret.
            """
            return self._set("name", value)

    class BuilderContext(BuilderContextBase["SecretRef.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SecretRef.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SecretRef."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["SecretRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SecretRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: Optional[str] = None
    """
    Key in the Secret, when not specified an implementation-specific default key is used.
    """
    name: str
    """
    Name of the Secret.
    """


class KubeConfig(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["KubeConfig"]:
            return KubeConfig

        def build(self) -> "KubeConfig":
            return KubeConfig(**self._attrs)

        @overload
        def secret_ref(self, value_or_callback: SecretRef, /) -> "KubeConfig.Builder": ...

        @overload
        def secret_ref(
            self,
            value_or_callback: Callable[[SecretRef.Builder], SecretRef.Builder | SecretRef],
            /,
        ) -> "KubeConfig.Builder": ...

        @overload
        def secret_ref(self, value_or_callback: Never = ...) -> "SecretRef.BuilderContext": ...

        def secret_ref(self, value_or_callback=None, /):
            """
            SecretRef holds the name of a secret that contains a key with
            the kubeconfig file as the value. If no key is set, the key will default
            to 'value'.
            It is recommended that the kubeconfig is self-contained, and the secret
            is regularly updated if credentials such as a cloud-access-token expire.
            Cloud specific `cmd-path` auth helpers will not function without adding
            binaries and credentials to the Pod that is responsible for reconciling
            Kubernetes resources.
            """
            if self._in_context and value_or_callback is None:
                context = SecretRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "secret_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SecretRef.builder())
                if isinstance(output, SecretRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("secret_ref", value)

    class BuilderContext(BuilderContextBase["KubeConfig.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = KubeConfig.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for KubeConfig."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["KubeConfig", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use KubeConfig.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    secret_ref: Annotated[SecretRef, Field(alias="secretRef")]
    """
    SecretRef holds the name of a secret that contains a key with
    the kubeconfig file as the value. If no key is set, the key will default
    to 'value'.
    It is recommended that the kubeconfig is self-contained, and the secret
    is regularly updated if credentials such as a cloud-access-token expire.
    Cloud specific `cmd-path` auth helpers will not function without adding
    binaries and credentials to the Pod that is responsible for reconciling
    Kubernetes resources.
    """


class SourceRef(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["SourceRef"]:
            return SourceRef

        def build(self) -> "SourceRef":
            return SourceRef(**self._attrs)

        def api_version(self, value: Optional[str], /) -> Self:
            """
            API version of the referent.
            """
            return self._set("api_version", value)

        def kind(self, value: Literal["OCIRepository", "GitRepository", "Bucket"], /) -> Self:
            """
            Kind of the referent.
            """
            return self._set("kind", value)

        def name(self, value: str, /) -> Self:
            """
            Name of the referent.
            """
            return self._set("name", value)

        def namespace(self, value: Optional[str], /) -> Self:
            """
            Namespace of the referent, defaults to the namespace of the Kubernetes
            resource object that contains the reference.
            """
            return self._set("namespace", value)

    class BuilderContext(BuilderContextBase["SourceRef.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SourceRef.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SourceRef."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["SourceRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SourceRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[str], Field(alias="apiVersion")] = None
    """
    API version of the referent.
    """
    kind: Literal["OCIRepository", "GitRepository", "Bucket"]
    """
    Kind of the referent.
    """
    name: str
    """
    Name of the referent.
    """
    namespace: Optional[str] = None
    """
    Namespace of the referent, defaults to the namespace of the Kubernetes
    resource object that contains the reference.
    """


class KCLRunSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["KCLRunSpec"]:
            return KCLRunSpec

        def build(self) -> "KCLRunSpec":
            return KCLRunSpec(**self._attrs)

        @overload
        def arguments_references(
            self, value_or_callback: List[ArgumentsReference], /
        ) -> "KCLRunSpec.Builder": ...

        @overload
        def arguments_references(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[ArgumentsReference, ArgumentsReference.Builder]],
                GenericListBuilder[ArgumentsReference, ArgumentsReference.Builder]
                | List[ArgumentsReference],
            ],
            /,
        ) -> "KCLRunSpec.Builder": ...

        @overload
        def arguments_references(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ArgumentsReference.Builder]: ...

        def arguments_references(self, value_or_callback=None, /):
            """
            ConfigReference holds references to ConfigMaps and Secrets containing
            the KCL compile config. The ConfigMap and the Secret data keys represent the config names.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ArgumentsReference.Builder]()
                context._parent_builder = self
                context._field_name = "arguments_references"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ArgumentsReference.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("arguments_references", value)

        @overload
        def common_metadata(
            self, value_or_callback: Optional[CommonMetadata], /
        ) -> "KCLRunSpec.Builder": ...

        @overload
        def common_metadata(
            self,
            value_or_callback: Callable[
                [CommonMetadata.Builder], CommonMetadata.Builder | CommonMetadata
            ],
            /,
        ) -> "KCLRunSpec.Builder": ...

        @overload
        def common_metadata(
            self, value_or_callback: Never = ...
        ) -> "CommonMetadata.BuilderContext": ...

        def common_metadata(self, value_or_callback=None, /):
            """
            CommonMetadata specifies the common labels and annotations that are
            applied to all resources. Any existing label or annotation will be
            overridden if its key matches a common one.
            """
            if self._in_context and value_or_callback is None:
                context = CommonMetadata.BuilderContext()
                context._parent_builder = self
                context._field_name = "common_metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(CommonMetadata.builder())
                if isinstance(output, CommonMetadata.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("common_metadata", value)

        @overload
        def config(self, value_or_callback: Optional[Config], /) -> "KCLRunSpec.Builder": ...

        @overload
        def config(
            self,
            value_or_callback: Callable[[Config.Builder], Config.Builder | Config],
            /,
        ) -> "KCLRunSpec.Builder": ...

        @overload
        def config(self, value_or_callback: Never = ...) -> "Config.BuilderContext": ...

        def config(self, value_or_callback=None, /):
            """
            Config is the KCL compile config.
            """
            if self._in_context and value_or_callback is None:
                context = Config.BuilderContext()
                context._parent_builder = self
                context._field_name = "config"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Config.builder())
                if isinstance(output, Config.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("config", value)

        @overload
        def depends_on(self, value_or_callback: List[DependsOn], /) -> "KCLRunSpec.Builder": ...

        @overload
        def depends_on(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[DependsOn, DependsOn.Builder]],
                GenericListBuilder[DependsOn, DependsOn.Builder] | List[DependsOn],
            ],
            /,
        ) -> "KCLRunSpec.Builder": ...

        @overload
        def depends_on(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[DependsOn.Builder]: ...

        def depends_on(self, value_or_callback=None, /):
            """
            DependsOn may contain a meta.NamespacedObjectReference slice
            with references to Kustomization resources that must be ready before this
            Kustomization can be reconciled.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[DependsOn.Builder]()
                context._parent_builder = self
                context._field_name = "depends_on"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(DependsOn.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("depends_on", value)

        def force(self, value: Optional[bool], /) -> Self:
            """
            Force instructs the controller to recreate resources
            when patching fails due to an immutable field change.
            """
            return self._set("force", value)

        @overload
        def health_checks(
            self, value_or_callback: List[HealthCheck], /
        ) -> "KCLRunSpec.Builder": ...

        @overload
        def health_checks(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[HealthCheck, HealthCheck.Builder]],
                GenericListBuilder[HealthCheck, HealthCheck.Builder] | List[HealthCheck],
            ],
            /,
        ) -> "KCLRunSpec.Builder": ...

        @overload
        def health_checks(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[HealthCheck.Builder]: ...

        def health_checks(self, value_or_callback=None, /):
            """
            A list of resources to be included in the health assessment.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[HealthCheck.Builder]()
                context._parent_builder = self
                context._field_name = "health_checks"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(HealthCheck.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("health_checks", value)

        def interval(self, value: str, /) -> Self:
            """
            The interval at which to reconcile the KCL Module.
            This interval is approximate and may be subject to jitter to ensure
            efficient use of resources.
            """
            return self._set("interval", value)

        @overload
        def kube_config(
            self, value_or_callback: Optional[KubeConfig], /
        ) -> "KCLRunSpec.Builder": ...

        @overload
        def kube_config(
            self,
            value_or_callback: Callable[[KubeConfig.Builder], KubeConfig.Builder | KubeConfig],
            /,
        ) -> "KCLRunSpec.Builder": ...

        @overload
        def kube_config(self, value_or_callback: Never = ...) -> "KubeConfig.BuilderContext": ...

        def kube_config(self, value_or_callback=None, /):
            """
            The KubeConfig for reconciling the controller on a remote cluster.
            When used in combination with `KCLRunSpec.ServiceAccountName`,
            forces the controller to act on behalf of that Service Account at the
            target cluster.
            If the --default-service-account flag is set, its value will be used as
            a controller level fallback for when `KCLRunSpec.ServiceAccountName`
            is empty.
            """
            if self._in_context and value_or_callback is None:
                context = KubeConfig.BuilderContext()
                context._parent_builder = self
                context._field_name = "kube_config"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(KubeConfig.builder())
                if isinstance(output, KubeConfig.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("kube_config", value)

        def path(self, value: Optional[str], /) -> Self:
            """
            Path to the directory containing the kcl.mod file.
            Defaults to 'None', which translates to the root path of the SourceRef.
            """
            return self._set("path", value)

        def persistent_client(self, value: Optional[bool], /) -> Self:
            """
            PersistentClient tells the controller to use a persistent Kubernetes
            client for this release. When enabled, the client will be reused for the
            duration of the reconciliation, instead of being created and destroyed
            for each (step of a).

            If not set, it defaults to true.
            """
            return self._set("persistent_client", value)

        def prune(self, value: bool, /) -> Self:
            """
            Prune enables garbage collection.
            """
            return self._set("prune", value)

        def retry_interval(self, value: Optional[str], /) -> Self:
            """
            The interval at which to retry a previously failed reconciliation.
            When not specified, the controller uses the KCLRunSpec.Interval
            value to retry failures.
            """
            return self._set("retry_interval", value)

        def service_account_name(self, value: Optional[str], /) -> Self:
            """
            The name of the Kubernetes service account to impersonate
            when reconciling this KCL source.
            """
            return self._set("service_account_name", value)

        @overload
        def source_ref(self, value_or_callback: SourceRef, /) -> "KCLRunSpec.Builder": ...

        @overload
        def source_ref(
            self,
            value_or_callback: Callable[[SourceRef.Builder], SourceRef.Builder | SourceRef],
            /,
        ) -> "KCLRunSpec.Builder": ...

        @overload
        def source_ref(self, value_or_callback: Never = ...) -> "SourceRef.BuilderContext": ...

        def source_ref(self, value_or_callback=None, /):
            """
            Reference of the source where the kcl file is.
            """
            if self._in_context and value_or_callback is None:
                context = SourceRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "source_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SourceRef.builder())
                if isinstance(output, SourceRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("source_ref", value)

        def suspend(self, value: Optional[bool], /) -> Self:
            """
            This flag tells the controller to suspend subsequent kustomize executions,
            it does not apply to already started executions. Defaults to false.
            """
            return self._set("suspend", value)

        def target_namespace(self, value: Optional[str], /) -> Self:
            """
            TargetNamespace to target when performing operations for the KCL.
            Defaults to the namespace of the KCL source.
            """
            return self._set("target_namespace", value)

        def timeout(self, value: Optional[str], /) -> Self:
            """
            Timeout is the time to wait for any individual Kubernetes operation (like Jobs
            for hooks) during the performance. Defaults to '5m0s'.
            """
            return self._set("timeout", value)

        def wait(self, value: Optional[bool], /) -> Self:
            """
            Wait instructs the controller to check the health of all the reconciled
            resources. When enabled, the HealthChecks are ignored. Defaults to false.
            """
            return self._set("wait", value)

    class BuilderContext(BuilderContextBase["KCLRunSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = KCLRunSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for KCLRunSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["KCLRunSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use KCLRunSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    arguments_references: Annotated[
        Optional[List[ArgumentsReference]], Field(alias="argumentsReferences")
    ] = None
    """
    ConfigReference holds references to ConfigMaps and Secrets containing
    the KCL compile config. The ConfigMap and the Secret data keys represent the config names.
    """
    common_metadata: Annotated[Optional[CommonMetadata], Field(alias="commonMetadata")] = None
    """
    CommonMetadata specifies the common labels and annotations that are
    applied to all resources. Any existing label or annotation will be
    overridden if its key matches a common one.
    """
    config: Optional[Config] = None
    """
    Config is the KCL compile config.
    """
    depends_on: Annotated[Optional[List[DependsOn]], Field(alias="dependsOn")] = None
    """
    DependsOn may contain a meta.NamespacedObjectReference slice
    with references to Kustomization resources that must be ready before this
    Kustomization can be reconciled.
    """
    force: Optional[bool] = False
    """
    Force instructs the controller to recreate resources
    when patching fails due to an immutable field change.
    """
    health_checks: Annotated[Optional[List[HealthCheck]], Field(alias="healthChecks")] = None
    """
    A list of resources to be included in the health assessment.
    """
    interval: Annotated[str, Field(pattern="^([0-9]+(\\.[0-9]+)?(ms|s|m|h))+$")]
    """
    The interval at which to reconcile the KCL Module.
    This interval is approximate and may be subject to jitter to ensure
    efficient use of resources.
    """
    kube_config: Annotated[Optional[KubeConfig], Field(alias="kubeConfig")] = None
    """
    The KubeConfig for reconciling the controller on a remote cluster.
    When used in combination with `KCLRunSpec.ServiceAccountName`,
    forces the controller to act on behalf of that Service Account at the
    target cluster.
    If the --default-service-account flag is set, its value will be used as
    a controller level fallback for when `KCLRunSpec.ServiceAccountName`
    is empty.
    """
    path: Optional[str] = None
    """
    Path to the directory containing the kcl.mod file.
    Defaults to 'None', which translates to the root path of the SourceRef.
    """
    persistent_client: Annotated[Optional[bool], Field(alias="persistentClient")] = None
    """
    PersistentClient tells the controller to use a persistent Kubernetes
    client for this release. When enabled, the client will be reused for the
    duration of the reconciliation, instead of being created and destroyed
    for each (step of a).

    If not set, it defaults to true.
    """
    prune: bool
    """
    Prune enables garbage collection.
    """
    retry_interval: Annotated[
        Optional[str],
        Field(alias="retryInterval", pattern="^([0-9]+(\\.[0-9]+)?(ms|s|m|h))+$"),
    ] = None
    """
    The interval at which to retry a previously failed reconciliation.
    When not specified, the controller uses the KCLRunSpec.Interval
    value to retry failures.
    """
    service_account_name: Annotated[
        Optional[str], Field(alias="serviceAccountName", max_length=253, min_length=1)
    ] = None
    """
    The name of the Kubernetes service account to impersonate
    when reconciling this KCL source.
    """
    source_ref: Annotated[SourceRef, Field(alias="sourceRef")]
    """
    Reference of the source where the kcl file is.
    """
    suspend: Optional[bool] = None
    """
    This flag tells the controller to suspend subsequent kustomize executions,
    it does not apply to already started executions. Defaults to false.
    """
    target_namespace: Annotated[
        Optional[str], Field(alias="targetNamespace", max_length=63, min_length=1)
    ] = None
    """
    TargetNamespace to target when performing operations for the KCL.
    Defaults to the namespace of the KCL source.
    """
    timeout: Annotated[Optional[str], Field(pattern="^([0-9]+(\\.[0-9]+)?(ms|s|m|h))+$")] = None
    """
    Timeout is the time to wait for any individual Kubernetes operation (like Jobs
    for hooks) during the performance. Defaults to '5m0s'.
    """
    wait: Optional[bool] = None
    """
    Wait instructs the controller to check the health of all the reconciled
    resources. When enabled, the HealthChecks are ignored. Defaults to false.
    """


class Condition(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Condition"]:
            return Condition

        def build(self) -> "Condition":
            return Condition(**self._attrs)

        def last_transition_time(self, value: AwareDatetime, /) -> Self:
            """
            lastTransitionTime is the last time the condition transitioned from one status to another.
            This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
            """
            return self._set("last_transition_time", value)

        def message(self, value: str, /) -> Self:
            """
            message is a human readable message indicating details about the transition.
            This may be an empty string.
            """
            return self._set("message", value)

        def observed_generation(self, value: Optional[int], /) -> Self:
            """
            observedGeneration represents the .metadata.generation that the condition was set based upon.
            For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
            with respect to the current state of the instance.
            """
            return self._set("observed_generation", value)

        def reason(self, value: str, /) -> Self:
            """
            reason contains a programmatic identifier indicating the reason for the condition's last transition.
            Producers of specific condition types may define expected values and meanings for this field,
            and whether the values are considered a guaranteed API.
            The value should be a CamelCase string.
            This field may not be empty.
            """
            return self._set("reason", value)

        def status(self, value: Literal["True", "False", "Unknown"], /) -> Self:
            """
            status of the condition, one of True, False, Unknown.
            """
            return self._set("status", value)

        def type(self, value: str, /) -> Self:
            """
            type of condition in CamelCase or in foo.example.com/CamelCase.
            """
            return self._set("type", value)

    class BuilderContext(BuilderContextBase["Condition.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Condition.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Condition."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Condition", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Condition.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    last_transition_time: Annotated[AwareDatetime, Field(alias="lastTransitionTime")]
    """
    lastTransitionTime is the last time the condition transitioned from one status to another.
    This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
    """
    message: Annotated[str, Field(max_length=32768)]
    """
    message is a human readable message indicating details about the transition.
    This may be an empty string.
    """
    observed_generation: Annotated[Optional[int], Field(alias="observedGeneration", ge=0)] = None
    """
    observedGeneration represents the .metadata.generation that the condition was set based upon.
    For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
    with respect to the current state of the instance.
    """
    reason: Annotated[
        str,
        Field(
            max_length=1024,
            min_length=1,
            pattern="^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$",
        ),
    ]
    """
    reason contains a programmatic identifier indicating the reason for the condition's last transition.
    Producers of specific condition types may define expected values and meanings for this field,
    and whether the values are considered a guaranteed API.
    The value should be a CamelCase string.
    This field may not be empty.
    """
    status: Literal["True", "False", "Unknown"]
    """
    status of the condition, one of True, False, Unknown.
    """
    type: Annotated[
        str,
        Field(
            max_length=316,
            pattern="^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$",
        ),
    ]
    """
    type of condition in CamelCase or in foo.example.com/CamelCase.
    """


class Entry(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Entry"]:
            return Entry

        def build(self) -> "Entry":
            return Entry(**self._attrs)

        def id(self, value: str, /) -> Self:
            """
            ID is the string representation of the Kubernetes resource object's metadata,
            in the format '<namespace>_<name>_<group>_<kind>'.
            """
            return self._set("id", value)

        def v(self, value: str, /) -> Self:
            """
            Version is the API version of the Kubernetes resource object's kind.
            """
            return self._set("v", value)

    class BuilderContext(BuilderContextBase["Entry.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Entry.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Entry."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Entry", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Entry.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    id: str
    """
    ID is the string representation of the Kubernetes resource object's metadata,
    in the format '<namespace>_<name>_<group>_<kind>'.
    """
    v: str
    """
    Version is the API version of the Kubernetes resource object's kind.
    """


class Inventory(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Inventory"]:
            return Inventory

        def build(self) -> "Inventory":
            return Inventory(**self._attrs)

        @overload
        def entries(self, value_or_callback: List[Entry], /) -> "Inventory.Builder": ...

        @overload
        def entries(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Entry, Entry.Builder]],
                GenericListBuilder[Entry, Entry.Builder] | List[Entry],
            ],
            /,
        ) -> "Inventory.Builder": ...

        @overload
        def entries(self, value_or_callback: Never = ...) -> ListBuilderContext[Entry.Builder]: ...

        def entries(self, value_or_callback=None, /):
            """
            Entries of Kubernetes resource object references.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Entry.Builder]()
                context._parent_builder = self
                context._field_name = "entries"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Entry.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("entries", value)

    class BuilderContext(BuilderContextBase["Inventory.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Inventory.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Inventory."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Inventory", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Inventory.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    entries: List[Entry]
    """
    Entries of Kubernetes resource object references.
    """


class KCLRunStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["KCLRunStatus"]:
            return KCLRunStatus

        def build(self) -> "KCLRunStatus":
            return KCLRunStatus(**self._attrs)

        @overload
        def conditions(self, value_or_callback: List[Condition], /) -> "KCLRunStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Condition, Condition.Builder]],
                GenericListBuilder[Condition, Condition.Builder] | List[Condition],
            ],
            /,
        ) -> "KCLRunStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        @overload
        def inventory(
            self, value_or_callback: Optional[Inventory], /
        ) -> "KCLRunStatus.Builder": ...

        @overload
        def inventory(
            self,
            value_or_callback: Callable[[Inventory.Builder], Inventory.Builder | Inventory],
            /,
        ) -> "KCLRunStatus.Builder": ...

        @overload
        def inventory(self, value_or_callback: Never = ...) -> "Inventory.BuilderContext": ...

        def inventory(self, value_or_callback=None, /):
            """
            Inventory contains the list of Kubernetes resource object references that
            have been successfully applied.
            """
            if self._in_context and value_or_callback is None:
                context = Inventory.BuilderContext()
                context._parent_builder = self
                context._field_name = "inventory"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Inventory.builder())
                if isinstance(output, Inventory.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("inventory", value)

        def last_applied_revision(self, value: Optional[str], /) -> Self:
            """
            The last successfully applied revision.
            Equals the Revision of the applied Artifact from the referenced Source.
            """
            return self._set("last_applied_revision", value)

        def last_attempted_revision(self, value: Optional[str], /) -> Self:
            """
            LastAttemptedRevision is the revision of the last reconciliation attempt.
            """
            return self._set("last_attempted_revision", value)

        def last_attempted_revision_digest(self, value: Optional[str], /) -> Self:
            """
            LastAttemptedRevisionDigest is the digest of the last reconciliation attempt.
            This is only set for OCIRepository sources.
            """
            return self._set("last_attempted_revision_digest", value)

        def last_handled_reconcile_at(self, value: Optional[str], /) -> Self:
            """
            LastHandledReconcileAt holds the value of the most recent
            reconcile request value, so a change of the annotation value
            can be detected.
            """
            return self._set("last_handled_reconcile_at", value)

        def observed_generation(self, value: Optional[int], /) -> Self:
            """
            ObservedGeneration is the last reconciled generation.
            """
            return self._set("observed_generation", value)

    class BuilderContext(BuilderContextBase["KCLRunStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = KCLRunStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for KCLRunStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["KCLRunStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use KCLRunStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    conditions: Optional[List[Condition]] = None
    inventory: Optional[Inventory] = None
    """
    Inventory contains the list of Kubernetes resource object references that
    have been successfully applied.
    """
    last_applied_revision: Annotated[Optional[str], Field(alias="lastAppliedRevision")] = None
    """
    The last successfully applied revision.
    Equals the Revision of the applied Artifact from the referenced Source.
    """
    last_attempted_revision: Annotated[Optional[str], Field(alias="lastAttemptedRevision")] = None
    """
    LastAttemptedRevision is the revision of the last reconciliation attempt.
    """
    last_attempted_revision_digest: Annotated[
        Optional[str], Field(alias="lastAttemptedRevisionDigest")
    ] = None
    """
    LastAttemptedRevisionDigest is the digest of the last reconciliation attempt.
    This is only set for OCIRepository sources.
    """
    last_handled_reconcile_at: Annotated[Optional[str], Field(alias="lastHandledReconcileAt")] = (
        None
    )
    """
    LastHandledReconcileAt holds the value of the most recent
    reconcile request value, so a change of the annotation value
    can be detected.
    """
    observed_generation: Annotated[Optional[int], Field(alias="observedGeneration")] = None
    """
    ObservedGeneration is the last reconciled generation.
    """


class KCLRun(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["KCLRun"]:
            return KCLRun

        def build(self) -> "KCLRun":
            return KCLRun(**self._attrs)

        def api_version(self, value: Optional[Literal["krm.kcl.dev.fluxcd/v1alpha1"]], /) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["KCLRun"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "KCLRun.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "KCLRun.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(self, value_or_callback: Optional[KCLRunSpec], /) -> "KCLRun.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[[KCLRunSpec.Builder], KCLRunSpec.Builder | KCLRunSpec],
            /,
        ) -> "KCLRun.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "KCLRunSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = KCLRunSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(KCLRunSpec.builder())
                if isinstance(output, KCLRunSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(self, value_or_callback: Optional[KCLRunStatus], /) -> "KCLRun.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [KCLRunStatus.Builder], KCLRunStatus.Builder | KCLRunStatus
            ],
            /,
        ) -> "KCLRun.Builder": ...

        @overload
        def status(self, value_or_callback: Never = ...) -> "KCLRunStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = KCLRunStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(KCLRunStatus.builder())
                if isinstance(output, KCLRunStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["KCLRun.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = KCLRun.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for KCLRun."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["KCLRun", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use KCLRun.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[
        Optional[Literal["krm.kcl.dev.fluxcd/v1alpha1"]], Field(alias="apiVersion")
    ] = "krm.kcl.dev.fluxcd/v1alpha1"
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["KCLRun"]] = "KCLRun"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: Optional[KCLRunSpec] = None
    status: Optional[KCLRunStatus] = None
