# Generated by cloudcoil-model-codegen v0.5.8
# DO NOT EDIT


from __future__ import annotations

from typing import (
    Annotated,
    Any,
    Callable,
    Dict,
    List,
    Literal,
    Optional,
    Type,
    overload,
)

from cloudcoil import apimachinery
from cloudcoil.pydantic import (
    BaseModel,
    BaseModelBuilder,
    BuilderContextBase,
    GenericListBuilder,
    ListBuilderContext,
    Never,
    Self,
)
from cloudcoil.resources import Resource
from pydantic import AwareDatetime, Field


class PasswordSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PasswordSpec"]:
            return PasswordSpec

        def build(self) -> "PasswordSpec":
            return PasswordSpec(**self._attrs)

        def allow_repeat(self, value: Optional[bool], /) -> Self:
            """
            set allowRepeat to true to allow repeating characters.
            """
            return self._set("allow_repeat", value)

        def digits(self, value: Optional[int], /) -> Self:
            """
            digits specifies the number of digits in the generated
            password. If omitted it defaults to 25% of the length of the password
            """
            return self._set("digits", value)

        def length(self, value: Optional[int], /) -> Self:
            """
            Length of the password to be generated.
            Defaults to 24
            """
            return self._set("length", value)

        def no_upper(self, value: Optional[bool], /) -> Self:
            """
            Set noUpper to disable uppercase characters
            """
            return self._set("no_upper", value)

        def symbol_characters(self, value: Optional[str], /) -> Self:
            """
            symbolCharacters specifies the special characters that should be used
            in the generated password.
            """
            return self._set("symbol_characters", value)

        def symbols(self, value: Optional[int], /) -> Self:
            """
            symbols specifies the number of symbol characters in the generated
            password. If omitted it defaults to 25% of the length of the password
            """
            return self._set("symbols", value)

    class BuilderContext(BuilderContextBase["PasswordSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PasswordSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PasswordSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["PasswordSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PasswordSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    allow_repeat: Annotated[Optional[bool], Field(alias="allowRepeat")] = False
    """
    set allowRepeat to true to allow repeating characters.
    """
    digits: Optional[int] = None
    """
    digits specifies the number of digits in the generated
    password. If omitted it defaults to 25% of the length of the password
    """
    length: Optional[int] = 24
    """
    Length of the password to be generated.
    Defaults to 24
    """
    no_upper: Annotated[Optional[bool], Field(alias="noUpper")] = False
    """
    Set noUpper to disable uppercase characters
    """
    symbol_characters: Annotated[Optional[str], Field(alias="symbolCharacters")] = None
    """
    symbolCharacters specifies the special characters that should be used
    in the generated password.
    """
    symbols: Optional[int] = None
    """
    symbols specifies the number of symbol characters in the generated
    password. If omitted it defaults to 25% of the length of the password
    """


class Generator(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Generator"]:
            return Generator

        def build(self) -> "Generator":
            return Generator(**self._attrs)

        @overload
        def password_spec(
            self, value_or_callback: Optional[PasswordSpec], /
        ) -> "Generator.Builder": ...

        @overload
        def password_spec(
            self,
            value_or_callback: Callable[
                [PasswordSpec.Builder], PasswordSpec.Builder | PasswordSpec
            ],
            /,
        ) -> "Generator.Builder": ...

        @overload
        def password_spec(
            self, value_or_callback: Never = ...
        ) -> "PasswordSpec.BuilderContext": ...

        def password_spec(self, value_or_callback=None, /):
            """
            PasswordSpec controls the behavior of the password generator.
            """
            if self._in_context and value_or_callback is None:
                context = PasswordSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "password_spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PasswordSpec.builder())
                if isinstance(output, PasswordSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("password_spec", value)

        def uuid_spec(self, value: Optional[Dict[str, Any]], /) -> Self:
            """
            UUIDSpec controls the behavior of the uuid generator.
            """
            return self._set("uuid_spec", value)

    class BuilderContext(BuilderContextBase["Generator.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Generator.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Generator."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Generator", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Generator.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    password_spec: Annotated[Optional[PasswordSpec], Field(alias="passwordSpec")] = None
    """
    PasswordSpec controls the behavior of the password generator.
    """
    uuid_spec: Annotated[Optional[Dict[str, Any]], Field(alias="uuidSpec")] = None
    """
    UUIDSpec controls the behavior of the uuid generator.
    """


class ClusterGeneratorSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ClusterGeneratorSpec"]:
            return ClusterGeneratorSpec

        def build(self) -> "ClusterGeneratorSpec":
            return ClusterGeneratorSpec(**self._attrs)

        @overload
        def generator(
            self, value_or_callback: Optional[Generator], /
        ) -> "ClusterGeneratorSpec.Builder": ...

        @overload
        def generator(
            self,
            value_or_callback: Callable[[Generator.Builder], Generator.Builder | Generator],
            /,
        ) -> "ClusterGeneratorSpec.Builder": ...

        @overload
        def generator(self, value_or_callback: Never = ...) -> "Generator.BuilderContext": ...

        def generator(self, value_or_callback=None, /):
            """
            Generator the spec for this generator, must match the kind.
            """
            if self._in_context and value_or_callback is None:
                context = Generator.BuilderContext()
                context._parent_builder = self
                context._field_name = "generator"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Generator.builder())
                if isinstance(output, Generator.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("generator", value)

        def kind(self, value: Literal["Password", "UUID"], /) -> Self:
            """
            Kind the kind of this generator.
            """
            return self._set("kind", value)

    class BuilderContext(BuilderContextBase["ClusterGeneratorSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ClusterGeneratorSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ClusterGeneratorSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ClusterGeneratorSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ClusterGeneratorSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    generator: Optional[Generator] = None
    """
    Generator the spec for this generator, must match the kind.
    """
    kind: Literal["Password", "UUID"]
    """
    Kind the kind of this generator.
    """


class AwsIamAuth(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AwsIamAuth"]:
            return AwsIamAuth

        def build(self) -> "AwsIamAuth":
            return AwsIamAuth(**self._attrs)

        def identity_id(self, value: str, /) -> Self:
            return self._set("identity_id", value)

    class BuilderContext(BuilderContextBase["AwsIamAuth.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AwsIamAuth.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AwsIamAuth."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AwsIamAuth", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AwsIamAuth.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    identity_id: Annotated[str, Field(alias="identityId")]


class AzureAuth(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AzureAuth"]:
            return AzureAuth

        def build(self) -> "AzureAuth":
            return AzureAuth(**self._attrs)

        def identity_id(self, value: str, /) -> Self:
            return self._set("identity_id", value)

        def resource(self, value: Optional[str], /) -> Self:
            return self._set("resource", value)

    class BuilderContext(BuilderContextBase["AzureAuth.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AzureAuth.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AzureAuth."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AzureAuth", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AzureAuth.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    identity_id: Annotated[str, Field(alias="identityId")]
    resource: Optional[str] = None


class GcpIamAuth(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["GcpIamAuth"]:
            return GcpIamAuth

        def build(self) -> "GcpIamAuth":
            return GcpIamAuth(**self._attrs)

        def identity_id(self, value: str, /) -> Self:
            return self._set("identity_id", value)

        def service_account_key_file_path(self, value: str, /) -> Self:
            return self._set("service_account_key_file_path", value)

    class BuilderContext(BuilderContextBase["GcpIamAuth.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = GcpIamAuth.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for GcpIamAuth."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["GcpIamAuth", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use GcpIamAuth.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    identity_id: Annotated[str, Field(alias="identityId")]
    service_account_key_file_path: Annotated[str, Field(alias="serviceAccountKeyFilePath")]


class GcpIdTokenAuth(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["GcpIdTokenAuth"]:
            return GcpIdTokenAuth

        def build(self) -> "GcpIdTokenAuth":
            return GcpIdTokenAuth(**self._attrs)

        def identity_id(self, value: str, /) -> Self:
            return self._set("identity_id", value)

    class BuilderContext(BuilderContextBase["GcpIdTokenAuth.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = GcpIdTokenAuth.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for GcpIdTokenAuth."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["GcpIdTokenAuth", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use GcpIdTokenAuth.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    identity_id: Annotated[str, Field(alias="identityId")]


class ServiceAccountRef(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ServiceAccountRef"]:
            return ServiceAccountRef

        def build(self) -> "ServiceAccountRef":
            return ServiceAccountRef(**self._attrs)

        def name(self, value: str, /) -> Self:
            return self._set("name", value)

        def namespace(self, value: str, /) -> Self:
            return self._set("namespace", value)

    class BuilderContext(BuilderContextBase["ServiceAccountRef.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ServiceAccountRef.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ServiceAccountRef."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ServiceAccountRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ServiceAccountRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: str
    namespace: str


class KubernetesAuth(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["KubernetesAuth"]:
            return KubernetesAuth

        def build(self) -> "KubernetesAuth":
            return KubernetesAuth(**self._attrs)

        def auto_create_service_account_token(self, value: Optional[bool], /) -> Self:
            """
            Optionally automatically create a service account token for the configured service account.
            If this is set to `true`, the operator will automatically create a service account token for the configured service account. This field is recommended in most cases.
            """
            return self._set("auto_create_service_account_token", value)

        def identity_id(self, value: str, /) -> Self:
            return self._set("identity_id", value)

        @overload
        def service_account_ref(
            self, value_or_callback: ServiceAccountRef, /
        ) -> "KubernetesAuth.Builder": ...

        @overload
        def service_account_ref(
            self,
            value_or_callback: Callable[
                [ServiceAccountRef.Builder],
                ServiceAccountRef.Builder | ServiceAccountRef,
            ],
            /,
        ) -> "KubernetesAuth.Builder": ...

        @overload
        def service_account_ref(
            self, value_or_callback: Never = ...
        ) -> "ServiceAccountRef.BuilderContext": ...

        def service_account_ref(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ServiceAccountRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "service_account_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ServiceAccountRef.builder())
                if isinstance(output, ServiceAccountRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("service_account_ref", value)

        def service_account_token_audiences(self, value: Optional[List[str]], /) -> Self:
            """
            The audiences to use for the service account token. This is only relevant if `autoCreateServiceAccountToken` is true.
            """
            return self._set("service_account_token_audiences", value)

    class BuilderContext(BuilderContextBase["KubernetesAuth.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = KubernetesAuth.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for KubernetesAuth."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["KubernetesAuth", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use KubernetesAuth.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    auto_create_service_account_token: Annotated[
        Optional[bool], Field(alias="autoCreateServiceAccountToken")
    ] = None
    """
    Optionally automatically create a service account token for the configured service account.
    If this is set to `true`, the operator will automatically create a service account token for the configured service account. This field is recommended in most cases.
    """
    identity_id: Annotated[str, Field(alias="identityId")]
    service_account_ref: Annotated[ServiceAccountRef, Field(alias="serviceAccountRef")]
    service_account_token_audiences: Annotated[
        Optional[List[str]], Field(alias="serviceAccountTokenAudiences")
    ] = None
    """
    The audiences to use for the service account token. This is only relevant if `autoCreateServiceAccountToken` is true.
    """


class CredentialsRef(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["CredentialsRef"]:
            return CredentialsRef

        def build(self) -> "CredentialsRef":
            return CredentialsRef(**self._attrs)

        def secret_name(self, value: str, /) -> Self:
            """
            The name of the Kubernetes Secret
            """
            return self._set("secret_name", value)

        def secret_namespace(self, value: str, /) -> Self:
            """
            The name space where the Kubernetes Secret is located
            """
            return self._set("secret_namespace", value)

    class BuilderContext(BuilderContextBase["CredentialsRef.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = CredentialsRef.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for CredentialsRef."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["CredentialsRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use CredentialsRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    secret_name: Annotated[str, Field(alias="secretName")]
    """
    The name of the Kubernetes Secret
    """
    secret_namespace: Annotated[str, Field(alias="secretNamespace")]
    """
    The name space where the Kubernetes Secret is located
    """


class LdapAuth(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["LdapAuth"]:
            return LdapAuth

        def build(self) -> "LdapAuth":
            return LdapAuth(**self._attrs)

        @overload
        def credentials_ref(self, value_or_callback: CredentialsRef, /) -> "LdapAuth.Builder": ...

        @overload
        def credentials_ref(
            self,
            value_or_callback: Callable[
                [CredentialsRef.Builder], CredentialsRef.Builder | CredentialsRef
            ],
            /,
        ) -> "LdapAuth.Builder": ...

        @overload
        def credentials_ref(
            self, value_or_callback: Never = ...
        ) -> "CredentialsRef.BuilderContext": ...

        def credentials_ref(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = CredentialsRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "credentials_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(CredentialsRef.builder())
                if isinstance(output, CredentialsRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("credentials_ref", value)

        def identity_id(self, value: str, /) -> Self:
            return self._set("identity_id", value)

    class BuilderContext(BuilderContextBase["LdapAuth.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = LdapAuth.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for LdapAuth."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["LdapAuth", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use LdapAuth.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    credentials_ref: Annotated[CredentialsRef, Field(alias="credentialsRef")]
    identity_id: Annotated[str, Field(alias="identityId")]


class UniversalAuth(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["UniversalAuth"]:
            return UniversalAuth

        def build(self) -> "UniversalAuth":
            return UniversalAuth(**self._attrs)

        @overload
        def credentials_ref(
            self, value_or_callback: CredentialsRef, /
        ) -> "UniversalAuth.Builder": ...

        @overload
        def credentials_ref(
            self,
            value_or_callback: Callable[
                [CredentialsRef.Builder], CredentialsRef.Builder | CredentialsRef
            ],
            /,
        ) -> "UniversalAuth.Builder": ...

        @overload
        def credentials_ref(
            self, value_or_callback: Never = ...
        ) -> "CredentialsRef.BuilderContext": ...

        def credentials_ref(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = CredentialsRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "credentials_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(CredentialsRef.builder())
                if isinstance(output, CredentialsRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("credentials_ref", value)

    class BuilderContext(BuilderContextBase["UniversalAuth.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = UniversalAuth.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for UniversalAuth."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["UniversalAuth", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use UniversalAuth.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    credentials_ref: Annotated[CredentialsRef, Field(alias="credentialsRef")]


class Authentication(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Authentication"]:
            return Authentication

        def build(self) -> "Authentication":
            return Authentication(**self._attrs)

        @overload
        def aws_iam_auth(
            self, value_or_callback: Optional[AwsIamAuth], /
        ) -> "Authentication.Builder": ...

        @overload
        def aws_iam_auth(
            self,
            value_or_callback: Callable[[AwsIamAuth.Builder], AwsIamAuth.Builder | AwsIamAuth],
            /,
        ) -> "Authentication.Builder": ...

        @overload
        def aws_iam_auth(self, value_or_callback: Never = ...) -> "AwsIamAuth.BuilderContext": ...

        def aws_iam_auth(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = AwsIamAuth.BuilderContext()
                context._parent_builder = self
                context._field_name = "aws_iam_auth"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AwsIamAuth.builder())
                if isinstance(output, AwsIamAuth.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("aws_iam_auth", value)

        @overload
        def azure_auth(
            self, value_or_callback: Optional[AzureAuth], /
        ) -> "Authentication.Builder": ...

        @overload
        def azure_auth(
            self,
            value_or_callback: Callable[[AzureAuth.Builder], AzureAuth.Builder | AzureAuth],
            /,
        ) -> "Authentication.Builder": ...

        @overload
        def azure_auth(self, value_or_callback: Never = ...) -> "AzureAuth.BuilderContext": ...

        def azure_auth(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = AzureAuth.BuilderContext()
                context._parent_builder = self
                context._field_name = "azure_auth"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AzureAuth.builder())
                if isinstance(output, AzureAuth.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("azure_auth", value)

        @overload
        def gcp_iam_auth(
            self, value_or_callback: Optional[GcpIamAuth], /
        ) -> "Authentication.Builder": ...

        @overload
        def gcp_iam_auth(
            self,
            value_or_callback: Callable[[GcpIamAuth.Builder], GcpIamAuth.Builder | GcpIamAuth],
            /,
        ) -> "Authentication.Builder": ...

        @overload
        def gcp_iam_auth(self, value_or_callback: Never = ...) -> "GcpIamAuth.BuilderContext": ...

        def gcp_iam_auth(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = GcpIamAuth.BuilderContext()
                context._parent_builder = self
                context._field_name = "gcp_iam_auth"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(GcpIamAuth.builder())
                if isinstance(output, GcpIamAuth.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("gcp_iam_auth", value)

        @overload
        def gcp_id_token_auth(
            self, value_or_callback: Optional[GcpIdTokenAuth], /
        ) -> "Authentication.Builder": ...

        @overload
        def gcp_id_token_auth(
            self,
            value_or_callback: Callable[
                [GcpIdTokenAuth.Builder], GcpIdTokenAuth.Builder | GcpIdTokenAuth
            ],
            /,
        ) -> "Authentication.Builder": ...

        @overload
        def gcp_id_token_auth(
            self, value_or_callback: Never = ...
        ) -> "GcpIdTokenAuth.BuilderContext": ...

        def gcp_id_token_auth(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = GcpIdTokenAuth.BuilderContext()
                context._parent_builder = self
                context._field_name = "gcp_id_token_auth"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(GcpIdTokenAuth.builder())
                if isinstance(output, GcpIdTokenAuth.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("gcp_id_token_auth", value)

        @overload
        def kubernetes_auth(
            self, value_or_callback: Optional[KubernetesAuth], /
        ) -> "Authentication.Builder": ...

        @overload
        def kubernetes_auth(
            self,
            value_or_callback: Callable[
                [KubernetesAuth.Builder], KubernetesAuth.Builder | KubernetesAuth
            ],
            /,
        ) -> "Authentication.Builder": ...

        @overload
        def kubernetes_auth(
            self, value_or_callback: Never = ...
        ) -> "KubernetesAuth.BuilderContext": ...

        def kubernetes_auth(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = KubernetesAuth.BuilderContext()
                context._parent_builder = self
                context._field_name = "kubernetes_auth"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(KubernetesAuth.builder())
                if isinstance(output, KubernetesAuth.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("kubernetes_auth", value)

        @overload
        def ldap_auth(
            self, value_or_callback: Optional[LdapAuth], /
        ) -> "Authentication.Builder": ...

        @overload
        def ldap_auth(
            self,
            value_or_callback: Callable[[LdapAuth.Builder], LdapAuth.Builder | LdapAuth],
            /,
        ) -> "Authentication.Builder": ...

        @overload
        def ldap_auth(self, value_or_callback: Never = ...) -> "LdapAuth.BuilderContext": ...

        def ldap_auth(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = LdapAuth.BuilderContext()
                context._parent_builder = self
                context._field_name = "ldap_auth"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(LdapAuth.builder())
                if isinstance(output, LdapAuth.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("ldap_auth", value)

        @overload
        def universal_auth(
            self, value_or_callback: Optional[UniversalAuth], /
        ) -> "Authentication.Builder": ...

        @overload
        def universal_auth(
            self,
            value_or_callback: Callable[
                [UniversalAuth.Builder], UniversalAuth.Builder | UniversalAuth
            ],
            /,
        ) -> "Authentication.Builder": ...

        @overload
        def universal_auth(
            self, value_or_callback: Never = ...
        ) -> "UniversalAuth.BuilderContext": ...

        def universal_auth(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = UniversalAuth.BuilderContext()
                context._parent_builder = self
                context._field_name = "universal_auth"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(UniversalAuth.builder())
                if isinstance(output, UniversalAuth.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("universal_auth", value)

    class BuilderContext(BuilderContextBase["Authentication.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Authentication.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Authentication."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Authentication", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Authentication.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    aws_iam_auth: Annotated[Optional[AwsIamAuth], Field(alias="awsIamAuth")] = None
    azure_auth: Annotated[Optional[AzureAuth], Field(alias="azureAuth")] = None
    gcp_iam_auth: Annotated[Optional[GcpIamAuth], Field(alias="gcpIamAuth")] = None
    gcp_id_token_auth: Annotated[Optional[GcpIdTokenAuth], Field(alias="gcpIdTokenAuth")] = None
    kubernetes_auth: Annotated[Optional[KubernetesAuth], Field(alias="kubernetesAuth")] = None
    ldap_auth: Annotated[Optional[LdapAuth], Field(alias="ldapAuth")] = None
    universal_auth: Annotated[Optional[UniversalAuth], Field(alias="universalAuth")] = None


class DynamicSecret(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["DynamicSecret"]:
            return DynamicSecret

        def build(self) -> "DynamicSecret":
            return DynamicSecret(**self._attrs)

        def environment_slug(self, value: str, /) -> Self:
            return self._set("environment_slug", value)

        def project_id(self, value: Optional[str], /) -> Self:
            return self._set("project_id", value)

        def project_slug(self, value: Optional[str], /) -> Self:
            return self._set("project_slug", value)

        def secret_name(self, value: str, /) -> Self:
            return self._set("secret_name", value)

        def secrets_path(self, value: str, /) -> Self:
            return self._set("secrets_path", value)

    class BuilderContext(BuilderContextBase["DynamicSecret.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DynamicSecret.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DynamicSecret."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["DynamicSecret", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use DynamicSecret.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    environment_slug: Annotated[str, Field(alias="environmentSlug")]
    project_id: Annotated[Optional[str], Field(alias="projectId")] = None
    project_slug: Annotated[Optional[str], Field(alias="projectSlug")] = None
    secret_name: Annotated[str, Field(alias="secretName")]
    secrets_path: Annotated[str, Field(alias="secretsPath")]


class Template(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Template"]:
            return Template

        def build(self) -> "Template":
            return Template(**self._attrs)

        def data(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            The template key values
            """
            return self._set("data", value)

        def include_all_secrets(self, value: Optional[bool], /) -> Self:
            """
            This injects all retrieved secrets into the top level of your template.
            Secrets defined in the template will take precedence over the injected ones.
            """
            return self._set("include_all_secrets", value)

    class BuilderContext(BuilderContextBase["Template.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Template.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Template."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Template", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Template.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    data: Optional[Dict[str, str]] = None
    """
    The template key values
    """
    include_all_secrets: Annotated[Optional[bool], Field(alias="includeAllSecrets")] = None
    """
    This injects all retrieved secrets into the top level of your template.
    Secrets defined in the template will take precedence over the injected ones.
    """


class ManagedSecretReference(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ManagedSecretReference"]:
            return ManagedSecretReference

        def build(self) -> "ManagedSecretReference":
            return ManagedSecretReference(**self._attrs)

        def creation_policy(self, value: Optional[str], /) -> Self:
            """
            The Kubernetes Secret creation policy.
            Enum with values: 'Owner', 'Orphan'.
            Owner creates the secret and sets .metadata.ownerReferences of the InfisicalSecret CRD that created it.
            Orphan will not set the secret owner. This will result in the secret being orphaned and not deleted when the resource is deleted.
            """
            return self._set("creation_policy", value)

        def secret_name(self, value: str, /) -> Self:
            """
            The name of the Kubernetes Secret
            """
            return self._set("secret_name", value)

        def secret_namespace(self, value: str, /) -> Self:
            """
            The name space where the Kubernetes Secret is located
            """
            return self._set("secret_namespace", value)

        def secret_type(self, value: Optional[str], /) -> Self:
            """
            The Kubernetes Secret type (experimental feature). More info: https://kubernetes.io/docs/concepts/configuration/secret/#secret-types
            """
            return self._set("secret_type", value)

        @overload
        def template(
            self, value_or_callback: Optional[Template], /
        ) -> "ManagedSecretReference.Builder": ...

        @overload
        def template(
            self,
            value_or_callback: Callable[[Template.Builder], Template.Builder | Template],
            /,
        ) -> "ManagedSecretReference.Builder": ...

        @overload
        def template(self, value_or_callback: Never = ...) -> "Template.BuilderContext": ...

        def template(self, value_or_callback=None, /):
            """
            The template to transform the secret data
            """
            if self._in_context and value_or_callback is None:
                context = Template.BuilderContext()
                context._parent_builder = self
                context._field_name = "template"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Template.builder())
                if isinstance(output, Template.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("template", value)

    class BuilderContext(BuilderContextBase["ManagedSecretReference.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ManagedSecretReference.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ManagedSecretReference."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ManagedSecretReference", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ManagedSecretReference.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    creation_policy: Annotated[Optional[str], Field(alias="creationPolicy")] = "Orphan"
    """
    The Kubernetes Secret creation policy.
    Enum with values: 'Owner', 'Orphan'.
    Owner creates the secret and sets .metadata.ownerReferences of the InfisicalSecret CRD that created it.
    Orphan will not set the secret owner. This will result in the secret being orphaned and not deleted when the resource is deleted.
    """
    secret_name: Annotated[str, Field(alias="secretName")]
    """
    The name of the Kubernetes Secret
    """
    secret_namespace: Annotated[str, Field(alias="secretNamespace")]
    """
    The name space where the Kubernetes Secret is located
    """
    secret_type: Annotated[Optional[str], Field(alias="secretType")] = "Opaque"
    """
    The Kubernetes Secret type (experimental feature). More info: https://kubernetes.io/docs/concepts/configuration/secret/#secret-types
    """
    template: Optional[Template] = None
    """
    The template to transform the secret data
    """


class CaRef(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["CaRef"]:
            return CaRef

        def build(self) -> "CaRef":
            return CaRef(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            The name of the secret property with the CA certificate value
            """
            return self._set("key", value)

        def secret_name(self, value: str, /) -> Self:
            """
            The name of the Kubernetes Secret
            """
            return self._set("secret_name", value)

        def secret_namespace(self, value: str, /) -> Self:
            """
            The namespace where the Kubernetes Secret is located
            """
            return self._set("secret_namespace", value)

    class BuilderContext(BuilderContextBase["CaRef.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = CaRef.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for CaRef."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["CaRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use CaRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: str
    """
    The name of the secret property with the CA certificate value
    """
    secret_name: Annotated[str, Field(alias="secretName")]
    """
    The name of the Kubernetes Secret
    """
    secret_namespace: Annotated[str, Field(alias="secretNamespace")]
    """
    The namespace where the Kubernetes Secret is located
    """


class Tls(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Tls"]:
            return Tls

        def build(self) -> "Tls":
            return Tls(**self._attrs)

        @overload
        def ca_ref(self, value_or_callback: Optional[CaRef], /) -> "Tls.Builder": ...

        @overload
        def ca_ref(
            self, value_or_callback: Callable[[CaRef.Builder], CaRef.Builder | CaRef], /
        ) -> "Tls.Builder": ...

        @overload
        def ca_ref(self, value_or_callback: Never = ...) -> "CaRef.BuilderContext": ...

        def ca_ref(self, value_or_callback=None, /):
            """
            Reference to secret containing CA cert
            """
            if self._in_context and value_or_callback is None:
                context = CaRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "ca_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(CaRef.builder())
                if isinstance(output, CaRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("ca_ref", value)

    class BuilderContext(BuilderContextBase["Tls.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Tls.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Tls."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Tls", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Tls.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    ca_ref: Annotated[Optional[CaRef], Field(alias="caRef")] = None
    """
    Reference to secret containing CA cert
    """


class InfisicalDynamicSecretSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["InfisicalDynamicSecretSpec"]:
            return InfisicalDynamicSecretSpec

        def build(self) -> "InfisicalDynamicSecretSpec":
            return InfisicalDynamicSecretSpec(**self._attrs)

        @overload
        def authentication(
            self, value_or_callback: Authentication, /
        ) -> "InfisicalDynamicSecretSpec.Builder": ...

        @overload
        def authentication(
            self,
            value_or_callback: Callable[
                [Authentication.Builder], Authentication.Builder | Authentication
            ],
            /,
        ) -> "InfisicalDynamicSecretSpec.Builder": ...

        @overload
        def authentication(
            self, value_or_callback: Never = ...
        ) -> "Authentication.BuilderContext": ...

        def authentication(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = Authentication.BuilderContext()
                context._parent_builder = self
                context._field_name = "authentication"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Authentication.builder())
                if isinstance(output, Authentication.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("authentication", value)

        @overload
        def dynamic_secret(
            self, value_or_callback: DynamicSecret, /
        ) -> "InfisicalDynamicSecretSpec.Builder": ...

        @overload
        def dynamic_secret(
            self,
            value_or_callback: Callable[
                [DynamicSecret.Builder], DynamicSecret.Builder | DynamicSecret
            ],
            /,
        ) -> "InfisicalDynamicSecretSpec.Builder": ...

        @overload
        def dynamic_secret(
            self, value_or_callback: Never = ...
        ) -> "DynamicSecret.BuilderContext": ...

        def dynamic_secret(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = DynamicSecret.BuilderContext()
                context._parent_builder = self
                context._field_name = "dynamic_secret"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(DynamicSecret.builder())
                if isinstance(output, DynamicSecret.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("dynamic_secret", value)

        def host_api(self, value: Optional[str], /) -> Self:
            return self._set("host_api", value)

        def lease_revocation_policy(self, value: str, /) -> Self:
            return self._set("lease_revocation_policy", value)

        def lease_ttl(self, value: str, /) -> Self:
            return self._set("lease_ttl", value)

        @overload
        def managed_secret_reference(
            self, value_or_callback: ManagedSecretReference, /
        ) -> "InfisicalDynamicSecretSpec.Builder": ...

        @overload
        def managed_secret_reference(
            self,
            value_or_callback: Callable[
                [ManagedSecretReference.Builder],
                ManagedSecretReference.Builder | ManagedSecretReference,
            ],
            /,
        ) -> "InfisicalDynamicSecretSpec.Builder": ...

        @overload
        def managed_secret_reference(
            self, value_or_callback: Never = ...
        ) -> "ManagedSecretReference.BuilderContext": ...

        def managed_secret_reference(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ManagedSecretReference.BuilderContext()
                context._parent_builder = self
                context._field_name = "managed_secret_reference"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ManagedSecretReference.builder())
                if isinstance(output, ManagedSecretReference.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("managed_secret_reference", value)

        @overload
        def tls(
            self, value_or_callback: Optional[Tls], /
        ) -> "InfisicalDynamicSecretSpec.Builder": ...

        @overload
        def tls(
            self, value_or_callback: Callable[[Tls.Builder], Tls.Builder | Tls], /
        ) -> "InfisicalDynamicSecretSpec.Builder": ...

        @overload
        def tls(self, value_or_callback: Never = ...) -> "Tls.BuilderContext": ...

        def tls(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = Tls.BuilderContext()
                context._parent_builder = self
                context._field_name = "tls"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Tls.builder())
                if isinstance(output, Tls.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("tls", value)

    class BuilderContext(BuilderContextBase["InfisicalDynamicSecretSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = InfisicalDynamicSecretSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for InfisicalDynamicSecretSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["InfisicalDynamicSecretSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use InfisicalDynamicSecretSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    authentication: Authentication
    dynamic_secret: Annotated[DynamicSecret, Field(alias="dynamicSecret")]
    host_api: Annotated[Optional[str], Field(alias="hostAPI")] = None
    lease_revocation_policy: Annotated[str, Field(alias="leaseRevocationPolicy")]
    lease_ttl: Annotated[str, Field(alias="leaseTTL")]
    managed_secret_reference: Annotated[
        ManagedSecretReference, Field(alias="managedSecretReference")
    ]
    tls: Optional[Tls] = None


class Condition(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Condition"]:
            return Condition

        def build(self) -> "Condition":
            return Condition(**self._attrs)

        def last_transition_time(self, value: AwareDatetime, /) -> Self:
            """
            lastTransitionTime is the last time the condition transitioned from one status to another.
            This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
            """
            return self._set("last_transition_time", value)

        def message(self, value: str, /) -> Self:
            """
            message is a human readable message indicating details about the transition.
            This may be an empty string.
            """
            return self._set("message", value)

        def observed_generation(self, value: Optional[int], /) -> Self:
            """
            observedGeneration represents the .metadata.generation that the condition was set based upon.
            For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
            with respect to the current state of the instance.
            """
            return self._set("observed_generation", value)

        def reason(self, value: str, /) -> Self:
            """
            reason contains a programmatic identifier indicating the reason for the condition's last transition.
            Producers of specific condition types may define expected values and meanings for this field,
            and whether the values are considered a guaranteed API.
            The value should be a CamelCase string.
            This field may not be empty.
            """
            return self._set("reason", value)

        def status(self, value: Literal["True", "False", "Unknown"], /) -> Self:
            """
            status of the condition, one of True, False, Unknown.
            """
            return self._set("status", value)

        def type(self, value: str, /) -> Self:
            """
            type of condition in CamelCase or in foo.example.com/CamelCase.
            """
            return self._set("type", value)

    class BuilderContext(BuilderContextBase["Condition.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Condition.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Condition."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Condition", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Condition.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    last_transition_time: Annotated[AwareDatetime, Field(alias="lastTransitionTime")]
    """
    lastTransitionTime is the last time the condition transitioned from one status to another.
    This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
    """
    message: Annotated[str, Field(max_length=32768)]
    """
    message is a human readable message indicating details about the transition.
    This may be an empty string.
    """
    observed_generation: Annotated[Optional[int], Field(alias="observedGeneration", ge=0)] = None
    """
    observedGeneration represents the .metadata.generation that the condition was set based upon.
    For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
    with respect to the current state of the instance.
    """
    reason: Annotated[
        str,
        Field(
            max_length=1024,
            min_length=1,
            pattern="^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$",
        ),
    ]
    """
    reason contains a programmatic identifier indicating the reason for the condition's last transition.
    Producers of specific condition types may define expected values and meanings for this field,
    and whether the values are considered a guaranteed API.
    The value should be a CamelCase string.
    This field may not be empty.
    """
    status: Literal["True", "False", "Unknown"]
    """
    status of the condition, one of True, False, Unknown.
    """
    type: Annotated[
        str,
        Field(
            max_length=316,
            pattern="^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$",
        ),
    ]
    """
    type of condition in CamelCase or in foo.example.com/CamelCase.
    """


class Lease(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Lease"]:
            return Lease

        def build(self) -> "Lease":
            return Lease(**self._attrs)

        def creation_timestamp(self, value: AwareDatetime, /) -> Self:
            return self._set("creation_timestamp", value)

        def expires_at(self, value: AwareDatetime, /) -> Self:
            return self._set("expires_at", value)

        def id(self, value: str, /) -> Self:
            return self._set("id", value)

        def version(self, value: int, /) -> Self:
            return self._set("version", value)

    class BuilderContext(BuilderContextBase["Lease.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Lease.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Lease."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Lease", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Lease.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    creation_timestamp: Annotated[AwareDatetime, Field(alias="creationTimestamp")]
    expires_at: Annotated[AwareDatetime, Field(alias="expiresAt")]
    id: str
    version: int


class InfisicalDynamicSecretStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["InfisicalDynamicSecretStatus"]:
            return InfisicalDynamicSecretStatus

        def build(self) -> "InfisicalDynamicSecretStatus":
            return InfisicalDynamicSecretStatus(**self._attrs)

        @overload
        def conditions(
            self, value_or_callback: List[Condition], /
        ) -> "InfisicalDynamicSecretStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Condition, Condition.Builder]],
                GenericListBuilder[Condition, Condition.Builder] | List[Condition],
            ],
            /,
        ) -> "InfisicalDynamicSecretStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        def dynamic_secret_id(self, value: Optional[str], /) -> Self:
            return self._set("dynamic_secret_id", value)

        @overload
        def lease(
            self, value_or_callback: Optional[Lease], /
        ) -> "InfisicalDynamicSecretStatus.Builder": ...

        @overload
        def lease(
            self, value_or_callback: Callable[[Lease.Builder], Lease.Builder | Lease], /
        ) -> "InfisicalDynamicSecretStatus.Builder": ...

        @overload
        def lease(self, value_or_callback: Never = ...) -> "Lease.BuilderContext": ...

        def lease(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = Lease.BuilderContext()
                context._parent_builder = self
                context._field_name = "lease"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Lease.builder())
                if isinstance(output, Lease.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("lease", value)

        def max_ttl(self, value: Optional[str], /) -> Self:
            """
            The MaxTTL can be null, if it's null, there's no max TTL and we should never have to renew.
            """
            return self._set("max_ttl", value)

    class BuilderContext(BuilderContextBase["InfisicalDynamicSecretStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = InfisicalDynamicSecretStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for InfisicalDynamicSecretStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["InfisicalDynamicSecretStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use InfisicalDynamicSecretStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    conditions: List[Condition]
    dynamic_secret_id: Annotated[Optional[str], Field(alias="dynamicSecretId")] = None
    lease: Optional[Lease] = None
    max_ttl: Annotated[Optional[str], Field(alias="maxTTL")] = None
    """
    The MaxTTL can be null, if it's null, there's no max TTL and we should never have to renew.
    """


class Destination(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Destination"]:
            return Destination

        def build(self) -> "Destination":
            return Destination(**self._attrs)

        def environment_slug(self, value: str, /) -> Self:
            return self._set("environment_slug", value)

        def project_id(self, value: Optional[str], /) -> Self:
            return self._set("project_id", value)

        def project_slug(self, value: Optional[str], /) -> Self:
            return self._set("project_slug", value)

        def secrets_path(self, value: str, /) -> Self:
            return self._set("secrets_path", value)

    class BuilderContext(BuilderContextBase["Destination.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Destination.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Destination."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Destination", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Destination.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    environment_slug: Annotated[str, Field(alias="environmentSlug")]
    project_id: Annotated[Optional[str], Field(alias="projectId")] = None
    project_slug: Annotated[Optional[str], Field(alias="projectSlug")] = None
    secrets_path: Annotated[str, Field(alias="secretsPath")]


class Kind(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Kind"]:
            return Kind

        def build(self) -> "Kind":
            return Kind(**self._attrs)

    class BuilderContext(BuilderContextBase["Kind.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Kind.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Kind."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Kind", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Kind.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    pass


class GeneratorRef(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["GeneratorRef"]:
            return GeneratorRef

        def build(self) -> "GeneratorRef":
            return GeneratorRef(**self._attrs)

        @overload
        def kind(self, value_or_callback: Kind, /) -> "GeneratorRef.Builder": ...

        @overload
        def kind(
            self, value_or_callback: Callable[[Kind.Builder], Kind.Builder | Kind], /
        ) -> "GeneratorRef.Builder": ...

        @overload
        def kind(self, value_or_callback: Never = ...) -> "Kind.BuilderContext": ...

        def kind(self, value_or_callback=None, /):
            """
            Specify the Kind of the generator resource
            """
            if self._in_context and value_or_callback is None:
                context = Kind.BuilderContext()
                context._parent_builder = self
                context._field_name = "kind"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Kind.builder())
                if isinstance(output, Kind.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("kind", value)

        def name(self, value: str, /) -> Self:
            return self._set("name", value)

    class BuilderContext(BuilderContextBase["GeneratorRef.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = GeneratorRef.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for GeneratorRef."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["GeneratorRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use GeneratorRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    kind: Kind
    """
    Specify the Kind of the generator resource
    """
    name: str


class GeneratorModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["GeneratorModel"]:
            return GeneratorModel

        def build(self) -> "GeneratorModel":
            return GeneratorModel(**self._attrs)

        def destination_secret_name(self, value: str, /) -> Self:
            return self._set("destination_secret_name", value)

        @overload
        def generator_ref(self, value_or_callback: GeneratorRef, /) -> "GeneratorModel.Builder": ...

        @overload
        def generator_ref(
            self,
            value_or_callback: Callable[
                [GeneratorRef.Builder], GeneratorRef.Builder | GeneratorRef
            ],
            /,
        ) -> "GeneratorModel.Builder": ...

        @overload
        def generator_ref(
            self, value_or_callback: Never = ...
        ) -> "GeneratorRef.BuilderContext": ...

        def generator_ref(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = GeneratorRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "generator_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(GeneratorRef.builder())
                if isinstance(output, GeneratorRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("generator_ref", value)

    class BuilderContext(BuilderContextBase["GeneratorModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = GeneratorModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for GeneratorModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["GeneratorModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use GeneratorModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    destination_secret_name: Annotated[str, Field(alias="destinationSecretName")]
    generator_ref: Annotated[GeneratorRef, Field(alias="generatorRef")]


class Secret(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Secret"]:
            return Secret

        def build(self) -> "Secret":
            return Secret(**self._attrs)

        def secret_name(self, value: str, /) -> Self:
            """
            The name of the Kubernetes Secret
            """
            return self._set("secret_name", value)

        def secret_namespace(self, value: str, /) -> Self:
            """
            The name space where the Kubernetes Secret is located
            """
            return self._set("secret_namespace", value)

        @overload
        def template(self, value_or_callback: Optional[Template], /) -> "Secret.Builder": ...

        @overload
        def template(
            self,
            value_or_callback: Callable[[Template.Builder], Template.Builder | Template],
            /,
        ) -> "Secret.Builder": ...

        @overload
        def template(self, value_or_callback: Never = ...) -> "Template.BuilderContext": ...

        def template(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = Template.BuilderContext()
                context._parent_builder = self
                context._field_name = "template"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Template.builder())
                if isinstance(output, Template.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("template", value)

    class BuilderContext(BuilderContextBase["Secret.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Secret.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Secret."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Secret", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Secret.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    secret_name: Annotated[str, Field(alias="secretName")]
    """
    The name of the Kubernetes Secret
    """
    secret_namespace: Annotated[str, Field(alias="secretNamespace")]
    """
    The name space where the Kubernetes Secret is located
    """
    template: Optional[Template] = None


class Push(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Push"]:
            return Push

        def build(self) -> "Push":
            return Push(**self._attrs)

        @overload
        def generators(self, value_or_callback: List[GeneratorModel], /) -> "Push.Builder": ...

        @overload
        def generators(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[GeneratorModel, GeneratorModel.Builder]],
                GenericListBuilder[GeneratorModel, GeneratorModel.Builder] | List[GeneratorModel],
            ],
            /,
        ) -> "Push.Builder": ...

        @overload
        def generators(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[GeneratorModel.Builder]: ...

        def generators(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[GeneratorModel.Builder]()
                context._parent_builder = self
                context._field_name = "generators"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(GeneratorModel.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("generators", value)

        @overload
        def secret(self, value_or_callback: Optional[Secret], /) -> "Push.Builder": ...

        @overload
        def secret(
            self,
            value_or_callback: Callable[[Secret.Builder], Secret.Builder | Secret],
            /,
        ) -> "Push.Builder": ...

        @overload
        def secret(self, value_or_callback: Never = ...) -> "Secret.BuilderContext": ...

        def secret(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = Secret.BuilderContext()
                context._parent_builder = self
                context._field_name = "secret"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Secret.builder())
                if isinstance(output, Secret.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("secret", value)

    class BuilderContext(BuilderContextBase["Push.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Push.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Push."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Push", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Push.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    generators: Optional[List[GeneratorModel]] = None
    secret: Optional[Secret] = None


class InfisicalPushSecretSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["InfisicalPushSecretSpec"]:
            return InfisicalPushSecretSpec

        def build(self) -> "InfisicalPushSecretSpec":
            return InfisicalPushSecretSpec(**self._attrs)

        @overload
        def authentication(
            self, value_or_callback: Optional[Authentication], /
        ) -> "InfisicalPushSecretSpec.Builder": ...

        @overload
        def authentication(
            self,
            value_or_callback: Callable[
                [Authentication.Builder], Authentication.Builder | Authentication
            ],
            /,
        ) -> "InfisicalPushSecretSpec.Builder": ...

        @overload
        def authentication(
            self, value_or_callback: Never = ...
        ) -> "Authentication.BuilderContext": ...

        def authentication(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = Authentication.BuilderContext()
                context._parent_builder = self
                context._field_name = "authentication"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Authentication.builder())
                if isinstance(output, Authentication.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("authentication", value)

        def deletion_policy(self, value: Optional[str], /) -> Self:
            return self._set("deletion_policy", value)

        @overload
        def destination(
            self, value_or_callback: Destination, /
        ) -> "InfisicalPushSecretSpec.Builder": ...

        @overload
        def destination(
            self,
            value_or_callback: Callable[[Destination.Builder], Destination.Builder | Destination],
            /,
        ) -> "InfisicalPushSecretSpec.Builder": ...

        @overload
        def destination(self, value_or_callback: Never = ...) -> "Destination.BuilderContext": ...

        def destination(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = Destination.BuilderContext()
                context._parent_builder = self
                context._field_name = "destination"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Destination.builder())
                if isinstance(output, Destination.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("destination", value)

        def host_api(self, value: Optional[str], /) -> Self:
            """
            Infisical host to pull secrets from
            """
            return self._set("host_api", value)

        @overload
        def push(self, value_or_callback: Push, /) -> "InfisicalPushSecretSpec.Builder": ...

        @overload
        def push(
            self, value_or_callback: Callable[[Push.Builder], Push.Builder | Push], /
        ) -> "InfisicalPushSecretSpec.Builder": ...

        @overload
        def push(self, value_or_callback: Never = ...) -> "Push.BuilderContext": ...

        def push(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = Push.BuilderContext()
                context._parent_builder = self
                context._field_name = "push"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Push.builder())
                if isinstance(output, Push.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("push", value)

        def resync_interval(self, value: Optional[str], /) -> Self:
            return self._set("resync_interval", value)

        @overload
        def tls(self, value_or_callback: Optional[Tls], /) -> "InfisicalPushSecretSpec.Builder": ...

        @overload
        def tls(
            self, value_or_callback: Callable[[Tls.Builder], Tls.Builder | Tls], /
        ) -> "InfisicalPushSecretSpec.Builder": ...

        @overload
        def tls(self, value_or_callback: Never = ...) -> "Tls.BuilderContext": ...

        def tls(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = Tls.BuilderContext()
                context._parent_builder = self
                context._field_name = "tls"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Tls.builder())
                if isinstance(output, Tls.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("tls", value)

        def update_policy(self, value: Optional[str], /) -> Self:
            return self._set("update_policy", value)

    class BuilderContext(BuilderContextBase["InfisicalPushSecretSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = InfisicalPushSecretSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for InfisicalPushSecretSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["InfisicalPushSecretSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use InfisicalPushSecretSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    authentication: Optional[Authentication] = None
    deletion_policy: Annotated[Optional[str], Field(alias="deletionPolicy")] = None
    destination: Destination
    host_api: Annotated[Optional[str], Field(alias="hostAPI")] = None
    """
    Infisical host to pull secrets from
    """
    push: Push
    resync_interval: Annotated[Optional[str], Field(alias="resyncInterval")] = None
    tls: Optional[Tls] = None
    update_policy: Annotated[Optional[str], Field(alias="updatePolicy")] = None


class InfisicalPushSecretStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["InfisicalPushSecretStatus"]:
            return InfisicalPushSecretStatus

        def build(self) -> "InfisicalPushSecretStatus":
            return InfisicalPushSecretStatus(**self._attrs)

        @overload
        def conditions(
            self, value_or_callback: List[Condition], /
        ) -> "InfisicalPushSecretStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Condition, Condition.Builder]],
                GenericListBuilder[Condition, Condition.Builder] | List[Condition],
            ],
            /,
        ) -> "InfisicalPushSecretStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        def managed_secrets(self, value: Dict[str, str], /) -> Self:
            """
            managed secrets is a map where the key is the ID, and the value is the secret key (string[id], string[key] )
            """
            return self._set("managed_secrets", value)

    class BuilderContext(BuilderContextBase["InfisicalPushSecretStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = InfisicalPushSecretStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for InfisicalPushSecretStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["InfisicalPushSecretStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use InfisicalPushSecretStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    conditions: List[Condition]
    managed_secrets: Annotated[Dict[str, str], Field(alias="managedSecrets")]
    """
    managed secrets is a map where the key is the ID, and the value is the secret key (string[id], string[key] )
    """


class SecretsScope(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["SecretsScope"]:
            return SecretsScope

        def build(self) -> "SecretsScope":
            return SecretsScope(**self._attrs)

        def env_slug(self, value: str, /) -> Self:
            return self._set("env_slug", value)

        def project_id(self, value: Optional[str], /) -> Self:
            return self._set("project_id", value)

        def project_slug(self, value: Optional[str], /) -> Self:
            return self._set("project_slug", value)

        def recursive(self, value: Optional[bool], /) -> Self:
            return self._set("recursive", value)

        def secret_name(self, value: Optional[str], /) -> Self:
            return self._set("secret_name", value)

        def secrets_path(self, value: str, /) -> Self:
            return self._set("secrets_path", value)

    class BuilderContext(BuilderContextBase["SecretsScope.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SecretsScope.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SecretsScope."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["SecretsScope", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SecretsScope.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    env_slug: Annotated[str, Field(alias="envSlug")]
    project_id: Annotated[Optional[str], Field(alias="projectId")] = None
    project_slug: Annotated[Optional[str], Field(alias="projectSlug")] = None
    recursive: Optional[bool] = None
    secret_name: Annotated[Optional[str], Field(alias="secretName")] = None
    secrets_path: Annotated[str, Field(alias="secretsPath")]


class AwsIamAuthModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AwsIamAuthModel"]:
            return AwsIamAuthModel

        def build(self) -> "AwsIamAuthModel":
            return AwsIamAuthModel(**self._attrs)

        def identity_id(self, value: str, /) -> Self:
            return self._set("identity_id", value)

        @overload
        def secrets_scope(
            self, value_or_callback: SecretsScope, /
        ) -> "AwsIamAuthModel.Builder": ...

        @overload
        def secrets_scope(
            self,
            value_or_callback: Callable[
                [SecretsScope.Builder], SecretsScope.Builder | SecretsScope
            ],
            /,
        ) -> "AwsIamAuthModel.Builder": ...

        @overload
        def secrets_scope(
            self, value_or_callback: Never = ...
        ) -> "SecretsScope.BuilderContext": ...

        def secrets_scope(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = SecretsScope.BuilderContext()
                context._parent_builder = self
                context._field_name = "secrets_scope"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SecretsScope.builder())
                if isinstance(output, SecretsScope.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("secrets_scope", value)

    class BuilderContext(BuilderContextBase["AwsIamAuthModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AwsIamAuthModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AwsIamAuthModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AwsIamAuthModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AwsIamAuthModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    identity_id: Annotated[str, Field(alias="identityId")]
    secrets_scope: Annotated[SecretsScope, Field(alias="secretsScope")]


class AzureAuthModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AzureAuthModel"]:
            return AzureAuthModel

        def build(self) -> "AzureAuthModel":
            return AzureAuthModel(**self._attrs)

        def identity_id(self, value: str, /) -> Self:
            return self._set("identity_id", value)

        def resource(self, value: Optional[str], /) -> Self:
            return self._set("resource", value)

        @overload
        def secrets_scope(self, value_or_callback: SecretsScope, /) -> "AzureAuthModel.Builder": ...

        @overload
        def secrets_scope(
            self,
            value_or_callback: Callable[
                [SecretsScope.Builder], SecretsScope.Builder | SecretsScope
            ],
            /,
        ) -> "AzureAuthModel.Builder": ...

        @overload
        def secrets_scope(
            self, value_or_callback: Never = ...
        ) -> "SecretsScope.BuilderContext": ...

        def secrets_scope(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = SecretsScope.BuilderContext()
                context._parent_builder = self
                context._field_name = "secrets_scope"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SecretsScope.builder())
                if isinstance(output, SecretsScope.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("secrets_scope", value)

    class BuilderContext(BuilderContextBase["AzureAuthModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AzureAuthModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AzureAuthModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AzureAuthModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AzureAuthModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    identity_id: Annotated[str, Field(alias="identityId")]
    resource: Optional[str] = None
    secrets_scope: Annotated[SecretsScope, Field(alias="secretsScope")]


class GcpIamAuthModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["GcpIamAuthModel"]:
            return GcpIamAuthModel

        def build(self) -> "GcpIamAuthModel":
            return GcpIamAuthModel(**self._attrs)

        def identity_id(self, value: str, /) -> Self:
            return self._set("identity_id", value)

        @overload
        def secrets_scope(
            self, value_or_callback: SecretsScope, /
        ) -> "GcpIamAuthModel.Builder": ...

        @overload
        def secrets_scope(
            self,
            value_or_callback: Callable[
                [SecretsScope.Builder], SecretsScope.Builder | SecretsScope
            ],
            /,
        ) -> "GcpIamAuthModel.Builder": ...

        @overload
        def secrets_scope(
            self, value_or_callback: Never = ...
        ) -> "SecretsScope.BuilderContext": ...

        def secrets_scope(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = SecretsScope.BuilderContext()
                context._parent_builder = self
                context._field_name = "secrets_scope"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SecretsScope.builder())
                if isinstance(output, SecretsScope.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("secrets_scope", value)

        def service_account_key_file_path(self, value: str, /) -> Self:
            return self._set("service_account_key_file_path", value)

    class BuilderContext(BuilderContextBase["GcpIamAuthModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = GcpIamAuthModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for GcpIamAuthModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["GcpIamAuthModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use GcpIamAuthModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    identity_id: Annotated[str, Field(alias="identityId")]
    secrets_scope: Annotated[SecretsScope, Field(alias="secretsScope")]
    service_account_key_file_path: Annotated[str, Field(alias="serviceAccountKeyFilePath")]


class GcpIdTokenAuthModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["GcpIdTokenAuthModel"]:
            return GcpIdTokenAuthModel

        def build(self) -> "GcpIdTokenAuthModel":
            return GcpIdTokenAuthModel(**self._attrs)

        def identity_id(self, value: str, /) -> Self:
            return self._set("identity_id", value)

        @overload
        def secrets_scope(
            self, value_or_callback: SecretsScope, /
        ) -> "GcpIdTokenAuthModel.Builder": ...

        @overload
        def secrets_scope(
            self,
            value_or_callback: Callable[
                [SecretsScope.Builder], SecretsScope.Builder | SecretsScope
            ],
            /,
        ) -> "GcpIdTokenAuthModel.Builder": ...

        @overload
        def secrets_scope(
            self, value_or_callback: Never = ...
        ) -> "SecretsScope.BuilderContext": ...

        def secrets_scope(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = SecretsScope.BuilderContext()
                context._parent_builder = self
                context._field_name = "secrets_scope"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SecretsScope.builder())
                if isinstance(output, SecretsScope.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("secrets_scope", value)

    class BuilderContext(BuilderContextBase["GcpIdTokenAuthModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = GcpIdTokenAuthModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for GcpIdTokenAuthModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["GcpIdTokenAuthModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use GcpIdTokenAuthModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    identity_id: Annotated[str, Field(alias="identityId")]
    secrets_scope: Annotated[SecretsScope, Field(alias="secretsScope")]


class KubernetesAuthModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["KubernetesAuthModel"]:
            return KubernetesAuthModel

        def build(self) -> "KubernetesAuthModel":
            return KubernetesAuthModel(**self._attrs)

        def auto_create_service_account_token(self, value: Optional[bool], /) -> Self:
            """
            Optionally automatically create a service account token for the configured service account.
            If this is set to `true`, the operator will automatically create a service account token for the configured service account.
            """
            return self._set("auto_create_service_account_token", value)

        def identity_id(self, value: str, /) -> Self:
            return self._set("identity_id", value)

        @overload
        def secrets_scope(
            self, value_or_callback: SecretsScope, /
        ) -> "KubernetesAuthModel.Builder": ...

        @overload
        def secrets_scope(
            self,
            value_or_callback: Callable[
                [SecretsScope.Builder], SecretsScope.Builder | SecretsScope
            ],
            /,
        ) -> "KubernetesAuthModel.Builder": ...

        @overload
        def secrets_scope(
            self, value_or_callback: Never = ...
        ) -> "SecretsScope.BuilderContext": ...

        def secrets_scope(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = SecretsScope.BuilderContext()
                context._parent_builder = self
                context._field_name = "secrets_scope"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SecretsScope.builder())
                if isinstance(output, SecretsScope.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("secrets_scope", value)

        @overload
        def service_account_ref(
            self, value_or_callback: ServiceAccountRef, /
        ) -> "KubernetesAuthModel.Builder": ...

        @overload
        def service_account_ref(
            self,
            value_or_callback: Callable[
                [ServiceAccountRef.Builder],
                ServiceAccountRef.Builder | ServiceAccountRef,
            ],
            /,
        ) -> "KubernetesAuthModel.Builder": ...

        @overload
        def service_account_ref(
            self, value_or_callback: Never = ...
        ) -> "ServiceAccountRef.BuilderContext": ...

        def service_account_ref(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ServiceAccountRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "service_account_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ServiceAccountRef.builder())
                if isinstance(output, ServiceAccountRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("service_account_ref", value)

        def service_account_token_audiences(self, value: Optional[List[str]], /) -> Self:
            """
            The audiences to use for the service account token. This is only relevant if `autoCreateServiceAccountToken` is true.
            """
            return self._set("service_account_token_audiences", value)

    class BuilderContext(BuilderContextBase["KubernetesAuthModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = KubernetesAuthModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for KubernetesAuthModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["KubernetesAuthModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use KubernetesAuthModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    auto_create_service_account_token: Annotated[
        Optional[bool], Field(alias="autoCreateServiceAccountToken")
    ] = None
    """
    Optionally automatically create a service account token for the configured service account.
    If this is set to `true`, the operator will automatically create a service account token for the configured service account.
    """
    identity_id: Annotated[str, Field(alias="identityId")]
    secrets_scope: Annotated[SecretsScope, Field(alias="secretsScope")]
    service_account_ref: Annotated[ServiceAccountRef, Field(alias="serviceAccountRef")]
    service_account_token_audiences: Annotated[
        Optional[List[str]], Field(alias="serviceAccountTokenAudiences")
    ] = None
    """
    The audiences to use for the service account token. This is only relevant if `autoCreateServiceAccountToken` is true.
    """


class LdapAuthModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["LdapAuthModel"]:
            return LdapAuthModel

        def build(self) -> "LdapAuthModel":
            return LdapAuthModel(**self._attrs)

        @overload
        def credentials_ref(
            self, value_or_callback: CredentialsRef, /
        ) -> "LdapAuthModel.Builder": ...

        @overload
        def credentials_ref(
            self,
            value_or_callback: Callable[
                [CredentialsRef.Builder], CredentialsRef.Builder | CredentialsRef
            ],
            /,
        ) -> "LdapAuthModel.Builder": ...

        @overload
        def credentials_ref(
            self, value_or_callback: Never = ...
        ) -> "CredentialsRef.BuilderContext": ...

        def credentials_ref(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = CredentialsRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "credentials_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(CredentialsRef.builder())
                if isinstance(output, CredentialsRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("credentials_ref", value)

        def identity_id(self, value: str, /) -> Self:
            return self._set("identity_id", value)

        @overload
        def secrets_scope(self, value_or_callback: SecretsScope, /) -> "LdapAuthModel.Builder": ...

        @overload
        def secrets_scope(
            self,
            value_or_callback: Callable[
                [SecretsScope.Builder], SecretsScope.Builder | SecretsScope
            ],
            /,
        ) -> "LdapAuthModel.Builder": ...

        @overload
        def secrets_scope(
            self, value_or_callback: Never = ...
        ) -> "SecretsScope.BuilderContext": ...

        def secrets_scope(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = SecretsScope.BuilderContext()
                context._parent_builder = self
                context._field_name = "secrets_scope"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SecretsScope.builder())
                if isinstance(output, SecretsScope.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("secrets_scope", value)

    class BuilderContext(BuilderContextBase["LdapAuthModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = LdapAuthModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for LdapAuthModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["LdapAuthModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use LdapAuthModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    credentials_ref: Annotated[CredentialsRef, Field(alias="credentialsRef")]
    identity_id: Annotated[str, Field(alias="identityId")]
    secrets_scope: Annotated[SecretsScope, Field(alias="secretsScope")]


class ServiceAccountSecretReference(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ServiceAccountSecretReference"]:
            return ServiceAccountSecretReference

        def build(self) -> "ServiceAccountSecretReference":
            return ServiceAccountSecretReference(**self._attrs)

        def secret_name(self, value: str, /) -> Self:
            """
            The name of the Kubernetes Secret
            """
            return self._set("secret_name", value)

        def secret_namespace(self, value: str, /) -> Self:
            """
            The name space where the Kubernetes Secret is located
            """
            return self._set("secret_namespace", value)

    class BuilderContext(BuilderContextBase["ServiceAccountSecretReference.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ServiceAccountSecretReference.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ServiceAccountSecretReference."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ServiceAccountSecretReference", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ServiceAccountSecretReference.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    secret_name: Annotated[str, Field(alias="secretName")]
    """
    The name of the Kubernetes Secret
    """
    secret_namespace: Annotated[str, Field(alias="secretNamespace")]
    """
    The name space where the Kubernetes Secret is located
    """


class ServiceAccount(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ServiceAccount"]:
            return ServiceAccount

        def build(self) -> "ServiceAccount":
            return ServiceAccount(**self._attrs)

        def environment_name(self, value: str, /) -> Self:
            return self._set("environment_name", value)

        def project_id(self, value: str, /) -> Self:
            return self._set("project_id", value)

        @overload
        def service_account_secret_reference(
            self, value_or_callback: ServiceAccountSecretReference, /
        ) -> "ServiceAccount.Builder": ...

        @overload
        def service_account_secret_reference(
            self,
            value_or_callback: Callable[
                [ServiceAccountSecretReference.Builder],
                ServiceAccountSecretReference.Builder | ServiceAccountSecretReference,
            ],
            /,
        ) -> "ServiceAccount.Builder": ...

        @overload
        def service_account_secret_reference(
            self, value_or_callback: Never = ...
        ) -> "ServiceAccountSecretReference.BuilderContext": ...

        def service_account_secret_reference(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ServiceAccountSecretReference.BuilderContext()
                context._parent_builder = self
                context._field_name = "service_account_secret_reference"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ServiceAccountSecretReference.builder())
                if isinstance(output, ServiceAccountSecretReference.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("service_account_secret_reference", value)

    class BuilderContext(BuilderContextBase["ServiceAccount.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ServiceAccount.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ServiceAccount."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ServiceAccount", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ServiceAccount.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    environment_name: Annotated[str, Field(alias="environmentName")]
    project_id: Annotated[str, Field(alias="projectId")]
    service_account_secret_reference: Annotated[
        ServiceAccountSecretReference, Field(alias="serviceAccountSecretReference")
    ]


class SecretsScopeModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["SecretsScopeModel"]:
            return SecretsScopeModel

        def build(self) -> "SecretsScopeModel":
            return SecretsScopeModel(**self._attrs)

        def env_slug(self, value: str, /) -> Self:
            return self._set("env_slug", value)

        def recursive(self, value: Optional[bool], /) -> Self:
            return self._set("recursive", value)

        def secrets_path(self, value: str, /) -> Self:
            return self._set("secrets_path", value)

    class BuilderContext(BuilderContextBase["SecretsScopeModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SecretsScopeModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SecretsScopeModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["SecretsScopeModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SecretsScopeModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    env_slug: Annotated[str, Field(alias="envSlug")]
    recursive: Optional[bool] = None
    secrets_path: Annotated[str, Field(alias="secretsPath")]


class ServiceTokenSecretReference(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ServiceTokenSecretReference"]:
            return ServiceTokenSecretReference

        def build(self) -> "ServiceTokenSecretReference":
            return ServiceTokenSecretReference(**self._attrs)

        def secret_name(self, value: str, /) -> Self:
            """
            The name of the Kubernetes Secret
            """
            return self._set("secret_name", value)

        def secret_namespace(self, value: str, /) -> Self:
            """
            The name space where the Kubernetes Secret is located
            """
            return self._set("secret_namespace", value)

    class BuilderContext(BuilderContextBase["ServiceTokenSecretReference.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ServiceTokenSecretReference.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ServiceTokenSecretReference."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ServiceTokenSecretReference", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ServiceTokenSecretReference.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    secret_name: Annotated[str, Field(alias="secretName")]
    """
    The name of the Kubernetes Secret
    """
    secret_namespace: Annotated[str, Field(alias="secretNamespace")]
    """
    The name space where the Kubernetes Secret is located
    """


class ServiceToken(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ServiceToken"]:
            return ServiceToken

        def build(self) -> "ServiceToken":
            return ServiceToken(**self._attrs)

        @overload
        def secrets_scope(
            self, value_or_callback: SecretsScopeModel, /
        ) -> "ServiceToken.Builder": ...

        @overload
        def secrets_scope(
            self,
            value_or_callback: Callable[
                [SecretsScopeModel.Builder],
                SecretsScopeModel.Builder | SecretsScopeModel,
            ],
            /,
        ) -> "ServiceToken.Builder": ...

        @overload
        def secrets_scope(
            self, value_or_callback: Never = ...
        ) -> "SecretsScopeModel.BuilderContext": ...

        def secrets_scope(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = SecretsScopeModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "secrets_scope"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SecretsScopeModel.builder())
                if isinstance(output, SecretsScopeModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("secrets_scope", value)

        @overload
        def service_token_secret_reference(
            self, value_or_callback: ServiceTokenSecretReference, /
        ) -> "ServiceToken.Builder": ...

        @overload
        def service_token_secret_reference(
            self,
            value_or_callback: Callable[
                [ServiceTokenSecretReference.Builder],
                ServiceTokenSecretReference.Builder | ServiceTokenSecretReference,
            ],
            /,
        ) -> "ServiceToken.Builder": ...

        @overload
        def service_token_secret_reference(
            self, value_or_callback: Never = ...
        ) -> "ServiceTokenSecretReference.BuilderContext": ...

        def service_token_secret_reference(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ServiceTokenSecretReference.BuilderContext()
                context._parent_builder = self
                context._field_name = "service_token_secret_reference"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ServiceTokenSecretReference.builder())
                if isinstance(output, ServiceTokenSecretReference.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("service_token_secret_reference", value)

    class BuilderContext(BuilderContextBase["ServiceToken.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ServiceToken.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ServiceToken."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ServiceToken", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ServiceToken.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    secrets_scope: Annotated[SecretsScopeModel, Field(alias="secretsScope")]
    service_token_secret_reference: Annotated[
        ServiceTokenSecretReference, Field(alias="serviceTokenSecretReference")
    ]


class SecretsScopeModel1(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["SecretsScopeModel1"]:
            return SecretsScopeModel1

        def build(self) -> "SecretsScopeModel1":
            return SecretsScopeModel1(**self._attrs)

        def env_slug(self, value: str, /) -> Self:
            return self._set("env_slug", value)

        def project_id(self, value: Optional[str], /) -> Self:
            return self._set("project_id", value)

        def project_slug(self, value: Optional[str], /) -> Self:
            return self._set("project_slug", value)

        def recursive(self, value: Optional[bool], /) -> Self:
            return self._set("recursive", value)

        def secret_name(self, value: Optional[str], /) -> Self:
            return self._set("secret_name", value)

        def secrets_path(self, value: str, /) -> Self:
            return self._set("secrets_path", value)

    class BuilderContext(BuilderContextBase["SecretsScopeModel1.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SecretsScopeModel1.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SecretsScopeModel1."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["SecretsScopeModel1", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SecretsScopeModel1.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    env_slug: Annotated[str, Field(alias="envSlug")]
    project_id: Annotated[Optional[str], Field(alias="projectId")] = None
    project_slug: Annotated[Optional[str], Field(alias="projectSlug")] = None
    recursive: Optional[bool] = None
    secret_name: Annotated[Optional[str], Field(alias="secretName")] = None
    secrets_path: Annotated[str, Field(alias="secretsPath")]


class UniversalAuthModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["UniversalAuthModel"]:
            return UniversalAuthModel

        def build(self) -> "UniversalAuthModel":
            return UniversalAuthModel(**self._attrs)

        @overload
        def credentials_ref(
            self, value_or_callback: CredentialsRef, /
        ) -> "UniversalAuthModel.Builder": ...

        @overload
        def credentials_ref(
            self,
            value_or_callback: Callable[
                [CredentialsRef.Builder], CredentialsRef.Builder | CredentialsRef
            ],
            /,
        ) -> "UniversalAuthModel.Builder": ...

        @overload
        def credentials_ref(
            self, value_or_callback: Never = ...
        ) -> "CredentialsRef.BuilderContext": ...

        def credentials_ref(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = CredentialsRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "credentials_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(CredentialsRef.builder())
                if isinstance(output, CredentialsRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("credentials_ref", value)

        @overload
        def secrets_scope(
            self, value_or_callback: SecretsScopeModel1, /
        ) -> "UniversalAuthModel.Builder": ...

        @overload
        def secrets_scope(
            self,
            value_or_callback: Callable[
                [SecretsScopeModel1.Builder],
                SecretsScopeModel1.Builder | SecretsScopeModel1,
            ],
            /,
        ) -> "UniversalAuthModel.Builder": ...

        @overload
        def secrets_scope(
            self, value_or_callback: Never = ...
        ) -> "SecretsScopeModel1.BuilderContext": ...

        def secrets_scope(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = SecretsScopeModel1.BuilderContext()
                context._parent_builder = self
                context._field_name = "secrets_scope"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SecretsScopeModel1.builder())
                if isinstance(output, SecretsScopeModel1.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("secrets_scope", value)

    class BuilderContext(BuilderContextBase["UniversalAuthModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = UniversalAuthModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for UniversalAuthModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["UniversalAuthModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use UniversalAuthModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    credentials_ref: Annotated[CredentialsRef, Field(alias="credentialsRef")]
    secrets_scope: Annotated[SecretsScopeModel1, Field(alias="secretsScope")]


class AuthenticationModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AuthenticationModel"]:
            return AuthenticationModel

        def build(self) -> "AuthenticationModel":
            return AuthenticationModel(**self._attrs)

        @overload
        def aws_iam_auth(
            self, value_or_callback: Optional[AwsIamAuthModel], /
        ) -> "AuthenticationModel.Builder": ...

        @overload
        def aws_iam_auth(
            self,
            value_or_callback: Callable[
                [AwsIamAuthModel.Builder], AwsIamAuthModel.Builder | AwsIamAuthModel
            ],
            /,
        ) -> "AuthenticationModel.Builder": ...

        @overload
        def aws_iam_auth(
            self, value_or_callback: Never = ...
        ) -> "AwsIamAuthModel.BuilderContext": ...

        def aws_iam_auth(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = AwsIamAuthModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "aws_iam_auth"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AwsIamAuthModel.builder())
                if isinstance(output, AwsIamAuthModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("aws_iam_auth", value)

        @overload
        def azure_auth(
            self, value_or_callback: Optional[AzureAuthModel], /
        ) -> "AuthenticationModel.Builder": ...

        @overload
        def azure_auth(
            self,
            value_or_callback: Callable[
                [AzureAuthModel.Builder], AzureAuthModel.Builder | AzureAuthModel
            ],
            /,
        ) -> "AuthenticationModel.Builder": ...

        @overload
        def azure_auth(self, value_or_callback: Never = ...) -> "AzureAuthModel.BuilderContext": ...

        def azure_auth(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = AzureAuthModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "azure_auth"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AzureAuthModel.builder())
                if isinstance(output, AzureAuthModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("azure_auth", value)

        @overload
        def gcp_iam_auth(
            self, value_or_callback: Optional[GcpIamAuthModel], /
        ) -> "AuthenticationModel.Builder": ...

        @overload
        def gcp_iam_auth(
            self,
            value_or_callback: Callable[
                [GcpIamAuthModel.Builder], GcpIamAuthModel.Builder | GcpIamAuthModel
            ],
            /,
        ) -> "AuthenticationModel.Builder": ...

        @overload
        def gcp_iam_auth(
            self, value_or_callback: Never = ...
        ) -> "GcpIamAuthModel.BuilderContext": ...

        def gcp_iam_auth(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = GcpIamAuthModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "gcp_iam_auth"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(GcpIamAuthModel.builder())
                if isinstance(output, GcpIamAuthModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("gcp_iam_auth", value)

        @overload
        def gcp_id_token_auth(
            self, value_or_callback: Optional[GcpIdTokenAuthModel], /
        ) -> "AuthenticationModel.Builder": ...

        @overload
        def gcp_id_token_auth(
            self,
            value_or_callback: Callable[
                [GcpIdTokenAuthModel.Builder],
                GcpIdTokenAuthModel.Builder | GcpIdTokenAuthModel,
            ],
            /,
        ) -> "AuthenticationModel.Builder": ...

        @overload
        def gcp_id_token_auth(
            self, value_or_callback: Never = ...
        ) -> "GcpIdTokenAuthModel.BuilderContext": ...

        def gcp_id_token_auth(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = GcpIdTokenAuthModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "gcp_id_token_auth"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(GcpIdTokenAuthModel.builder())
                if isinstance(output, GcpIdTokenAuthModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("gcp_id_token_auth", value)

        @overload
        def kubernetes_auth(
            self, value_or_callback: Optional[KubernetesAuthModel], /
        ) -> "AuthenticationModel.Builder": ...

        @overload
        def kubernetes_auth(
            self,
            value_or_callback: Callable[
                [KubernetesAuthModel.Builder],
                KubernetesAuthModel.Builder | KubernetesAuthModel,
            ],
            /,
        ) -> "AuthenticationModel.Builder": ...

        @overload
        def kubernetes_auth(
            self, value_or_callback: Never = ...
        ) -> "KubernetesAuthModel.BuilderContext": ...

        def kubernetes_auth(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = KubernetesAuthModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "kubernetes_auth"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(KubernetesAuthModel.builder())
                if isinstance(output, KubernetesAuthModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("kubernetes_auth", value)

        @overload
        def ldap_auth(
            self, value_or_callback: Optional[LdapAuthModel], /
        ) -> "AuthenticationModel.Builder": ...

        @overload
        def ldap_auth(
            self,
            value_or_callback: Callable[
                [LdapAuthModel.Builder], LdapAuthModel.Builder | LdapAuthModel
            ],
            /,
        ) -> "AuthenticationModel.Builder": ...

        @overload
        def ldap_auth(self, value_or_callback: Never = ...) -> "LdapAuthModel.BuilderContext": ...

        def ldap_auth(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = LdapAuthModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "ldap_auth"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(LdapAuthModel.builder())
                if isinstance(output, LdapAuthModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("ldap_auth", value)

        @overload
        def service_account(
            self, value_or_callback: Optional[ServiceAccount], /
        ) -> "AuthenticationModel.Builder": ...

        @overload
        def service_account(
            self,
            value_or_callback: Callable[
                [ServiceAccount.Builder], ServiceAccount.Builder | ServiceAccount
            ],
            /,
        ) -> "AuthenticationModel.Builder": ...

        @overload
        def service_account(
            self, value_or_callback: Never = ...
        ) -> "ServiceAccount.BuilderContext": ...

        def service_account(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ServiceAccount.BuilderContext()
                context._parent_builder = self
                context._field_name = "service_account"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ServiceAccount.builder())
                if isinstance(output, ServiceAccount.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("service_account", value)

        @overload
        def service_token(
            self, value_or_callback: Optional[ServiceToken], /
        ) -> "AuthenticationModel.Builder": ...

        @overload
        def service_token(
            self,
            value_or_callback: Callable[
                [ServiceToken.Builder], ServiceToken.Builder | ServiceToken
            ],
            /,
        ) -> "AuthenticationModel.Builder": ...

        @overload
        def service_token(
            self, value_or_callback: Never = ...
        ) -> "ServiceToken.BuilderContext": ...

        def service_token(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ServiceToken.BuilderContext()
                context._parent_builder = self
                context._field_name = "service_token"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ServiceToken.builder())
                if isinstance(output, ServiceToken.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("service_token", value)

        @overload
        def universal_auth(
            self, value_or_callback: Optional[UniversalAuthModel], /
        ) -> "AuthenticationModel.Builder": ...

        @overload
        def universal_auth(
            self,
            value_or_callback: Callable[
                [UniversalAuthModel.Builder],
                UniversalAuthModel.Builder | UniversalAuthModel,
            ],
            /,
        ) -> "AuthenticationModel.Builder": ...

        @overload
        def universal_auth(
            self, value_or_callback: Never = ...
        ) -> "UniversalAuthModel.BuilderContext": ...

        def universal_auth(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = UniversalAuthModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "universal_auth"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(UniversalAuthModel.builder())
                if isinstance(output, UniversalAuthModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("universal_auth", value)

    class BuilderContext(BuilderContextBase["AuthenticationModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AuthenticationModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AuthenticationModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AuthenticationModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AuthenticationModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    aws_iam_auth: Annotated[Optional[AwsIamAuthModel], Field(alias="awsIamAuth")] = None
    azure_auth: Annotated[Optional[AzureAuthModel], Field(alias="azureAuth")] = None
    gcp_iam_auth: Annotated[Optional[GcpIamAuthModel], Field(alias="gcpIamAuth")] = None
    gcp_id_token_auth: Annotated[Optional[GcpIdTokenAuthModel], Field(alias="gcpIdTokenAuth")] = (
        None
    )
    kubernetes_auth: Annotated[Optional[KubernetesAuthModel], Field(alias="kubernetesAuth")] = None
    ldap_auth: Annotated[Optional[LdapAuthModel], Field(alias="ldapAuth")] = None
    service_account: Annotated[Optional[ServiceAccount], Field(alias="serviceAccount")] = None
    service_token: Annotated[Optional[ServiceToken], Field(alias="serviceToken")] = None
    universal_auth: Annotated[Optional[UniversalAuthModel], Field(alias="universalAuth")] = None


class ManagedKubeConfigMapReference(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ManagedKubeConfigMapReference"]:
            return ManagedKubeConfigMapReference

        def build(self) -> "ManagedKubeConfigMapReference":
            return ManagedKubeConfigMapReference(**self._attrs)

        def config_map_name(self, value: str, /) -> Self:
            """
            The name of the Kubernetes ConfigMap
            """
            return self._set("config_map_name", value)

        def config_map_namespace(self, value: str, /) -> Self:
            """
            The namespace where the Kubernetes ConfigMap is located
            """
            return self._set("config_map_namespace", value)

        def creation_policy(self, value: Optional[str], /) -> Self:
            """
            The Kubernetes ConfigMap creation policy.
            Enum with values: 'Owner', 'Orphan'.
            Owner creates the config map and sets .metadata.ownerReferences of the InfisicalSecret CRD that created it.
            Orphan will not set the config map owner. This will result in the config map being orphaned and not deleted when the resource is deleted.
            """
            return self._set("creation_policy", value)

        @overload
        def template(
            self, value_or_callback: Optional[Template], /
        ) -> "ManagedKubeConfigMapReference.Builder": ...

        @overload
        def template(
            self,
            value_or_callback: Callable[[Template.Builder], Template.Builder | Template],
            /,
        ) -> "ManagedKubeConfigMapReference.Builder": ...

        @overload
        def template(self, value_or_callback: Never = ...) -> "Template.BuilderContext": ...

        def template(self, value_or_callback=None, /):
            """
            The template to transform the secret data
            """
            if self._in_context and value_or_callback is None:
                context = Template.BuilderContext()
                context._parent_builder = self
                context._field_name = "template"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Template.builder())
                if isinstance(output, Template.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("template", value)

    class BuilderContext(BuilderContextBase["ManagedKubeConfigMapReference.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ManagedKubeConfigMapReference.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ManagedKubeConfigMapReference."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ManagedKubeConfigMapReference", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ManagedKubeConfigMapReference.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    config_map_name: Annotated[str, Field(alias="configMapName")]
    """
    The name of the Kubernetes ConfigMap
    """
    config_map_namespace: Annotated[str, Field(alias="configMapNamespace")]
    """
    The namespace where the Kubernetes ConfigMap is located
    """
    creation_policy: Annotated[Optional[str], Field(alias="creationPolicy")] = "Orphan"
    """
    The Kubernetes ConfigMap creation policy.
    Enum with values: 'Owner', 'Orphan'.
    Owner creates the config map and sets .metadata.ownerReferences of the InfisicalSecret CRD that created it.
    Orphan will not set the config map owner. This will result in the config map being orphaned and not deleted when the resource is deleted.
    """
    template: Optional[Template] = None
    """
    The template to transform the secret data
    """


class ManagedKubeSecretReference(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ManagedKubeSecretReference"]:
            return ManagedKubeSecretReference

        def build(self) -> "ManagedKubeSecretReference":
            return ManagedKubeSecretReference(**self._attrs)

        def creation_policy(self, value: Optional[str], /) -> Self:
            """
            The Kubernetes Secret creation policy.
            Enum with values: 'Owner', 'Orphan'.
            Owner creates the secret and sets .metadata.ownerReferences of the InfisicalSecret CRD that created it.
            Orphan will not set the secret owner. This will result in the secret being orphaned and not deleted when the resource is deleted.
            """
            return self._set("creation_policy", value)

        def secret_name(self, value: str, /) -> Self:
            """
            The name of the Kubernetes Secret
            """
            return self._set("secret_name", value)

        def secret_namespace(self, value: str, /) -> Self:
            """
            The name space where the Kubernetes Secret is located
            """
            return self._set("secret_namespace", value)

        def secret_type(self, value: Optional[str], /) -> Self:
            """
            The Kubernetes Secret type (experimental feature). More info: https://kubernetes.io/docs/concepts/configuration/secret/#secret-types
            """
            return self._set("secret_type", value)

        @overload
        def template(
            self, value_or_callback: Optional[Template], /
        ) -> "ManagedKubeSecretReference.Builder": ...

        @overload
        def template(
            self,
            value_or_callback: Callable[[Template.Builder], Template.Builder | Template],
            /,
        ) -> "ManagedKubeSecretReference.Builder": ...

        @overload
        def template(self, value_or_callback: Never = ...) -> "Template.BuilderContext": ...

        def template(self, value_or_callback=None, /):
            """
            The template to transform the secret data
            """
            if self._in_context and value_or_callback is None:
                context = Template.BuilderContext()
                context._parent_builder = self
                context._field_name = "template"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Template.builder())
                if isinstance(output, Template.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("template", value)

    class BuilderContext(BuilderContextBase["ManagedKubeSecretReference.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ManagedKubeSecretReference.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ManagedKubeSecretReference."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ManagedKubeSecretReference", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ManagedKubeSecretReference.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    creation_policy: Annotated[Optional[str], Field(alias="creationPolicy")] = "Orphan"
    """
    The Kubernetes Secret creation policy.
    Enum with values: 'Owner', 'Orphan'.
    Owner creates the secret and sets .metadata.ownerReferences of the InfisicalSecret CRD that created it.
    Orphan will not set the secret owner. This will result in the secret being orphaned and not deleted when the resource is deleted.
    """
    secret_name: Annotated[str, Field(alias="secretName")]
    """
    The name of the Kubernetes Secret
    """
    secret_namespace: Annotated[str, Field(alias="secretNamespace")]
    """
    The name space where the Kubernetes Secret is located
    """
    secret_type: Annotated[Optional[str], Field(alias="secretType")] = "Opaque"
    """
    The Kubernetes Secret type (experimental feature). More info: https://kubernetes.io/docs/concepts/configuration/secret/#secret-types
    """
    template: Optional[Template] = None
    """
    The template to transform the secret data
    """


class TokenSecretReference(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["TokenSecretReference"]:
            return TokenSecretReference

        def build(self) -> "TokenSecretReference":
            return TokenSecretReference(**self._attrs)

        def secret_name(self, value: str, /) -> Self:
            """
            The name of the Kubernetes Secret
            """
            return self._set("secret_name", value)

        def secret_namespace(self, value: str, /) -> Self:
            """
            The name space where the Kubernetes Secret is located
            """
            return self._set("secret_namespace", value)

    class BuilderContext(BuilderContextBase["TokenSecretReference.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = TokenSecretReference.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for TokenSecretReference."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["TokenSecretReference", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use TokenSecretReference.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    secret_name: Annotated[str, Field(alias="secretName")]
    """
    The name of the Kubernetes Secret
    """
    secret_namespace: Annotated[str, Field(alias="secretNamespace")]
    """
    The name space where the Kubernetes Secret is located
    """


class InfisicalSecretSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["InfisicalSecretSpec"]:
            return InfisicalSecretSpec

        def build(self) -> "InfisicalSecretSpec":
            return InfisicalSecretSpec(**self._attrs)

        @overload
        def authentication(
            self, value_or_callback: Optional[AuthenticationModel], /
        ) -> "InfisicalSecretSpec.Builder": ...

        @overload
        def authentication(
            self,
            value_or_callback: Callable[
                [AuthenticationModel.Builder],
                AuthenticationModel.Builder | AuthenticationModel,
            ],
            /,
        ) -> "InfisicalSecretSpec.Builder": ...

        @overload
        def authentication(
            self, value_or_callback: Never = ...
        ) -> "AuthenticationModel.BuilderContext": ...

        def authentication(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = AuthenticationModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "authentication"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AuthenticationModel.builder())
                if isinstance(output, AuthenticationModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("authentication", value)

        def host_api(self, value: Optional[str], /) -> Self:
            """
            Infisical host to pull secrets from
            """
            return self._set("host_api", value)

        def instant_updates(self, value: Optional[bool], /) -> Self:
            return self._set("instant_updates", value)

        @overload
        def managed_kube_config_map_references(
            self, value_or_callback: List[ManagedKubeConfigMapReference], /
        ) -> "InfisicalSecretSpec.Builder": ...

        @overload
        def managed_kube_config_map_references(
            self,
            value_or_callback: Callable[
                [
                    GenericListBuilder[
                        ManagedKubeConfigMapReference,
                        ManagedKubeConfigMapReference.Builder,
                    ]
                ],
                GenericListBuilder[
                    ManagedKubeConfigMapReference, ManagedKubeConfigMapReference.Builder
                ]
                | List[ManagedKubeConfigMapReference],
            ],
            /,
        ) -> "InfisicalSecretSpec.Builder": ...

        @overload
        def managed_kube_config_map_references(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ManagedKubeConfigMapReference.Builder]: ...

        def managed_kube_config_map_references(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ManagedKubeConfigMapReference.Builder]()
                context._parent_builder = self
                context._field_name = "managed_kube_config_map_references"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ManagedKubeConfigMapReference.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("managed_kube_config_map_references", value)

        @overload
        def managed_kube_secret_references(
            self, value_or_callback: List[ManagedKubeSecretReference], /
        ) -> "InfisicalSecretSpec.Builder": ...

        @overload
        def managed_kube_secret_references(
            self,
            value_or_callback: Callable[
                [
                    GenericListBuilder[
                        ManagedKubeSecretReference, ManagedKubeSecretReference.Builder
                    ]
                ],
                GenericListBuilder[ManagedKubeSecretReference, ManagedKubeSecretReference.Builder]
                | List[ManagedKubeSecretReference],
            ],
            /,
        ) -> "InfisicalSecretSpec.Builder": ...

        @overload
        def managed_kube_secret_references(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ManagedKubeSecretReference.Builder]: ...

        def managed_kube_secret_references(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ManagedKubeSecretReference.Builder]()
                context._parent_builder = self
                context._field_name = "managed_kube_secret_references"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ManagedKubeSecretReference.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("managed_kube_secret_references", value)

        @overload
        def managed_secret_reference(
            self, value_or_callback: Optional[ManagedSecretReference], /
        ) -> "InfisicalSecretSpec.Builder": ...

        @overload
        def managed_secret_reference(
            self,
            value_or_callback: Callable[
                [ManagedSecretReference.Builder],
                ManagedSecretReference.Builder | ManagedSecretReference,
            ],
            /,
        ) -> "InfisicalSecretSpec.Builder": ...

        @overload
        def managed_secret_reference(
            self, value_or_callback: Never = ...
        ) -> "ManagedSecretReference.BuilderContext": ...

        def managed_secret_reference(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ManagedSecretReference.BuilderContext()
                context._parent_builder = self
                context._field_name = "managed_secret_reference"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ManagedSecretReference.builder())
                if isinstance(output, ManagedSecretReference.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("managed_secret_reference", value)

        def resync_interval(self, value: Optional[int], /) -> Self:
            return self._set("resync_interval", value)

        @overload
        def tls(self, value_or_callback: Optional[Tls], /) -> "InfisicalSecretSpec.Builder": ...

        @overload
        def tls(
            self, value_or_callback: Callable[[Tls.Builder], Tls.Builder | Tls], /
        ) -> "InfisicalSecretSpec.Builder": ...

        @overload
        def tls(self, value_or_callback: Never = ...) -> "Tls.BuilderContext": ...

        def tls(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = Tls.BuilderContext()
                context._parent_builder = self
                context._field_name = "tls"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Tls.builder())
                if isinstance(output, Tls.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("tls", value)

        @overload
        def token_secret_reference(
            self, value_or_callback: Optional[TokenSecretReference], /
        ) -> "InfisicalSecretSpec.Builder": ...

        @overload
        def token_secret_reference(
            self,
            value_or_callback: Callable[
                [TokenSecretReference.Builder],
                TokenSecretReference.Builder | TokenSecretReference,
            ],
            /,
        ) -> "InfisicalSecretSpec.Builder": ...

        @overload
        def token_secret_reference(
            self, value_or_callback: Never = ...
        ) -> "TokenSecretReference.BuilderContext": ...

        def token_secret_reference(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = TokenSecretReference.BuilderContext()
                context._parent_builder = self
                context._field_name = "token_secret_reference"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(TokenSecretReference.builder())
                if isinstance(output, TokenSecretReference.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("token_secret_reference", value)

    class BuilderContext(BuilderContextBase["InfisicalSecretSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = InfisicalSecretSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for InfisicalSecretSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["InfisicalSecretSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use InfisicalSecretSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    authentication: Optional[AuthenticationModel] = None
    host_api: Annotated[Optional[str], Field(alias="hostAPI")] = None
    """
    Infisical host to pull secrets from
    """
    instant_updates: Annotated[Optional[bool], Field(alias="instantUpdates")] = None
    managed_kube_config_map_references: Annotated[
        Optional[List[ManagedKubeConfigMapReference]],
        Field(alias="managedKubeConfigMapReferences"),
    ] = None
    managed_kube_secret_references: Annotated[
        Optional[List[ManagedKubeSecretReference]],
        Field(alias="managedKubeSecretReferences"),
    ] = None
    managed_secret_reference: Annotated[
        Optional[ManagedSecretReference], Field(alias="managedSecretReference")
    ] = None
    resync_interval: Annotated[Optional[int], Field(alias="resyncInterval")] = 60
    tls: Optional[Tls] = None
    token_secret_reference: Annotated[
        Optional[TokenSecretReference], Field(alias="tokenSecretReference")
    ] = None


class InfisicalSecretStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["InfisicalSecretStatus"]:
            return InfisicalSecretStatus

        def build(self) -> "InfisicalSecretStatus":
            return InfisicalSecretStatus(**self._attrs)

        @overload
        def conditions(
            self, value_or_callback: List[Condition], /
        ) -> "InfisicalSecretStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Condition, Condition.Builder]],
                GenericListBuilder[Condition, Condition.Builder] | List[Condition],
            ],
            /,
        ) -> "InfisicalSecretStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

    class BuilderContext(BuilderContextBase["InfisicalSecretStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = InfisicalSecretStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for InfisicalSecretStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["InfisicalSecretStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use InfisicalSecretStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    conditions: List[Condition]


class UUIDSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["UUIDSpec"]:
            return UUIDSpec

        def build(self) -> "UUIDSpec":
            return UUIDSpec(**self._attrs)

    class BuilderContext(BuilderContextBase["UUIDSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = UUIDSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for UUIDSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["UUIDSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use UUIDSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    pass


class ClusterGenerator(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ClusterGenerator"]:
            return ClusterGenerator

        def build(self) -> "ClusterGenerator":
            return ClusterGenerator(**self._attrs)

        def api_version(
            self, value: Optional[Literal["secrets.infisical.com/v1alpha1"]], /
        ) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["ClusterGenerator"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "ClusterGenerator.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "ClusterGenerator.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(
            self, value_or_callback: Optional[ClusterGeneratorSpec], /
        ) -> "ClusterGenerator.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [ClusterGeneratorSpec.Builder],
                ClusterGeneratorSpec.Builder | ClusterGeneratorSpec,
            ],
            /,
        ) -> "ClusterGenerator.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "ClusterGeneratorSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ClusterGeneratorSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ClusterGeneratorSpec.builder())
                if isinstance(output, ClusterGeneratorSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

    class BuilderContext(BuilderContextBase["ClusterGenerator.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ClusterGenerator.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ClusterGenerator."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ClusterGenerator", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ClusterGenerator.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[
        Optional[Literal["secrets.infisical.com/v1alpha1"]], Field(alias="apiVersion")
    ] = "secrets.infisical.com/v1alpha1"
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["ClusterGenerator"]] = "ClusterGenerator"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: Optional[ClusterGeneratorSpec] = None


class InfisicalDynamicSecret(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["InfisicalDynamicSecret"]:
            return InfisicalDynamicSecret

        def build(self) -> "InfisicalDynamicSecret":
            return InfisicalDynamicSecret(**self._attrs)

        def api_version(
            self, value: Optional[Literal["secrets.infisical.com/v1alpha1"]], /
        ) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["InfisicalDynamicSecret"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "InfisicalDynamicSecret.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "InfisicalDynamicSecret.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(
            self, value_or_callback: Optional[InfisicalDynamicSecretSpec], /
        ) -> "InfisicalDynamicSecret.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [InfisicalDynamicSecretSpec.Builder],
                InfisicalDynamicSecretSpec.Builder | InfisicalDynamicSecretSpec,
            ],
            /,
        ) -> "InfisicalDynamicSecret.Builder": ...

        @overload
        def spec(
            self, value_or_callback: Never = ...
        ) -> "InfisicalDynamicSecretSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = InfisicalDynamicSecretSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(InfisicalDynamicSecretSpec.builder())
                if isinstance(output, InfisicalDynamicSecretSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(
            self, value_or_callback: Optional[InfisicalDynamicSecretStatus], /
        ) -> "InfisicalDynamicSecret.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [InfisicalDynamicSecretStatus.Builder],
                InfisicalDynamicSecretStatus.Builder | InfisicalDynamicSecretStatus,
            ],
            /,
        ) -> "InfisicalDynamicSecret.Builder": ...

        @overload
        def status(
            self, value_or_callback: Never = ...
        ) -> "InfisicalDynamicSecretStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = InfisicalDynamicSecretStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(InfisicalDynamicSecretStatus.builder())
                if isinstance(output, InfisicalDynamicSecretStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["InfisicalDynamicSecret.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = InfisicalDynamicSecret.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for InfisicalDynamicSecret."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["InfisicalDynamicSecret", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use InfisicalDynamicSecret.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[
        Optional[Literal["secrets.infisical.com/v1alpha1"]], Field(alias="apiVersion")
    ] = "secrets.infisical.com/v1alpha1"
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["InfisicalDynamicSecret"]] = "InfisicalDynamicSecret"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: Optional[InfisicalDynamicSecretSpec] = None
    status: Optional[InfisicalDynamicSecretStatus] = None


class InfisicalPushSecret(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["InfisicalPushSecret"]:
            return InfisicalPushSecret

        def build(self) -> "InfisicalPushSecret":
            return InfisicalPushSecret(**self._attrs)

        def api_version(
            self, value: Optional[Literal["secrets.infisical.com/v1alpha1"]], /
        ) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["InfisicalPushSecret"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "InfisicalPushSecret.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "InfisicalPushSecret.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(
            self, value_or_callback: Optional[InfisicalPushSecretSpec], /
        ) -> "InfisicalPushSecret.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [InfisicalPushSecretSpec.Builder],
                InfisicalPushSecretSpec.Builder | InfisicalPushSecretSpec,
            ],
            /,
        ) -> "InfisicalPushSecret.Builder": ...

        @overload
        def spec(
            self, value_or_callback: Never = ...
        ) -> "InfisicalPushSecretSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = InfisicalPushSecretSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(InfisicalPushSecretSpec.builder())
                if isinstance(output, InfisicalPushSecretSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(
            self, value_or_callback: Optional[InfisicalPushSecretStatus], /
        ) -> "InfisicalPushSecret.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [InfisicalPushSecretStatus.Builder],
                InfisicalPushSecretStatus.Builder | InfisicalPushSecretStatus,
            ],
            /,
        ) -> "InfisicalPushSecret.Builder": ...

        @overload
        def status(
            self, value_or_callback: Never = ...
        ) -> "InfisicalPushSecretStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = InfisicalPushSecretStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(InfisicalPushSecretStatus.builder())
                if isinstance(output, InfisicalPushSecretStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["InfisicalPushSecret.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = InfisicalPushSecret.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for InfisicalPushSecret."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["InfisicalPushSecret", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use InfisicalPushSecret.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[
        Optional[Literal["secrets.infisical.com/v1alpha1"]], Field(alias="apiVersion")
    ] = "secrets.infisical.com/v1alpha1"
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["InfisicalPushSecret"]] = "InfisicalPushSecret"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: Optional[InfisicalPushSecretSpec] = None
    status: Optional[InfisicalPushSecretStatus] = None


class InfisicalSecret(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["InfisicalSecret"]:
            return InfisicalSecret

        def build(self) -> "InfisicalSecret":
            return InfisicalSecret(**self._attrs)

        def api_version(
            self, value: Optional[Literal["secrets.infisical.com/v1alpha1"]], /
        ) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["InfisicalSecret"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "InfisicalSecret.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "InfisicalSecret.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(
            self, value_or_callback: Optional[InfisicalSecretSpec], /
        ) -> "InfisicalSecret.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [InfisicalSecretSpec.Builder],
                InfisicalSecretSpec.Builder | InfisicalSecretSpec,
            ],
            /,
        ) -> "InfisicalSecret.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "InfisicalSecretSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = InfisicalSecretSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(InfisicalSecretSpec.builder())
                if isinstance(output, InfisicalSecretSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(
            self, value_or_callback: Optional[InfisicalSecretStatus], /
        ) -> "InfisicalSecret.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [InfisicalSecretStatus.Builder],
                InfisicalSecretStatus.Builder | InfisicalSecretStatus,
            ],
            /,
        ) -> "InfisicalSecret.Builder": ...

        @overload
        def status(
            self, value_or_callback: Never = ...
        ) -> "InfisicalSecretStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = InfisicalSecretStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(InfisicalSecretStatus.builder())
                if isinstance(output, InfisicalSecretStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["InfisicalSecret.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = InfisicalSecret.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for InfisicalSecret."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["InfisicalSecret", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use InfisicalSecret.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[
        Optional[Literal["secrets.infisical.com/v1alpha1"]], Field(alias="apiVersion")
    ] = "secrets.infisical.com/v1alpha1"
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["InfisicalSecret"]] = "InfisicalSecret"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: Optional[InfisicalSecretSpec] = None
    status: Optional[InfisicalSecretStatus] = None


class Password(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Password"]:
            return Password

        def build(self) -> "Password":
            return Password(**self._attrs)

        def api_version(
            self, value: Optional[Literal["secrets.infisical.com/v1alpha1"]], /
        ) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["Password"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "Password.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "Password.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(self, value_or_callback: Optional[PasswordSpec], /) -> "Password.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [PasswordSpec.Builder], PasswordSpec.Builder | PasswordSpec
            ],
            /,
        ) -> "Password.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "PasswordSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = PasswordSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PasswordSpec.builder())
                if isinstance(output, PasswordSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

    class BuilderContext(BuilderContextBase["Password.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Password.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Password."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Password", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Password.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[
        Optional[Literal["secrets.infisical.com/v1alpha1"]], Field(alias="apiVersion")
    ] = "secrets.infisical.com/v1alpha1"
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["Password"]] = "Password"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: Optional[PasswordSpec] = None


class UUID(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["UUID"]:
            return UUID

        def build(self) -> "UUID":
            return UUID(**self._attrs)

        def api_version(
            self, value: Optional[Literal["secrets.infisical.com/v1alpha1"]], /
        ) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["UUID"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "UUID.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "UUID.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(self, value_or_callback: Optional[UUIDSpec], /) -> "UUID.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[[UUIDSpec.Builder], UUIDSpec.Builder | UUIDSpec],
            /,
        ) -> "UUID.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "UUIDSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = UUIDSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(UUIDSpec.builder())
                if isinstance(output, UUIDSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

    class BuilderContext(BuilderContextBase["UUID.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = UUID.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for UUID."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["UUID", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use UUID.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[
        Optional[Literal["secrets.infisical.com/v1alpha1"]], Field(alias="apiVersion")
    ] = "secrets.infisical.com/v1alpha1"
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["UUID"]] = "UUID"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: Optional[UUIDSpec] = None
