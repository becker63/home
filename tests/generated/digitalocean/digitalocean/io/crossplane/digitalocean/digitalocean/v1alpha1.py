# Generated by cloudcoil-model-codegen v0.5.8
# DO NOT EDIT


from __future__ import annotations

from typing import (
    Annotated,
    Callable,
    Dict,
    List,
    Literal,
    Optional,
    Type,
    overload,
)

from cloudcoil import apimachinery
from cloudcoil.pydantic import (
    BaseModel,
    BaseModelBuilder,
    BuilderContextBase,
    GenericListBuilder,
    ListBuilderContext,
    Never,
    Self,
)
from cloudcoil.resources import Resource
from pydantic import AwareDatetime, Field


class DedicatedIp(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["DedicatedIp"]:
            return DedicatedIp

        def build(self) -> "DedicatedIp":
            return DedicatedIp(**self._attrs)

        def id(self, value: Optional[str], /) -> Self:
            """
            The ID of the app.
            The ID of the dedicated egress IP.
            """
            return self._set("id", value)

        def ip(self, value: Optional[str], /) -> Self:
            """
            The IP address of the dedicated egress IP.
            """
            return self._set("ip", value)

        def status(self, value: Optional[str], /) -> Self:
            """
            The status of the dedicated egress IP: 'UNKNOWN', 'ASSIGNING', 'ASSIGNED', or 'REMOVED'
            """
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["DedicatedIp.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DedicatedIp.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DedicatedIp."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["DedicatedIp", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use DedicatedIp.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    id: Optional[str] = None
    """
    The ID of the app.
    The ID of the dedicated egress IP.
    """
    ip: Optional[str] = None
    """
    The IP address of the dedicated egress IP.
    """
    status: Optional[str] = None
    """
    The status of the dedicated egress IP: 'UNKNOWN', 'ASSIGNING', 'ASSIGNED', or 'REMOVED'
    """


class Policy(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Policy"]:
            return Policy

        def build(self) -> "Policy":
            return Policy(**self._attrs)

        def resolution(self, value: Optional[Literal["Required", "Optional"]], /) -> Self:
            """
            Resolution specifies whether resolution of this reference is required.
            The default is 'Required', which means the reconcile will fail if the
            reference cannot be resolved. 'Optional' means this reference will be
            a no-op if it cannot be resolved.
            """
            return self._set("resolution", value)

        def resolve(self, value: Optional[Literal["Always", "IfNotPresent"]], /) -> Self:
            """
            Resolve specifies when this reference should be resolved. The default
            is 'IfNotPresent', which will attempt to resolve the reference only when
            the corresponding field is not present. Use 'Always' to resolve the
            reference on every reconcile.
            """
            return self._set("resolve", value)

    class BuilderContext(BuilderContextBase["Policy.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Policy.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Policy."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Policy", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Policy.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    resolution: Optional[Literal["Required", "Optional"]] = "Required"
    """
    Resolution specifies whether resolution of this reference is required.
    The default is 'Required', which means the reconcile will fail if the
    reference cannot be resolved. 'Optional' means this reference will be
    a no-op if it cannot be resolved.
    """
    resolve: Optional[Literal["Always", "IfNotPresent"]] = None
    """
    Resolve specifies when this reference should be resolved. The default
    is 'IfNotPresent', which will attempt to resolve the reference only when
    the corresponding field is not present. Use 'Always' to resolve the
    reference on every reconcile.
    """


class ProjectIdRef(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ProjectIdRef"]:
            return ProjectIdRef

        def build(self) -> "ProjectIdRef":
            return ProjectIdRef(**self._attrs)

        def name(self, value: str, /) -> Self:
            """
            Name of the referenced object.
            """
            return self._set("name", value)

        @overload
        def policy(self, value_or_callback: Optional[Policy], /) -> "ProjectIdRef.Builder": ...

        @overload
        def policy(
            self,
            value_or_callback: Callable[[Policy.Builder], Policy.Builder | Policy],
            /,
        ) -> "ProjectIdRef.Builder": ...

        @overload
        def policy(self, value_or_callback: Never = ...) -> "Policy.BuilderContext": ...

        def policy(self, value_or_callback=None, /):
            """
            Policies for referencing.
            """
            if self._in_context and value_or_callback is None:
                context = Policy.BuilderContext()
                context._parent_builder = self
                context._field_name = "policy"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Policy.builder())
                if isinstance(output, Policy.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("policy", value)

    class BuilderContext(BuilderContextBase["ProjectIdRef.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ProjectIdRef.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ProjectIdRef."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ProjectIdRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ProjectIdRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: str
    """
    Name of the referenced object.
    """
    policy: Optional[Policy] = None
    """
    Policies for referencing.
    """


class ProjectIdSelector(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ProjectIdSelector"]:
            return ProjectIdSelector

        def build(self) -> "ProjectIdSelector":
            return ProjectIdSelector(**self._attrs)

        def match_controller_ref(self, value: Optional[bool], /) -> Self:
            """
            MatchControllerRef ensures an object with the same controller reference
            as the selecting object is selected.
            """
            return self._set("match_controller_ref", value)

        def match_labels(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            MatchLabels ensures an object with matching labels is selected.
            """
            return self._set("match_labels", value)

        @overload
        def policy(self, value_or_callback: Optional[Policy], /) -> "ProjectIdSelector.Builder": ...

        @overload
        def policy(
            self,
            value_or_callback: Callable[[Policy.Builder], Policy.Builder | Policy],
            /,
        ) -> "ProjectIdSelector.Builder": ...

        @overload
        def policy(self, value_or_callback: Never = ...) -> "Policy.BuilderContext": ...

        def policy(self, value_or_callback=None, /):
            """
            Policies for selection.
            """
            if self._in_context and value_or_callback is None:
                context = Policy.BuilderContext()
                context._parent_builder = self
                context._field_name = "policy"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Policy.builder())
                if isinstance(output, Policy.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("policy", value)

    class BuilderContext(BuilderContextBase["ProjectIdSelector.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ProjectIdSelector.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ProjectIdSelector."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ProjectIdSelector", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ProjectIdSelector.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    match_controller_ref: Annotated[Optional[bool], Field(alias="matchControllerRef")] = None
    """
    MatchControllerRef ensures an object with the same controller reference
    as the selecting object is selected.
    """
    match_labels: Annotated[Optional[Dict[str, str]], Field(alias="matchLabels")] = None
    """
    MatchLabels ensures an object with matching labels is selected.
    """
    policy: Optional[Policy] = None
    """
    Policies for selection.
    """


class Alert(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Alert"]:
            return Alert

        def build(self) -> "Alert":
            return Alert(**self._attrs)

        def disabled(self, value: Optional[bool], /) -> Self:
            """
            Determines whether or not the alert is disabled (default: false).
            """
            return self._set("disabled", value)

        def rule(self, value: Optional[str], /) -> Self:
            """
            The type of the alert to configure. Top-level app alert policies can be: DEPLOYMENT_CANCELLED, DEPLOYMENT_FAILED, DEPLOYMENT_LIVE, DEPLOYMENT_STARTED, DOMAIN_FAILED, or DOMAIN_LIVE.
            """
            return self._set("rule", value)

    class BuilderContext(BuilderContextBase["Alert.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Alert.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Alert."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Alert", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Alert.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    disabled: Optional[bool] = None
    """
    Determines whether or not the alert is disabled (default: false).
    """
    rule: Optional[str] = None
    """
    The type of the alert to configure. Top-level app alert policies can be: DEPLOYMENT_CANCELLED, DEPLOYMENT_FAILED, DEPLOYMENT_LIVE, DEPLOYMENT_STARTED, DOMAIN_FAILED, or DOMAIN_LIVE.
    """


class Database(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Database"]:
            return Database

        def build(self) -> "Database":
            return Database(**self._attrs)

        def cluster_name(self, value: Optional[str], /) -> Self:
            """
            The name of a DigitalOcean DBaaS OpenSearch cluster to use as a log forwarding destination. Cannot be specified if endpoint is also specified.
            The name of the underlying DigitalOcean DBaaS cluster. This is required for production databases. For dev databases, if cluster_name is not set, a new cluster will be provisioned.
            """
            return self._set("cluster_name", value)

        def db_name(self, value: Optional[str], /) -> Self:
            """
            The name of the MySQL or PostgreSQL database to configure.
            The name of the MySQL or PostgreSQL database to configure.
            """
            return self._set("db_name", value)

        def db_user(self, value: Optional[str], /) -> Self:
            """
            The name of the MySQL or PostgreSQL user to configure.
            The name of the MySQL or PostgreSQL user to configure.
            """
            return self._set("db_user", value)

        def engine(self, value: Optional[str], /) -> Self:
            """
            The database engine to use (MYSQL, PG, REDIS, MONGODB, KAFKA, or OPENSEARCH).
            The database engine to use.
            """
            return self._set("engine", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            The name of the app. Must be unique across all apps in the same account.
            The name of the component
            """
            return self._set("name", value)

        def production(self, value: Optional[bool], /) -> Self:
            """
            Whether this is a production or dev database.
            Whether this is a production or dev database.
            """
            return self._set("production", value)

        def version(self, value: Optional[str], /) -> Self:
            """
            The version of the database engine.
            The version of the database engine.
            """
            return self._set("version", value)

    class BuilderContext(BuilderContextBase["Database.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Database.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Database."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Database", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Database.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    cluster_name: Annotated[Optional[str], Field(alias="clusterName")] = None
    """
    The name of a DigitalOcean DBaaS OpenSearch cluster to use as a log forwarding destination. Cannot be specified if endpoint is also specified.
    The name of the underlying DigitalOcean DBaaS cluster. This is required for production databases. For dev databases, if cluster_name is not set, a new cluster will be provisioned.
    """
    db_name: Annotated[Optional[str], Field(alias="dbName")] = None
    """
    The name of the MySQL or PostgreSQL database to configure.
    The name of the MySQL or PostgreSQL database to configure.
    """
    db_user: Annotated[Optional[str], Field(alias="dbUser")] = None
    """
    The name of the MySQL or PostgreSQL user to configure.
    The name of the MySQL or PostgreSQL user to configure.
    """
    engine: Optional[str] = None
    """
    The database engine to use (MYSQL, PG, REDIS, MONGODB, KAFKA, or OPENSEARCH).
    The database engine to use.
    """
    name: Optional[str] = None
    """
    The name of the app. Must be unique across all apps in the same account.
    The name of the component
    """
    production: Optional[bool] = None
    """
    Whether this is a production or dev database.
    Whether this is a production or dev database.
    """
    version: Optional[str] = None
    """
    The version of the database engine.
    The version of the database engine.
    """


class Domain(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Domain"]:
            return Domain

        def build(self) -> "Domain":
            return Domain(**self._attrs)

        def name(self, value: Optional[str], /) -> Self:
            """
            The name of the app. Must be unique across all apps in the same account.
            The hostname for the domain.
            """
            return self._set("name", value)

        def type(self, value: Optional[str], /) -> Self:
            """
            The domain type, which can be one of the following:
            The type of the domain.
            """
            return self._set("type", value)

        def wildcard(self, value: Optional[bool], /) -> Self:
            """
            A boolean indicating whether the domain includes all sub-domains, in addition to the given domain.
            Indicates whether the domain includes all sub-domains, in addition to the given domain.
            """
            return self._set("wildcard", value)

        def zone(self, value: Optional[str], /) -> Self:
            """
            If the domain uses DigitalOcean DNS and you would like App Platform to automatically manage it for you, set this to the name of the domain on your account.
            If the domain uses DigitalOcean DNS and you would like App Platform to automatically manage it for you, set this to the name of the domain on your account.
            """
            return self._set("zone", value)

    class BuilderContext(BuilderContextBase["Domain.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Domain.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Domain."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Domain", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Domain.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: Optional[str] = None
    """
    The name of the app. Must be unique across all apps in the same account.
    The hostname for the domain.
    """
    type: Optional[str] = None
    """
    The domain type, which can be one of the following:
    The type of the domain.
    """
    wildcard: Optional[bool] = None
    """
    A boolean indicating whether the domain includes all sub-domains, in addition to the given domain.
    Indicates whether the domain includes all sub-domains, in addition to the given domain.
    """
    zone: Optional[str] = None
    """
    If the domain uses DigitalOcean DNS and you would like App Platform to automatically manage it for you, set this to the name of the domain on your account.
    If the domain uses DigitalOcean DNS and you would like App Platform to automatically manage it for you, set this to the name of the domain on your account.
    """


class Egres(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Egres"]:
            return Egres

        def build(self) -> "Egres":
            return Egres(**self._attrs)

        def type(self, value: Optional[str], /) -> Self:
            """
            The domain type, which can be one of the following:
            The app egress type.
            """
            return self._set("type", value)

    class BuilderContext(BuilderContextBase["Egres.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Egres.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Egres."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Egres", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Egres.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    type: Optional[str] = None
    """
    The domain type, which can be one of the following:
    The app egress type.
    """


class ValueSecretRef(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ValueSecretRef"]:
            return ValueSecretRef

        def build(self) -> "ValueSecretRef":
            return ValueSecretRef(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            The key to select.
            """
            return self._set("key", value)

        def name(self, value: str, /) -> Self:
            """
            Name of the secret.
            """
            return self._set("name", value)

        def namespace(self, value: str, /) -> Self:
            """
            Namespace of the secret.
            """
            return self._set("namespace", value)

    class BuilderContext(BuilderContextBase["ValueSecretRef.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ValueSecretRef.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ValueSecretRef."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ValueSecretRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ValueSecretRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: str
    """
    The key to select.
    """
    name: str
    """
    Name of the secret.
    """
    namespace: str
    """
    Namespace of the secret.
    """


class Env(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Env"]:
            return Env

        def build(self) -> "Env":
            return Env(**self._attrs)

        def key(self, value: Optional[str], /) -> Self:
            """
            The name of the environment variable.
            The name of the environment variable.
            """
            return self._set("key", value)

        def scope(self, value: Optional[str], /) -> Self:
            """
            The visibility scope of the environment variable. One of RUN_TIME, BUILD_TIME, or RUN_AND_BUILD_TIME (default).
            The visibility scope of the environment variable.
            """
            return self._set("scope", value)

        def type(self, value: Optional[str], /) -> Self:
            """
            The domain type, which can be one of the following:
            The type of the environment variable.
            """
            return self._set("type", value)

        @overload
        def value_secret_ref(
            self, value_or_callback: Optional[ValueSecretRef], /
        ) -> "Env.Builder": ...

        @overload
        def value_secret_ref(
            self,
            value_or_callback: Callable[
                [ValueSecretRef.Builder], ValueSecretRef.Builder | ValueSecretRef
            ],
            /,
        ) -> "Env.Builder": ...

        @overload
        def value_secret_ref(
            self, value_or_callback: Never = ...
        ) -> "ValueSecretRef.BuilderContext": ...

        def value_secret_ref(self, value_or_callback=None, /):
            """
            The value of the environment variable.
            The value of the environment variable.
            """
            if self._in_context and value_or_callback is None:
                context = ValueSecretRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "value_secret_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ValueSecretRef.builder())
                if isinstance(output, ValueSecretRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("value_secret_ref", value)

    class BuilderContext(BuilderContextBase["Env.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Env.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Env."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Env", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Env.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: Optional[str] = None
    """
    The name of the environment variable.
    The name of the environment variable.
    """
    scope: Optional[str] = None
    """
    The visibility scope of the environment variable. One of RUN_TIME, BUILD_TIME, or RUN_AND_BUILD_TIME (default).
    The visibility scope of the environment variable.
    """
    type: Optional[str] = None
    """
    The domain type, which can be one of the following:
    The type of the environment variable.
    """
    value_secret_ref: Annotated[Optional[ValueSecretRef], Field(alias="valueSecretRef")] = None
    """
    The value of the environment variable.
    The value of the environment variable.
    """


class AlertModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AlertModel"]:
            return AlertModel

        def build(self) -> "AlertModel":
            return AlertModel(**self._attrs)

        def disabled(self, value: Optional[bool], /) -> Self:
            """
            Determines whether or not the alert is disabled (default: false).
            """
            return self._set("disabled", value)

        def operator(self, value: Optional[str], /) -> Self:
            """
            The operator to use. This is either of GREATER_THAN or LESS_THAN.
            """
            return self._set("operator", value)

        def rule(self, value: Optional[str], /) -> Self:
            """
            The type of the alert to configure. Top-level app alert policies can be: DEPLOYMENT_CANCELLED, DEPLOYMENT_FAILED, DEPLOYMENT_LIVE, DEPLOYMENT_STARTED, DOMAIN_FAILED, or DOMAIN_LIVE.
            """
            return self._set("rule", value)

        def value(self, value: Optional[float], /) -> Self:
            """
            The value of the environment variable.
            """
            return self._set("value", value)

        def window(self, value: Optional[str], /) -> Self:
            """
            The time before alerts should be triggered. This is may be one of: FIVE_MINUTES, TEN_MINUTES, THIRTY_MINUTES, ONE_HOUR.
            """
            return self._set("window", value)

    class BuilderContext(BuilderContextBase["AlertModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AlertModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AlertModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AlertModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AlertModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    disabled: Optional[bool] = None
    """
    Determines whether or not the alert is disabled (default: false).
    """
    operator: Optional[str] = None
    """
    The operator to use. This is either of GREATER_THAN or LESS_THAN.
    """
    rule: Optional[str] = None
    """
    The type of the alert to configure. Top-level app alert policies can be: DEPLOYMENT_CANCELLED, DEPLOYMENT_FAILED, DEPLOYMENT_LIVE, DEPLOYMENT_STARTED, DOMAIN_FAILED, or DOMAIN_LIVE.
    """
    value: Optional[float] = None
    """
    The value of the environment variable.
    """
    window: Optional[str] = None
    """
    The time before alerts should be triggered. This is may be one of: FIVE_MINUTES, TEN_MINUTES, THIRTY_MINUTES, ONE_HOUR.
    """


class AllowOrigin(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AllowOrigin"]:
            return AllowOrigin

        def build(self) -> "AllowOrigin":
            return AllowOrigin(**self._attrs)

        def exact(self, value: Optional[str], /) -> Self:
            """
            The Access-Control-Allow-Origin header will be set to the client's origin only if the client's origin exactly matches the value you provide.
            Exact string match.
            """
            return self._set("exact", value)

        def prefix(self, value: Optional[str], /) -> Self:
            """
            Prefix-based match.
            Prefix-based match.
            """
            return self._set("prefix", value)

        def regex(self, value: Optional[str], /) -> Self:
            """
            The Access-Control-Allow-Origin header will be set to the client's origin if the client’s origin matches the regex you provide, in RE2 style syntax.
            RE2 style regex-based match.
            """
            return self._set("regex", value)

    class BuilderContext(BuilderContextBase["AllowOrigin.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AllowOrigin.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AllowOrigin."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AllowOrigin", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AllowOrigin.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    exact: Optional[str] = None
    """
    The Access-Control-Allow-Origin header will be set to the client's origin only if the client's origin exactly matches the value you provide.
    Exact string match.
    """
    prefix: Optional[str] = None
    """
    Prefix-based match.
    Prefix-based match.
    """
    regex: Optional[str] = None
    """
    The Access-Control-Allow-Origin header will be set to the client's origin if the client’s origin matches the regex you provide, in RE2 style syntax.
    RE2 style regex-based match.
    """


class Cor(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Cor"]:
            return Cor

        def build(self) -> "Cor":
            return Cor(**self._attrs)

        def allow_credentials(self, value: Optional[bool], /) -> Self:
            """
            Whether browsers should expose the response to the client-side JavaScript code when the request's credentials mode is include. This configures the Access-Control-Allow-Credentials header.
            Whether browsers should expose the response to the client-side JavaScript code when the request’s credentials mode is `include`. This configures the Access-Control-Allow-Credentials header.
            """
            return self._set("allow_credentials", value)

        def allow_headers(self, value: Optional[List[str]], /) -> Self:
            """
            The set of allowed HTTP request headers. This configures the Access-Control-Allow-Headers header.
            The set of allowed HTTP request headers. This configures the Access-Control-Allow-Headers header.
            """
            return self._set("allow_headers", value)

        def allow_methods(self, value: Optional[List[str]], /) -> Self:
            """
            The set of allowed HTTP methods. This configures the Access-Control-Allow-Methods header.
            The set of allowed HTTP methods. This configures the Access-Control-Allow-Methods header.
            """
            return self._set("allow_methods", value)

        @overload
        def allow_origins(self, value_or_callback: List[AllowOrigin], /) -> "Cor.Builder": ...

        @overload
        def allow_origins(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[AllowOrigin, AllowOrigin.Builder]],
                GenericListBuilder[AllowOrigin, AllowOrigin.Builder] | List[AllowOrigin],
            ],
            /,
        ) -> "Cor.Builder": ...

        @overload
        def allow_origins(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[AllowOrigin.Builder]: ...

        def allow_origins(self, value_or_callback=None, /):
            """
            The Access-Control-Allow-Origin can be
            The set of allowed CORS origins. This configures the Access-Control-Allow-Origin header.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[AllowOrigin.Builder]()
                context._parent_builder = self
                context._field_name = "allow_origins"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AllowOrigin.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("allow_origins", value)

        def expose_headers(self, value: Optional[List[str]], /) -> Self:
            """
            The set of HTTP response headers that browsers are allowed to access. This configures the Access-Control-Expose-Headers header.
            The set of HTTP response headers that browsers are allowed to access. This configures the Access-Control-Expose-Headers header.
            """
            return self._set("expose_headers", value)

        def max_age(self, value: Optional[str], /) -> Self:
            """
            An optional duration specifying how long browsers can cache the results of a preflight request. This configures the Access-Control-Max-Age header. Example: 5h30m.
            An optional duration specifying how long browsers can cache the results of a preflight request. This configures the Access-Control-Max-Age header. Example: `5h30m`.
            """
            return self._set("max_age", value)

    class BuilderContext(BuilderContextBase["Cor.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Cor.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Cor."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Cor", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Cor.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    allow_credentials: Annotated[Optional[bool], Field(alias="allowCredentials")] = None
    """
    Whether browsers should expose the response to the client-side JavaScript code when the request's credentials mode is include. This configures the Access-Control-Allow-Credentials header.
    Whether browsers should expose the response to the client-side JavaScript code when the request’s credentials mode is `include`. This configures the Access-Control-Allow-Credentials header.
    """
    allow_headers: Annotated[Optional[List[str]], Field(alias="allowHeaders")] = None
    """
    The set of allowed HTTP request headers. This configures the Access-Control-Allow-Headers header.
    The set of allowed HTTP request headers. This configures the Access-Control-Allow-Headers header.
    """
    allow_methods: Annotated[Optional[List[str]], Field(alias="allowMethods")] = None
    """
    The set of allowed HTTP methods. This configures the Access-Control-Allow-Methods header.
    The set of allowed HTTP methods. This configures the Access-Control-Allow-Methods header.
    """
    allow_origins: Annotated[Optional[List[AllowOrigin]], Field(alias="allowOrigins")] = None
    """
    The Access-Control-Allow-Origin can be
    The set of allowed CORS origins. This configures the Access-Control-Allow-Origin header.
    """
    expose_headers: Annotated[Optional[List[str]], Field(alias="exposeHeaders")] = None
    """
    The set of HTTP response headers that browsers are allowed to access. This configures the Access-Control-Expose-Headers header.
    The set of HTTP response headers that browsers are allowed to access. This configures the Access-Control-Expose-Headers header.
    """
    max_age: Annotated[Optional[str], Field(alias="maxAge")] = None
    """
    An optional duration specifying how long browsers can cache the results of a preflight request. This configures the Access-Control-Max-Age header. Example: 5h30m.
    An optional duration specifying how long browsers can cache the results of a preflight request. This configures the Access-Control-Max-Age header. Example: `5h30m`.
    """


class Git(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Git"]:
            return Git

        def build(self) -> "Git":
            return Git(**self._attrs)

        def branch(self, value: Optional[str], /) -> Self:
            """
            The name of the branch to use.
            The name of the branch to use.
            """
            return self._set("branch", value)

        def repo_clone_url(self, value: Optional[str], /) -> Self:
            """
            The clone URL of the repo.
            The clone URL of the repo.
            """
            return self._set("repo_clone_url", value)

    class BuilderContext(BuilderContextBase["Git.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Git.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Git."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Git", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Git.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    branch: Optional[str] = None
    """
    The name of the branch to use.
    The name of the branch to use.
    """
    repo_clone_url: Annotated[Optional[str], Field(alias="repoCloneUrl")] = None
    """
    The clone URL of the repo.
    The clone URL of the repo.
    """


class Github(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Github"]:
            return Github

        def build(self) -> "Github":
            return Github(**self._attrs)

        def branch(self, value: Optional[str], /) -> Self:
            """
            The name of the branch to use.
            The name of the branch to use.
            """
            return self._set("branch", value)

        def deploy_on_push(self, value: Optional[bool], /) -> Self:
            """
            Whether to automatically deploy new commits made to the repo.
            Whether to automatically deploy new commits made to the repo
            """
            return self._set("deploy_on_push", value)

        def repo(self, value: Optional[str], /) -> Self:
            """
            The name of the repo in the format owner/repo.
            The name of the repo in the format `owner/repo`.
            """
            return self._set("repo", value)

    class BuilderContext(BuilderContextBase["Github.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Github.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Github."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Github", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Github.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    branch: Optional[str] = None
    """
    The name of the branch to use.
    The name of the branch to use.
    """
    deploy_on_push: Annotated[Optional[bool], Field(alias="deployOnPush")] = None
    """
    Whether to automatically deploy new commits made to the repo.
    Whether to automatically deploy new commits made to the repo
    """
    repo: Optional[str] = None
    """
    The name of the repo in the format owner/repo.
    The name of the repo in the format `owner/repo`.
    """


class Gitlab(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Gitlab"]:
            return Gitlab

        def build(self) -> "Gitlab":
            return Gitlab(**self._attrs)

        def branch(self, value: Optional[str], /) -> Self:
            """
            The name of the branch to use.
            The name of the branch to use.
            """
            return self._set("branch", value)

        def deploy_on_push(self, value: Optional[bool], /) -> Self:
            """
            Whether to automatically deploy new commits made to the repo.
            Whether to automatically deploy new commits made to the repo
            """
            return self._set("deploy_on_push", value)

        def repo(self, value: Optional[str], /) -> Self:
            """
            The name of the repo in the format owner/repo.
            The name of the repo in the format `owner/repo`.
            """
            return self._set("repo", value)

    class BuilderContext(BuilderContextBase["Gitlab.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Gitlab.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Gitlab."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Gitlab", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Gitlab.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    branch: Optional[str] = None
    """
    The name of the branch to use.
    The name of the branch to use.
    """
    deploy_on_push: Annotated[Optional[bool], Field(alias="deployOnPush")] = None
    """
    Whether to automatically deploy new commits made to the repo.
    Whether to automatically deploy new commits made to the repo
    """
    repo: Optional[str] = None
    """
    The name of the repo in the format owner/repo.
    The name of the repo in the format `owner/repo`.
    """


class Datadog(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Datadog"]:
            return Datadog

        def build(self) -> "Datadog":
            return Datadog(**self._attrs)

        def api_key(self, value: Optional[str], /) -> Self:
            """
            Datadog API key.
            Datadog API key.
            """
            return self._set("api_key", value)

        def endpoint(self, value: Optional[str], /) -> Self:
            """
            Papertrail syslog endpoint.
            Datadog HTTP log intake endpoint.
            """
            return self._set("endpoint", value)

    class BuilderContext(BuilderContextBase["Datadog.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Datadog.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Datadog."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Datadog", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Datadog.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_key: Annotated[Optional[str], Field(alias="apiKey")] = None
    """
    Datadog API key.
    Datadog API key.
    """
    endpoint: Optional[str] = None
    """
    Papertrail syslog endpoint.
    Datadog HTTP log intake endpoint.
    """


class Logtail(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Logtail"]:
            return Logtail

        def build(self) -> "Logtail":
            return Logtail(**self._attrs)

        def token(self, value: Optional[str], /) -> Self:
            """
            Logtail token.
            Logtail token.
            """
            return self._set("token", value)

    class BuilderContext(BuilderContextBase["Logtail.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Logtail.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Logtail."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Logtail", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Logtail.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    token: Optional[str] = None
    """
    Logtail token.
    Logtail token.
    """


class PasswordSecretRef(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PasswordSecretRef"]:
            return PasswordSecretRef

        def build(self) -> "PasswordSecretRef":
            return PasswordSecretRef(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            The key to select.
            """
            return self._set("key", value)

        def name(self, value: str, /) -> Self:
            """
            Name of the secret.
            """
            return self._set("name", value)

        def namespace(self, value: str, /) -> Self:
            """
            Namespace of the secret.
            """
            return self._set("namespace", value)

    class BuilderContext(BuilderContextBase["PasswordSecretRef.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PasswordSecretRef.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PasswordSecretRef."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["PasswordSecretRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PasswordSecretRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: str
    """
    The key to select.
    """
    name: str
    """
    Name of the secret.
    """
    namespace: str
    """
    Namespace of the secret.
    """


class BasicAuth(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["BasicAuth"]:
            return BasicAuth

        def build(self) -> "BasicAuth":
            return BasicAuth(**self._attrs)

        @overload
        def password_secret_ref(
            self, value_or_callback: Optional[PasswordSecretRef], /
        ) -> "BasicAuth.Builder": ...

        @overload
        def password_secret_ref(
            self,
            value_or_callback: Callable[
                [PasswordSecretRef.Builder],
                PasswordSecretRef.Builder | PasswordSecretRef,
            ],
            /,
        ) -> "BasicAuth.Builder": ...

        @overload
        def password_secret_ref(
            self, value_or_callback: Never = ...
        ) -> "PasswordSecretRef.BuilderContext": ...

        def password_secret_ref(self, value_or_callback=None, /):
            """
            Password for user defined in User. Is required when endpoint is set. Cannot be set if using a DigitalOcean DBaaS OpenSearch cluster.
            Password for basic authentication.
            """
            if self._in_context and value_or_callback is None:
                context = PasswordSecretRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "password_secret_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PasswordSecretRef.builder())
                if isinstance(output, PasswordSecretRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("password_secret_ref", value)

        def user(self, value: Optional[str], /) -> Self:
            """
            Username to authenticate with. Only required when endpoint is set. Defaults to doadmin when cluster_name is set.
            user for basic authentication.
            """
            return self._set("user", value)

    class BuilderContext(BuilderContextBase["BasicAuth.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = BasicAuth.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for BasicAuth."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["BasicAuth", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use BasicAuth.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    password_secret_ref: Annotated[
        Optional[PasswordSecretRef], Field(alias="passwordSecretRef")
    ] = None
    """
    Password for user defined in User. Is required when endpoint is set. Cannot be set if using a DigitalOcean DBaaS OpenSearch cluster.
    Password for basic authentication.
    """
    user: Optional[str] = None
    """
    Username to authenticate with. Only required when endpoint is set. Defaults to doadmin when cluster_name is set.
    user for basic authentication.
    """


class OpenSearch(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["OpenSearch"]:
            return OpenSearch

        def build(self) -> "OpenSearch":
            return OpenSearch(**self._attrs)

        @overload
        def basic_auth(self, value_or_callback: List[BasicAuth], /) -> "OpenSearch.Builder": ...

        @overload
        def basic_auth(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[BasicAuth, BasicAuth.Builder]],
                GenericListBuilder[BasicAuth, BasicAuth.Builder] | List[BasicAuth],
            ],
            /,
        ) -> "OpenSearch.Builder": ...

        @overload
        def basic_auth(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[BasicAuth.Builder]: ...

        def basic_auth(self, value_or_callback=None, /):
            """
            OpenSearch basic auth
            Basic authentication details.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[BasicAuth.Builder]()
                context._parent_builder = self
                context._field_name = "basic_auth"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(BasicAuth.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("basic_auth", value)

        def cluster_name(self, value: Optional[str], /) -> Self:
            """
            The name of a DigitalOcean DBaaS OpenSearch cluster to use as a log forwarding destination. Cannot be specified if endpoint is also specified.
            OpenSearch cluster name.
            """
            return self._set("cluster_name", value)

        def endpoint(self, value: Optional[str], /) -> Self:
            """
            Papertrail syslog endpoint.
            OpenSearch endpoint.
            """
            return self._set("endpoint", value)

        def index_name(self, value: Optional[str], /) -> Self:
            """
            The index name to use for the logs. If not set, the default index name is logs.
            OpenSearch index name.
            """
            return self._set("index_name", value)

    class BuilderContext(BuilderContextBase["OpenSearch.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = OpenSearch.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for OpenSearch."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["OpenSearch", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use OpenSearch.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    basic_auth: Annotated[Optional[List[BasicAuth]], Field(alias="basicAuth")] = None
    """
    OpenSearch basic auth
    Basic authentication details.
    """
    cluster_name: Annotated[Optional[str], Field(alias="clusterName")] = None
    """
    The name of a DigitalOcean DBaaS OpenSearch cluster to use as a log forwarding destination. Cannot be specified if endpoint is also specified.
    OpenSearch cluster name.
    """
    endpoint: Optional[str] = None
    """
    Papertrail syslog endpoint.
    OpenSearch endpoint.
    """
    index_name: Annotated[Optional[str], Field(alias="indexName")] = None
    """
    The index name to use for the logs. If not set, the default index name is logs.
    OpenSearch index name.
    """


class Papertrail(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Papertrail"]:
            return Papertrail

        def build(self) -> "Papertrail":
            return Papertrail(**self._attrs)

        def endpoint(self, value: Optional[str], /) -> Self:
            """
            Papertrail syslog endpoint.
            Papertrail syslog endpoint.
            """
            return self._set("endpoint", value)

    class BuilderContext(BuilderContextBase["Papertrail.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Papertrail.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Papertrail."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Papertrail", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Papertrail.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    endpoint: Optional[str] = None
    """
    Papertrail syslog endpoint.
    Papertrail syslog endpoint.
    """


class LogDestination(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["LogDestination"]:
            return LogDestination

        def build(self) -> "LogDestination":
            return LogDestination(**self._attrs)

        @overload
        def datadog(self, value_or_callback: List[Datadog], /) -> "LogDestination.Builder": ...

        @overload
        def datadog(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Datadog, Datadog.Builder]],
                GenericListBuilder[Datadog, Datadog.Builder] | List[Datadog],
            ],
            /,
        ) -> "LogDestination.Builder": ...

        @overload
        def datadog(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Datadog.Builder]: ...

        def datadog(self, value_or_callback=None, /):
            """
            Datadog configuration.
            Datadog configuration.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Datadog.Builder]()
                context._parent_builder = self
                context._field_name = "datadog"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Datadog.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("datadog", value)

        @overload
        def logtail(self, value_or_callback: List[Logtail], /) -> "LogDestination.Builder": ...

        @overload
        def logtail(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Logtail, Logtail.Builder]],
                GenericListBuilder[Logtail, Logtail.Builder] | List[Logtail],
            ],
            /,
        ) -> "LogDestination.Builder": ...

        @overload
        def logtail(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Logtail.Builder]: ...

        def logtail(self, value_or_callback=None, /):
            """
            Logtail configuration.
            Logtail configuration.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Logtail.Builder]()
                context._parent_builder = self
                context._field_name = "logtail"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Logtail.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("logtail", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            The name of the app. Must be unique across all apps in the same account.
            Name of the log destination
            """
            return self._set("name", value)

        @overload
        def open_search(
            self, value_or_callback: List[OpenSearch], /
        ) -> "LogDestination.Builder": ...

        @overload
        def open_search(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[OpenSearch, OpenSearch.Builder]],
                GenericListBuilder[OpenSearch, OpenSearch.Builder] | List[OpenSearch],
            ],
            /,
        ) -> "LogDestination.Builder": ...

        @overload
        def open_search(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[OpenSearch.Builder]: ...

        def open_search(self, value_or_callback=None, /):
            """
            OpenSearch configuration.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[OpenSearch.Builder]()
                context._parent_builder = self
                context._field_name = "open_search"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(OpenSearch.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("open_search", value)

        @overload
        def papertrail(
            self, value_or_callback: List[Papertrail], /
        ) -> "LogDestination.Builder": ...

        @overload
        def papertrail(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Papertrail, Papertrail.Builder]],
                GenericListBuilder[Papertrail, Papertrail.Builder] | List[Papertrail],
            ],
            /,
        ) -> "LogDestination.Builder": ...

        @overload
        def papertrail(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Papertrail.Builder]: ...

        def papertrail(self, value_or_callback=None, /):
            """
            Papertrail configuration.
            Papertrail configuration.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Papertrail.Builder]()
                context._parent_builder = self
                context._field_name = "papertrail"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Papertrail.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("papertrail", value)

    class BuilderContext(BuilderContextBase["LogDestination.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = LogDestination.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for LogDestination."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["LogDestination", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use LogDestination.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    datadog: Optional[List[Datadog]] = None
    """
    Datadog configuration.
    Datadog configuration.
    """
    logtail: Optional[List[Logtail]] = None
    """
    Logtail configuration.
    Logtail configuration.
    """
    name: Optional[str] = None
    """
    The name of the app. Must be unique across all apps in the same account.
    Name of the log destination
    """
    open_search: Annotated[Optional[List[OpenSearch]], Field(alias="openSearch")] = None
    """
    OpenSearch configuration.
    """
    papertrail: Optional[List[Papertrail]] = None
    """
    Papertrail configuration.
    Papertrail configuration.
    """


class Route(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Route"]:
            return Route

        def build(self) -> "Route":
            return Route(**self._attrs)

        def path(self, value: Optional[str], /) -> Self:
            """
            The path to match on.
            Path specifies an route by HTTP path prefix. Paths must start with / and must be unique within the app.
            """
            return self._set("path", value)

        def preserve_path_prefix(self, value: Optional[bool], /) -> Self:
            """
            An optional boolean flag to preserve the path that is forwarded to the backend service. By default, the HTTP request path will be trimmed from the left when forwarded to the component.
            An optional flag to preserve the path that is forwarded to the backend service.
            """
            return self._set("preserve_path_prefix", value)

    class BuilderContext(BuilderContextBase["Route.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Route.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Route."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Route", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Route.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    path: Optional[str] = None
    """
    The path to match on.
    Path specifies an route by HTTP path prefix. Paths must start with / and must be unique within the app.
    """
    preserve_path_prefix: Annotated[Optional[bool], Field(alias="preservePathPrefix")] = None
    """
    An optional boolean flag to preserve the path that is forwarded to the backend service. By default, the HTTP request path will be trimmed from the left when forwarded to the component.
    An optional flag to preserve the path that is forwarded to the backend service.
    """


class Function(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Function"]:
            return Function

        def build(self) -> "Function":
            return Function(**self._attrs)

        @overload
        def alert(self, value_or_callback: List[AlertModel], /) -> "Function.Builder": ...

        @overload
        def alert(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[AlertModel, AlertModel.Builder]],
                GenericListBuilder[AlertModel, AlertModel.Builder] | List[AlertModel],
            ],
            /,
        ) -> "Function.Builder": ...

        @overload
        def alert(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[AlertModel.Builder]: ...

        def alert(self, value_or_callback=None, /):
            """
            Describes an alert policy for the app.
            Alert policies for the app component
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[AlertModel.Builder]()
                context._parent_builder = self
                context._field_name = "alert"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AlertModel.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("alert", value)

        @overload
        def cors(self, value_or_callback: List[Cor], /) -> "Function.Builder": ...

        @overload
        def cors(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Cor, Cor.Builder]],
                GenericListBuilder[Cor, Cor.Builder] | List[Cor],
            ],
            /,
        ) -> "Function.Builder": ...

        @overload
        def cors(self, value_or_callback: Never = ...) -> ListBuilderContext[Cor.Builder]: ...

        def cors(self, value_or_callback=None, /):
            """
            The CORS policies of the app.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Cor.Builder]()
                context._parent_builder = self
                context._field_name = "cors"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Cor.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("cors", value)

        @overload
        def env(self, value_or_callback: List[Env], /) -> "Function.Builder": ...

        @overload
        def env(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Env, Env.Builder]],
                GenericListBuilder[Env, Env.Builder] | List[Env],
            ],
            /,
        ) -> "Function.Builder": ...

        @overload
        def env(self, value_or_callback: Never = ...) -> ListBuilderContext[Env.Builder]: ...

        def env(self, value_or_callback=None, /):
            """
            Describes an app-wide environment variable made available to all components.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Env.Builder]()
                context._parent_builder = self
                context._field_name = "env"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Env.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("env", value)

        @overload
        def git(self, value_or_callback: List[Git], /) -> "Function.Builder": ...

        @overload
        def git(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Git, Git.Builder]],
                GenericListBuilder[Git, Git.Builder] | List[Git],
            ],
            /,
        ) -> "Function.Builder": ...

        @overload
        def git(self, value_or_callback: Never = ...) -> ListBuilderContext[Git.Builder]: ...

        def git(self, value_or_callback=None, /):
            """
            A Git repo to use as the component's source. The repository must be able to be cloned without authentication. Only one of git, github or gitlab may be set
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Git.Builder]()
                context._parent_builder = self
                context._field_name = "git"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Git.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("git", value)

        @overload
        def github(self, value_or_callback: List[Github], /) -> "Function.Builder": ...

        @overload
        def github(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Github, Github.Builder]],
                GenericListBuilder[Github, Github.Builder] | List[Github],
            ],
            /,
        ) -> "Function.Builder": ...

        @overload
        def github(self, value_or_callback: Never = ...) -> ListBuilderContext[Github.Builder]: ...

        def github(self, value_or_callback=None, /):
            """
            A GitHub repo to use as the component's source. DigitalOcean App Platform must have access to the repository. Only one of git, github, gitlab, or image may be set.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Github.Builder]()
                context._parent_builder = self
                context._field_name = "github"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Github.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("github", value)

        @overload
        def gitlab(self, value_or_callback: List[Gitlab], /) -> "Function.Builder": ...

        @overload
        def gitlab(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Gitlab, Gitlab.Builder]],
                GenericListBuilder[Gitlab, Gitlab.Builder] | List[Gitlab],
            ],
            /,
        ) -> "Function.Builder": ...

        @overload
        def gitlab(self, value_or_callback: Never = ...) -> ListBuilderContext[Gitlab.Builder]: ...

        def gitlab(self, value_or_callback=None, /):
            """
            A Gitlab repo to use as the component's source. DigitalOcean App Platform must have access to the repository. Only one of git, github, gitlab, or image may be set.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Gitlab.Builder]()
                context._parent_builder = self
                context._field_name = "gitlab"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Gitlab.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("gitlab", value)

        @overload
        def log_destination(
            self, value_or_callback: List[LogDestination], /
        ) -> "Function.Builder": ...

        @overload
        def log_destination(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[LogDestination, LogDestination.Builder]],
                GenericListBuilder[LogDestination, LogDestination.Builder] | List[LogDestination],
            ],
            /,
        ) -> "Function.Builder": ...

        @overload
        def log_destination(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[LogDestination.Builder]: ...

        def log_destination(self, value_or_callback=None, /):
            """
            Describes a log forwarding destination.
            Logs
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[LogDestination.Builder]()
                context._parent_builder = self
                context._field_name = "log_destination"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(LogDestination.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("log_destination", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            The name of the app. Must be unique across all apps in the same account.
            The name of the component
            """
            return self._set("name", value)

        @overload
        def routes(self, value_or_callback: List[Route], /) -> "Function.Builder": ...

        @overload
        def routes(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Route, Route.Builder]],
                GenericListBuilder[Route, Route.Builder] | List[Route],
            ],
            /,
        ) -> "Function.Builder": ...

        @overload
        def routes(self, value_or_callback: Never = ...) -> ListBuilderContext[Route.Builder]: ...

        def routes(self, value_or_callback=None, /):
            """
            (Deprecated - use ingress) An HTTP paths that should be routed to this component.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Route.Builder]()
                context._parent_builder = self
                context._field_name = "routes"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Route.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("routes", value)

        def source_dir(self, value: Optional[str], /) -> Self:
            """
            An optional path to the working directory to use for the build.
            An optional path to the working directory to use for the build.
            """
            return self._set("source_dir", value)

    class BuilderContext(BuilderContextBase["Function.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Function.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Function."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Function", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Function.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    alert: Optional[List[AlertModel]] = None
    """
    Describes an alert policy for the app.
    Alert policies for the app component
    """
    cors: Optional[List[Cor]] = None
    """
    The CORS policies of the app.
    """
    env: Optional[List[Env]] = None
    """
    Describes an app-wide environment variable made available to all components.
    """
    git: Optional[List[Git]] = None
    """
    A Git repo to use as the component's source. The repository must be able to be cloned without authentication. Only one of git, github or gitlab may be set
    """
    github: Optional[List[Github]] = None
    """
    A GitHub repo to use as the component's source. DigitalOcean App Platform must have access to the repository. Only one of git, github, gitlab, or image may be set.
    """
    gitlab: Optional[List[Gitlab]] = None
    """
    A Gitlab repo to use as the component's source. DigitalOcean App Platform must have access to the repository. Only one of git, github, gitlab, or image may be set.
    """
    log_destination: Annotated[Optional[List[LogDestination]], Field(alias="logDestination")] = None
    """
    Describes a log forwarding destination.
    Logs
    """
    name: Optional[str] = None
    """
    The name of the app. Must be unique across all apps in the same account.
    The name of the component
    """
    routes: Optional[List[Route]] = None
    """
    (Deprecated - use ingress) An HTTP paths that should be routed to this component.
    """
    source_dir: Annotated[Optional[str], Field(alias="sourceDir")] = None
    """
    An optional path to the working directory to use for the build.
    An optional path to the working directory to use for the build.
    """


class Component(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Component"]:
            return Component

        def build(self) -> "Component":
            return Component(**self._attrs)

        def name(self, value: Optional[str], /) -> Self:
            """
            The name of the app. Must be unique across all apps in the same account.
            """
            return self._set("name", value)

        def preserve_path_prefix(self, value: Optional[bool], /) -> Self:
            """
            An optional boolean flag to preserve the path that is forwarded to the backend service. By default, the HTTP request path will be trimmed from the left when forwarded to the component.
            """
            return self._set("preserve_path_prefix", value)

        def rewrite(self, value: Optional[str], /) -> Self:
            """
            An optional field that will rewrite the path of the component to be what is specified here. This is mutually exclusive with preserve_path_prefix.
            """
            return self._set("rewrite", value)

    class BuilderContext(BuilderContextBase["Component.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Component.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Component."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Component", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Component.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: Optional[str] = None
    """
    The name of the app. Must be unique across all apps in the same account.
    """
    preserve_path_prefix: Annotated[Optional[bool], Field(alias="preservePathPrefix")] = None
    """
    An optional boolean flag to preserve the path that is forwarded to the backend service. By default, the HTTP request path will be trimmed from the left when forwarded to the component.
    """
    rewrite: Optional[str] = None
    """
    An optional field that will rewrite the path of the component to be what is specified here. This is mutually exclusive with preserve_path_prefix.
    """


class Path(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Path"]:
            return Path

        def build(self) -> "Path":
            return Path(**self._attrs)

        def prefix(self, value: Optional[str], /) -> Self:
            """
            Prefix-based match.
            """
            return self._set("prefix", value)

    class BuilderContext(BuilderContextBase["Path.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Path.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Path."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Path", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Path.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    prefix: Optional[str] = None
    """
    Prefix-based match.
    """


class Match(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Match"]:
            return Match

        def build(self) -> "Match":
            return Match(**self._attrs)

        @overload
        def path(self, value_or_callback: List[Path], /) -> "Match.Builder": ...

        @overload
        def path(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Path, Path.Builder]],
                GenericListBuilder[Path, Path.Builder] | List[Path],
            ],
            /,
        ) -> "Match.Builder": ...

        @overload
        def path(self, value_or_callback: Never = ...) -> ListBuilderContext[Path.Builder]: ...

        def path(self, value_or_callback=None, /):
            """
            The path to match on.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Path.Builder]()
                context._parent_builder = self
                context._field_name = "path"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Path.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("path", value)

    class BuilderContext(BuilderContextBase["Match.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Match.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Match."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Match", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Match.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    path: Optional[List[Path]] = None
    """
    The path to match on.
    """


class Redirect(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Redirect"]:
            return Redirect

        def build(self) -> "Redirect":
            return Redirect(**self._attrs)

        def authority(self, value: Optional[str], /) -> Self:
            """
            The authority/host to redirect to. This can be a hostname or IP address.
            """
            return self._set("authority", value)

        def port(self, value: Optional[float], /) -> Self:
            """
            The port to redirect to.
            """
            return self._set("port", value)

        def redirect_code(self, value: Optional[float], /) -> Self:
            """
            The redirect code to use. Supported values are 300, 301, 302, 303, 304, 307, 308.
            """
            return self._set("redirect_code", value)

        def scheme(self, value: Optional[str], /) -> Self:
            """
            The scheme to redirect to. Supported values are http or https
            """
            return self._set("scheme", value)

        def uri(self, value: Optional[str], /) -> Self:
            """
            An optional URI path to redirect to.
            """
            return self._set("uri", value)

    class BuilderContext(BuilderContextBase["Redirect.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Redirect.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Redirect."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Redirect", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Redirect.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    authority: Optional[str] = None
    """
    The authority/host to redirect to. This can be a hostname or IP address.
    """
    port: Optional[float] = None
    """
    The port to redirect to.
    """
    redirect_code: Annotated[Optional[float], Field(alias="redirectCode")] = None
    """
    The redirect code to use. Supported values are 300, 301, 302, 303, 304, 307, 308.
    """
    scheme: Optional[str] = None
    """
    The scheme to redirect to. Supported values are http or https
    """
    uri: Optional[str] = None
    """
    An optional URI path to redirect to.
    """


class Rule(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Rule"]:
            return Rule

        def build(self) -> "Rule":
            return Rule(**self._attrs)

        @overload
        def component(self, value_or_callback: List[Component], /) -> "Rule.Builder": ...

        @overload
        def component(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Component, Component.Builder]],
                GenericListBuilder[Component, Component.Builder] | List[Component],
            ],
            /,
        ) -> "Rule.Builder": ...

        @overload
        def component(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Component.Builder]: ...

        def component(self, value_or_callback=None, /):
            """
            The component to route to. Only one of component or redirect may be set.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Component.Builder]()
                context._parent_builder = self
                context._field_name = "component"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Component.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("component", value)

        @overload
        def cors(self, value_or_callback: List[Cor], /) -> "Rule.Builder": ...

        @overload
        def cors(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Cor, Cor.Builder]],
                GenericListBuilder[Cor, Cor.Builder] | List[Cor],
            ],
            /,
        ) -> "Rule.Builder": ...

        @overload
        def cors(self, value_or_callback: Never = ...) -> ListBuilderContext[Cor.Builder]: ...

        def cors(self, value_or_callback=None, /):
            """
            The CORS policies of the app.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Cor.Builder]()
                context._parent_builder = self
                context._field_name = "cors"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Cor.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("cors", value)

        @overload
        def match(self, value_or_callback: List[Match], /) -> "Rule.Builder": ...

        @overload
        def match(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Match, Match.Builder]],
                GenericListBuilder[Match, Match.Builder] | List[Match],
            ],
            /,
        ) -> "Rule.Builder": ...

        @overload
        def match(self, value_or_callback: Never = ...) -> ListBuilderContext[Match.Builder]: ...

        def match(self, value_or_callback=None, /):
            """
            The match configuration for the rule
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Match.Builder]()
                context._parent_builder = self
                context._field_name = "match"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Match.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("match", value)

        @overload
        def redirect(self, value_or_callback: List[Redirect], /) -> "Rule.Builder": ...

        @overload
        def redirect(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Redirect, Redirect.Builder]],
                GenericListBuilder[Redirect, Redirect.Builder] | List[Redirect],
            ],
            /,
        ) -> "Rule.Builder": ...

        @overload
        def redirect(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Redirect.Builder]: ...

        def redirect(self, value_or_callback=None, /):
            """
            The redirect configuration for the rule. Only one of component or redirect may be set.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Redirect.Builder]()
                context._parent_builder = self
                context._field_name = "redirect"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Redirect.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("redirect", value)

    class BuilderContext(BuilderContextBase["Rule.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Rule.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Rule."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Rule", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Rule.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    component: Optional[List[Component]] = None
    """
    The component to route to. Only one of component or redirect may be set.
    """
    cors: Optional[List[Cor]] = None
    """
    The CORS policies of the app.
    """
    match: Optional[List[Match]] = None
    """
    The match configuration for the rule
    """
    redirect: Optional[List[Redirect]] = None
    """
    The redirect configuration for the rule. Only one of component or redirect may be set.
    """


class Ingres(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Ingres"]:
            return Ingres

        def build(self) -> "Ingres":
            return Ingres(**self._attrs)

        @overload
        def rule(self, value_or_callback: List[Rule], /) -> "Ingres.Builder": ...

        @overload
        def rule(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Rule, Rule.Builder]],
                GenericListBuilder[Rule, Rule.Builder] | List[Rule],
            ],
            /,
        ) -> "Ingres.Builder": ...

        @overload
        def rule(self, value_or_callback: Never = ...) -> ListBuilderContext[Rule.Builder]: ...

        def rule(self, value_or_callback=None, /):
            """
            The type of the alert to configure. Top-level app alert policies can be: DEPLOYMENT_CANCELLED, DEPLOYMENT_FAILED, DEPLOYMENT_LIVE, DEPLOYMENT_STARTED, DOMAIN_FAILED, or DOMAIN_LIVE.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Rule.Builder]()
                context._parent_builder = self
                context._field_name = "rule"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Rule.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("rule", value)

    class BuilderContext(BuilderContextBase["Ingres.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Ingres.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Ingres."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Ingres", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Ingres.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    rule: Optional[List[Rule]] = None
    """
    The type of the alert to configure. Top-level app alert policies can be: DEPLOYMENT_CANCELLED, DEPLOYMENT_FAILED, DEPLOYMENT_LIVE, DEPLOYMENT_STARTED, DOMAIN_FAILED, or DOMAIN_LIVE.
    """


class DeployOnPush(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["DeployOnPush"]:
            return DeployOnPush

        def build(self) -> "DeployOnPush":
            return DeployOnPush(**self._attrs)

        def enabled(self, value: Optional[bool], /) -> Self:
            """
            Whether to automatically deploy images pushed to DOCR.
            Whether to automatically deploy images pushed to DOCR.
            """
            return self._set("enabled", value)

    class BuilderContext(BuilderContextBase["DeployOnPush.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DeployOnPush.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DeployOnPush."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["DeployOnPush", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use DeployOnPush.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    enabled: Optional[bool] = None
    """
    Whether to automatically deploy images pushed to DOCR.
    Whether to automatically deploy images pushed to DOCR.
    """


class RegistryCredentialsSecretRef(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["RegistryCredentialsSecretRef"]:
            return RegistryCredentialsSecretRef

        def build(self) -> "RegistryCredentialsSecretRef":
            return RegistryCredentialsSecretRef(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            The key to select.
            """
            return self._set("key", value)

        def name(self, value: str, /) -> Self:
            """
            Name of the secret.
            """
            return self._set("name", value)

        def namespace(self, value: str, /) -> Self:
            """
            Namespace of the secret.
            """
            return self._set("namespace", value)

    class BuilderContext(BuilderContextBase["RegistryCredentialsSecretRef.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = RegistryCredentialsSecretRef.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RegistryCredentialsSecretRef."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["RegistryCredentialsSecretRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use RegistryCredentialsSecretRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: str
    """
    The key to select.
    """
    name: str
    """
    Name of the secret.
    """
    namespace: str
    """
    Namespace of the secret.
    """


class Image(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Image"]:
            return Image

        def build(self) -> "Image":
            return Image(**self._attrs)

        @overload
        def deploy_on_push(self, value_or_callback: List[DeployOnPush], /) -> "Image.Builder": ...

        @overload
        def deploy_on_push(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[DeployOnPush, DeployOnPush.Builder]],
                GenericListBuilder[DeployOnPush, DeployOnPush.Builder] | List[DeployOnPush],
            ],
            /,
        ) -> "Image.Builder": ...

        @overload
        def deploy_on_push(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[DeployOnPush.Builder]: ...

        def deploy_on_push(self, value_or_callback=None, /):
            """
            Whether to automatically deploy new commits made to the repo.
            Configures automatically deploying images pushed to DOCR.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[DeployOnPush.Builder]()
                context._parent_builder = self
                context._field_name = "deploy_on_push"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(DeployOnPush.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("deploy_on_push", value)

        def registry(self, value: Optional[str], /) -> Self:
            """
            The registry name. Must be left empty for the DOCR registry type. Required for the DOCKER_HUB registry type.
            The registry name. Must be left empty for the DOCR registry type.
            """
            return self._set("registry", value)

        @overload
        def registry_credentials_secret_ref(
            self, value_or_callback: Optional[RegistryCredentialsSecretRef], /
        ) -> "Image.Builder": ...

        @overload
        def registry_credentials_secret_ref(
            self,
            value_or_callback: Callable[
                [RegistryCredentialsSecretRef.Builder],
                RegistryCredentialsSecretRef.Builder | RegistryCredentialsSecretRef,
            ],
            /,
        ) -> "Image.Builder": ...

        @overload
        def registry_credentials_secret_ref(
            self, value_or_callback: Never = ...
        ) -> "RegistryCredentialsSecretRef.BuilderContext": ...

        def registry_credentials_secret_ref(self, value_or_callback=None, /):
            """
            The credentials required to access a private Docker Hub or GitHub registry, in the following syntax <username>:<token>.
            Access credentials for third-party registries
            """
            if self._in_context and value_or_callback is None:
                context = RegistryCredentialsSecretRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "registry_credentials_secret_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(RegistryCredentialsSecretRef.builder())
                if isinstance(output, RegistryCredentialsSecretRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("registry_credentials_secret_ref", value)

        def registry_type(self, value: Optional[str], /) -> Self:
            """
            The registry type. One of DOCR (DigitalOcean container registry) or DOCKER_HUB.
            The registry type.
            """
            return self._set("registry_type", value)

        def repository(self, value: Optional[str], /) -> Self:
            """
            The repository name.
            The repository name.
            """
            return self._set("repository", value)

        def tag(self, value: Optional[str], /) -> Self:
            """
            The repository tag. Defaults to latest if not provided.
            The repository tag. Defaults to latest if not provided.
            """
            return self._set("tag", value)

    class BuilderContext(BuilderContextBase["Image.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Image.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Image."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Image", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Image.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    deploy_on_push: Annotated[Optional[List[DeployOnPush]], Field(alias="deployOnPush")] = None
    """
    Whether to automatically deploy new commits made to the repo.
    Configures automatically deploying images pushed to DOCR.
    """
    registry: Optional[str] = None
    """
    The registry name. Must be left empty for the DOCR registry type. Required for the DOCKER_HUB registry type.
    The registry name. Must be left empty for the DOCR registry type.
    """
    registry_credentials_secret_ref: Annotated[
        Optional[RegistryCredentialsSecretRef],
        Field(alias="registryCredentialsSecretRef"),
    ] = None
    """
    The credentials required to access a private Docker Hub or GitHub registry, in the following syntax <username>:<token>.
    Access credentials for third-party registries
    """
    registry_type: Annotated[Optional[str], Field(alias="registryType")] = None
    """
    The registry type. One of DOCR (DigitalOcean container registry) or DOCKER_HUB.
    The registry type.
    """
    repository: Optional[str] = None
    """
    The repository name.
    The repository name.
    """
    tag: Optional[str] = None
    """
    The repository tag. Defaults to latest if not provided.
    The repository tag. Defaults to latest if not provided.
    """


class Job(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Job"]:
            return Job

        def build(self) -> "Job":
            return Job(**self._attrs)

        @overload
        def alert(self, value_or_callback: List[AlertModel], /) -> "Job.Builder": ...

        @overload
        def alert(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[AlertModel, AlertModel.Builder]],
                GenericListBuilder[AlertModel, AlertModel.Builder] | List[AlertModel],
            ],
            /,
        ) -> "Job.Builder": ...

        @overload
        def alert(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[AlertModel.Builder]: ...

        def alert(self, value_or_callback=None, /):
            """
            Describes an alert policy for the app.
            Alert policies for the app component
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[AlertModel.Builder]()
                context._parent_builder = self
                context._field_name = "alert"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AlertModel.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("alert", value)

        def build_command(self, value: Optional[str], /) -> Self:
            """
            An optional build command to run while building this component from source.
            An optional build command to run while building this component from source.
            """
            return self._set("build_command", value)

        def dockerfile_path(self, value: Optional[str], /) -> Self:
            """
            The path to a Dockerfile relative to the root of the repo. If set, overrides usage of buildpacks.
            The path to a Dockerfile relative to the root of the repo. If set, overrides usage of buildpacks.
            """
            return self._set("dockerfile_path", value)

        @overload
        def env(self, value_or_callback: List[Env], /) -> "Job.Builder": ...

        @overload
        def env(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Env, Env.Builder]],
                GenericListBuilder[Env, Env.Builder] | List[Env],
            ],
            /,
        ) -> "Job.Builder": ...

        @overload
        def env(self, value_or_callback: Never = ...) -> ListBuilderContext[Env.Builder]: ...

        def env(self, value_or_callback=None, /):
            """
            Describes an app-wide environment variable made available to all components.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Env.Builder]()
                context._parent_builder = self
                context._field_name = "env"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Env.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("env", value)

        def environment_slug(self, value: Optional[str], /) -> Self:
            """
            An environment slug describing the type of this app.
            An environment slug describing the type of this app.
            """
            return self._set("environment_slug", value)

        @overload
        def git(self, value_or_callback: List[Git], /) -> "Job.Builder": ...

        @overload
        def git(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Git, Git.Builder]],
                GenericListBuilder[Git, Git.Builder] | List[Git],
            ],
            /,
        ) -> "Job.Builder": ...

        @overload
        def git(self, value_or_callback: Never = ...) -> ListBuilderContext[Git.Builder]: ...

        def git(self, value_or_callback=None, /):
            """
            A Git repo to use as the component's source. The repository must be able to be cloned without authentication. Only one of git, github or gitlab may be set
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Git.Builder]()
                context._parent_builder = self
                context._field_name = "git"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Git.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("git", value)

        @overload
        def github(self, value_or_callback: List[Github], /) -> "Job.Builder": ...

        @overload
        def github(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Github, Github.Builder]],
                GenericListBuilder[Github, Github.Builder] | List[Github],
            ],
            /,
        ) -> "Job.Builder": ...

        @overload
        def github(self, value_or_callback: Never = ...) -> ListBuilderContext[Github.Builder]: ...

        def github(self, value_or_callback=None, /):
            """
            A GitHub repo to use as the component's source. DigitalOcean App Platform must have access to the repository. Only one of git, github, gitlab, or image may be set.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Github.Builder]()
                context._parent_builder = self
                context._field_name = "github"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Github.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("github", value)

        @overload
        def gitlab(self, value_or_callback: List[Gitlab], /) -> "Job.Builder": ...

        @overload
        def gitlab(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Gitlab, Gitlab.Builder]],
                GenericListBuilder[Gitlab, Gitlab.Builder] | List[Gitlab],
            ],
            /,
        ) -> "Job.Builder": ...

        @overload
        def gitlab(self, value_or_callback: Never = ...) -> ListBuilderContext[Gitlab.Builder]: ...

        def gitlab(self, value_or_callback=None, /):
            """
            A Gitlab repo to use as the component's source. DigitalOcean App Platform must have access to the repository. Only one of git, github, gitlab, or image may be set.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Gitlab.Builder]()
                context._parent_builder = self
                context._field_name = "gitlab"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Gitlab.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("gitlab", value)

        @overload
        def image(self, value_or_callback: List[Image], /) -> "Job.Builder": ...

        @overload
        def image(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Image, Image.Builder]],
                GenericListBuilder[Image, Image.Builder] | List[Image],
            ],
            /,
        ) -> "Job.Builder": ...

        @overload
        def image(self, value_or_callback: Never = ...) -> ListBuilderContext[Image.Builder]: ...

        def image(self, value_or_callback=None, /):
            """
            An image to use as the component's source. Only one of git, github, gitlab, or image may be set.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Image.Builder]()
                context._parent_builder = self
                context._field_name = "image"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Image.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("image", value)

        def instance_count(self, value: Optional[float], /) -> Self:
            """
            The amount of instances that this component should be scaled to.
            The amount of instances that this component should be scaled to.
            """
            return self._set("instance_count", value)

        def instance_size_slug(self, value: Optional[str], /) -> Self:
            """
            The instance size to use for this component. This determines the plan (basic or professional) and the available CPU and memory. The list of available instance sizes can be found with the API or using the doctl CLI (doctl apps tier instance-size list). Default: basic-xxs
            The instance size to use for this component.
            """
            return self._set("instance_size_slug", value)

        def kind(self, value: Optional[str], /) -> Self:
            """
            The type of job and when it will be run during the deployment process. It may be one of:
            The type of job and when it will be run during the deployment process.
            """
            return self._set("kind", value)

        @overload
        def log_destination(self, value_or_callback: List[LogDestination], /) -> "Job.Builder": ...

        @overload
        def log_destination(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[LogDestination, LogDestination.Builder]],
                GenericListBuilder[LogDestination, LogDestination.Builder] | List[LogDestination],
            ],
            /,
        ) -> "Job.Builder": ...

        @overload
        def log_destination(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[LogDestination.Builder]: ...

        def log_destination(self, value_or_callback=None, /):
            """
            Describes a log forwarding destination.
            Logs
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[LogDestination.Builder]()
                context._parent_builder = self
                context._field_name = "log_destination"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(LogDestination.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("log_destination", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            The name of the app. Must be unique across all apps in the same account.
            The name of the component
            """
            return self._set("name", value)

        def run_command(self, value: Optional[str], /) -> Self:
            """
            An optional run command to override the component's default.
            An optional run command to override the component's default.
            """
            return self._set("run_command", value)

        def source_dir(self, value: Optional[str], /) -> Self:
            """
            An optional path to the working directory to use for the build.
            An optional path to the working directory to use for the build.
            """
            return self._set("source_dir", value)

    class BuilderContext(BuilderContextBase["Job.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Job.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Job."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Job", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Job.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    alert: Optional[List[AlertModel]] = None
    """
    Describes an alert policy for the app.
    Alert policies for the app component
    """
    build_command: Annotated[Optional[str], Field(alias="buildCommand")] = None
    """
    An optional build command to run while building this component from source.
    An optional build command to run while building this component from source.
    """
    dockerfile_path: Annotated[Optional[str], Field(alias="dockerfilePath")] = None
    """
    The path to a Dockerfile relative to the root of the repo. If set, overrides usage of buildpacks.
    The path to a Dockerfile relative to the root of the repo. If set, overrides usage of buildpacks.
    """
    env: Optional[List[Env]] = None
    """
    Describes an app-wide environment variable made available to all components.
    """
    environment_slug: Annotated[Optional[str], Field(alias="environmentSlug")] = None
    """
    An environment slug describing the type of this app.
    An environment slug describing the type of this app.
    """
    git: Optional[List[Git]] = None
    """
    A Git repo to use as the component's source. The repository must be able to be cloned without authentication. Only one of git, github or gitlab may be set
    """
    github: Optional[List[Github]] = None
    """
    A GitHub repo to use as the component's source. DigitalOcean App Platform must have access to the repository. Only one of git, github, gitlab, or image may be set.
    """
    gitlab: Optional[List[Gitlab]] = None
    """
    A Gitlab repo to use as the component's source. DigitalOcean App Platform must have access to the repository. Only one of git, github, gitlab, or image may be set.
    """
    image: Optional[List[Image]] = None
    """
    An image to use as the component's source. Only one of git, github, gitlab, or image may be set.
    """
    instance_count: Annotated[Optional[float], Field(alias="instanceCount")] = None
    """
    The amount of instances that this component should be scaled to.
    The amount of instances that this component should be scaled to.
    """
    instance_size_slug: Annotated[Optional[str], Field(alias="instanceSizeSlug")] = None
    """
    The instance size to use for this component. This determines the plan (basic or professional) and the available CPU and memory. The list of available instance sizes can be found with the API or using the doctl CLI (doctl apps tier instance-size list). Default: basic-xxs
    The instance size to use for this component.
    """
    kind: Optional[str] = None
    """
    The type of job and when it will be run during the deployment process. It may be one of:
    The type of job and when it will be run during the deployment process.
    """
    log_destination: Annotated[Optional[List[LogDestination]], Field(alias="logDestination")] = None
    """
    Describes a log forwarding destination.
    Logs
    """
    name: Optional[str] = None
    """
    The name of the app. Must be unique across all apps in the same account.
    The name of the component
    """
    run_command: Annotated[Optional[str], Field(alias="runCommand")] = None
    """
    An optional run command to override the component's default.
    An optional run command to override the component's default.
    """
    source_dir: Annotated[Optional[str], Field(alias="sourceDir")] = None
    """
    An optional path to the working directory to use for the build.
    An optional path to the working directory to use for the build.
    """


class Cpu(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Cpu"]:
            return Cpu

        def build(self) -> "Cpu":
            return Cpu(**self._attrs)

        def percent(self, value: Optional[float], /) -> Self:
            """
            The average target CPU utilization for the component.
            The average target CPU utilization for the component.
            """
            return self._set("percent", value)

    class BuilderContext(BuilderContextBase["Cpu.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Cpu.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Cpu."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Cpu", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Cpu.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    percent: Optional[float] = None
    """
    The average target CPU utilization for the component.
    The average target CPU utilization for the component.
    """


class Metric(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Metric"]:
            return Metric

        def build(self) -> "Metric":
            return Metric(**self._attrs)

        @overload
        def cpu(self, value_or_callback: List[Cpu], /) -> "Metric.Builder": ...

        @overload
        def cpu(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Cpu, Cpu.Builder]],
                GenericListBuilder[Cpu, Cpu.Builder] | List[Cpu],
            ],
            /,
        ) -> "Metric.Builder": ...

        @overload
        def cpu(self, value_or_callback: Never = ...) -> ListBuilderContext[Cpu.Builder]: ...

        def cpu(self, value_or_callback=None, /):
            """
            Settings for scaling the component based on CPU utilization.
            Settings for scaling the component based on CPU utilization.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Cpu.Builder]()
                context._parent_builder = self
                context._field_name = "cpu"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Cpu.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("cpu", value)

    class BuilderContext(BuilderContextBase["Metric.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Metric.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Metric."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Metric", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Metric.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    cpu: Optional[List[Cpu]] = None
    """
    Settings for scaling the component based on CPU utilization.
    Settings for scaling the component based on CPU utilization.
    """


class Autoscaling(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Autoscaling"]:
            return Autoscaling

        def build(self) -> "Autoscaling":
            return Autoscaling(**self._attrs)

        def max_instance_count(self, value: Optional[float], /) -> Self:
            """
            The maximum amount of instances for this component. Must be more than min_instance_count.
            The maximum amount of instances for this component. Must be more than min_instance_count.
            """
            return self._set("max_instance_count", value)

        @overload
        def metrics(self, value_or_callback: List[Metric], /) -> "Autoscaling.Builder": ...

        @overload
        def metrics(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Metric, Metric.Builder]],
                GenericListBuilder[Metric, Metric.Builder] | List[Metric],
            ],
            /,
        ) -> "Autoscaling.Builder": ...

        @overload
        def metrics(self, value_or_callback: Never = ...) -> ListBuilderContext[Metric.Builder]: ...

        def metrics(self, value_or_callback=None, /):
            """
            The metrics that the component is scaled on.
            The metrics that the component is scaled on.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Metric.Builder]()
                context._parent_builder = self
                context._field_name = "metrics"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Metric.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("metrics", value)

        def min_instance_count(self, value: Optional[float], /) -> Self:
            """
            The minimum amount of instances for this component. Must be less than max_instance_count.
            The minimum amount of instances for this component. Must be less than max_instance_count.
            """
            return self._set("min_instance_count", value)

    class BuilderContext(BuilderContextBase["Autoscaling.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Autoscaling.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Autoscaling."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Autoscaling", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Autoscaling.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    max_instance_count: Annotated[Optional[float], Field(alias="maxInstanceCount")] = None
    """
    The maximum amount of instances for this component. Must be more than min_instance_count.
    The maximum amount of instances for this component. Must be more than min_instance_count.
    """
    metrics: Optional[List[Metric]] = None
    """
    The metrics that the component is scaled on.
    The metrics that the component is scaled on.
    """
    min_instance_count: Annotated[Optional[float], Field(alias="minInstanceCount")] = None
    """
    The minimum amount of instances for this component. Must be less than max_instance_count.
    The minimum amount of instances for this component. Must be less than max_instance_count.
    """


class HealthCheck(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["HealthCheck"]:
            return HealthCheck

        def build(self) -> "HealthCheck":
            return HealthCheck(**self._attrs)

        def failure_threshold(self, value: Optional[float], /) -> Self:
            """
            The number of failed health checks before considered unhealthy.
            The number of failed health checks before considered unhealthy.
            """
            return self._set("failure_threshold", value)

        def http_path(self, value: Optional[str], /) -> Self:
            """
            The route path used for the HTTP health check ping.
            The route path used for the HTTP health check ping.
            """
            return self._set("http_path", value)

        def initial_delay_seconds(self, value: Optional[float], /) -> Self:
            """
            The number of seconds to wait before beginning health checks.
            The number of seconds to wait before beginning health checks.
            """
            return self._set("initial_delay_seconds", value)

        def period_seconds(self, value: Optional[float], /) -> Self:
            """
            The number of seconds to wait between health checks.
            The number of seconds to wait between health checks.
            """
            return self._set("period_seconds", value)

        def port(self, value: Optional[float], /) -> Self:
            """
            The port to redirect to.
            The port on which the health check will be performed. If not set, the health check will be performed on the component's http_port.
            """
            return self._set("port", value)

        def success_threshold(self, value: Optional[float], /) -> Self:
            """
            The number of successful health checks before considered healthy.
            The number of successful health checks before considered healthy.
            """
            return self._set("success_threshold", value)

        def timeout_seconds(self, value: Optional[float], /) -> Self:
            """
            The number of seconds after which the check times out.
            The number of seconds after which the check times out.
            """
            return self._set("timeout_seconds", value)

    class BuilderContext(BuilderContextBase["HealthCheck.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = HealthCheck.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for HealthCheck."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["HealthCheck", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use HealthCheck.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    failure_threshold: Annotated[Optional[float], Field(alias="failureThreshold")] = None
    """
    The number of failed health checks before considered unhealthy.
    The number of failed health checks before considered unhealthy.
    """
    http_path: Annotated[Optional[str], Field(alias="httpPath")] = None
    """
    The route path used for the HTTP health check ping.
    The route path used for the HTTP health check ping.
    """
    initial_delay_seconds: Annotated[Optional[float], Field(alias="initialDelaySeconds")] = None
    """
    The number of seconds to wait before beginning health checks.
    The number of seconds to wait before beginning health checks.
    """
    period_seconds: Annotated[Optional[float], Field(alias="periodSeconds")] = None
    """
    The number of seconds to wait between health checks.
    The number of seconds to wait between health checks.
    """
    port: Optional[float] = None
    """
    The port to redirect to.
    The port on which the health check will be performed. If not set, the health check will be performed on the component's http_port.
    """
    success_threshold: Annotated[Optional[float], Field(alias="successThreshold")] = None
    """
    The number of successful health checks before considered healthy.
    The number of successful health checks before considered healthy.
    """
    timeout_seconds: Annotated[Optional[float], Field(alias="timeoutSeconds")] = None
    """
    The number of seconds after which the check times out.
    The number of seconds after which the check times out.
    """


class Service(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Service"]:
            return Service

        def build(self) -> "Service":
            return Service(**self._attrs)

        @overload
        def alert(self, value_or_callback: List[AlertModel], /) -> "Service.Builder": ...

        @overload
        def alert(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[AlertModel, AlertModel.Builder]],
                GenericListBuilder[AlertModel, AlertModel.Builder] | List[AlertModel],
            ],
            /,
        ) -> "Service.Builder": ...

        @overload
        def alert(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[AlertModel.Builder]: ...

        def alert(self, value_or_callback=None, /):
            """
            Describes an alert policy for the app.
            Alert policies for the app component
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[AlertModel.Builder]()
                context._parent_builder = self
                context._field_name = "alert"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AlertModel.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("alert", value)

        @overload
        def autoscaling(self, value_or_callback: List[Autoscaling], /) -> "Service.Builder": ...

        @overload
        def autoscaling(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Autoscaling, Autoscaling.Builder]],
                GenericListBuilder[Autoscaling, Autoscaling.Builder] | List[Autoscaling],
            ],
            /,
        ) -> "Service.Builder": ...

        @overload
        def autoscaling(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Autoscaling.Builder]: ...

        def autoscaling(self, value_or_callback=None, /):
            """
            Configuration for automatically scaling this component based on metrics.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Autoscaling.Builder]()
                context._parent_builder = self
                context._field_name = "autoscaling"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Autoscaling.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("autoscaling", value)

        def build_command(self, value: Optional[str], /) -> Self:
            """
            An optional build command to run while building this component from source.
            An optional build command to run while building this component from source.
            """
            return self._set("build_command", value)

        @overload
        def cors(self, value_or_callback: List[Cor], /) -> "Service.Builder": ...

        @overload
        def cors(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Cor, Cor.Builder]],
                GenericListBuilder[Cor, Cor.Builder] | List[Cor],
            ],
            /,
        ) -> "Service.Builder": ...

        @overload
        def cors(self, value_or_callback: Never = ...) -> ListBuilderContext[Cor.Builder]: ...

        def cors(self, value_or_callback=None, /):
            """
            The CORS policies of the app.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Cor.Builder]()
                context._parent_builder = self
                context._field_name = "cors"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Cor.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("cors", value)

        def dockerfile_path(self, value: Optional[str], /) -> Self:
            """
            The path to a Dockerfile relative to the root of the repo. If set, overrides usage of buildpacks.
            The path to a Dockerfile relative to the root of the repo. If set, overrides usage of buildpacks.
            """
            return self._set("dockerfile_path", value)

        @overload
        def env(self, value_or_callback: List[Env], /) -> "Service.Builder": ...

        @overload
        def env(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Env, Env.Builder]],
                GenericListBuilder[Env, Env.Builder] | List[Env],
            ],
            /,
        ) -> "Service.Builder": ...

        @overload
        def env(self, value_or_callback: Never = ...) -> ListBuilderContext[Env.Builder]: ...

        def env(self, value_or_callback=None, /):
            """
            Describes an app-wide environment variable made available to all components.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Env.Builder]()
                context._parent_builder = self
                context._field_name = "env"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Env.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("env", value)

        def environment_slug(self, value: Optional[str], /) -> Self:
            """
            An environment slug describing the type of this app.
            An environment slug describing the type of this app.
            """
            return self._set("environment_slug", value)

        @overload
        def git(self, value_or_callback: List[Git], /) -> "Service.Builder": ...

        @overload
        def git(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Git, Git.Builder]],
                GenericListBuilder[Git, Git.Builder] | List[Git],
            ],
            /,
        ) -> "Service.Builder": ...

        @overload
        def git(self, value_or_callback: Never = ...) -> ListBuilderContext[Git.Builder]: ...

        def git(self, value_or_callback=None, /):
            """
            A Git repo to use as the component's source. The repository must be able to be cloned without authentication. Only one of git, github or gitlab may be set
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Git.Builder]()
                context._parent_builder = self
                context._field_name = "git"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Git.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("git", value)

        @overload
        def github(self, value_or_callback: List[Github], /) -> "Service.Builder": ...

        @overload
        def github(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Github, Github.Builder]],
                GenericListBuilder[Github, Github.Builder] | List[Github],
            ],
            /,
        ) -> "Service.Builder": ...

        @overload
        def github(self, value_or_callback: Never = ...) -> ListBuilderContext[Github.Builder]: ...

        def github(self, value_or_callback=None, /):
            """
            A GitHub repo to use as the component's source. DigitalOcean App Platform must have access to the repository. Only one of git, github, gitlab, or image may be set.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Github.Builder]()
                context._parent_builder = self
                context._field_name = "github"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Github.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("github", value)

        @overload
        def gitlab(self, value_or_callback: List[Gitlab], /) -> "Service.Builder": ...

        @overload
        def gitlab(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Gitlab, Gitlab.Builder]],
                GenericListBuilder[Gitlab, Gitlab.Builder] | List[Gitlab],
            ],
            /,
        ) -> "Service.Builder": ...

        @overload
        def gitlab(self, value_or_callback: Never = ...) -> ListBuilderContext[Gitlab.Builder]: ...

        def gitlab(self, value_or_callback=None, /):
            """
            A Gitlab repo to use as the component's source. DigitalOcean App Platform must have access to the repository. Only one of git, github, gitlab, or image may be set.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Gitlab.Builder]()
                context._parent_builder = self
                context._field_name = "gitlab"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Gitlab.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("gitlab", value)

        @overload
        def health_check(self, value_or_callback: List[HealthCheck], /) -> "Service.Builder": ...

        @overload
        def health_check(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[HealthCheck, HealthCheck.Builder]],
                GenericListBuilder[HealthCheck, HealthCheck.Builder] | List[HealthCheck],
            ],
            /,
        ) -> "Service.Builder": ...

        @overload
        def health_check(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[HealthCheck.Builder]: ...

        def health_check(self, value_or_callback=None, /):
            """
            A health check to determine the availability of this component.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[HealthCheck.Builder]()
                context._parent_builder = self
                context._field_name = "health_check"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(HealthCheck.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("health_check", value)

        def http_port(self, value: Optional[float], /) -> Self:
            """
            The internal port on which this service's run command will listen.
            The internal port on which this service's run command will listen.
            """
            return self._set("http_port", value)

        @overload
        def image(self, value_or_callback: List[Image], /) -> "Service.Builder": ...

        @overload
        def image(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Image, Image.Builder]],
                GenericListBuilder[Image, Image.Builder] | List[Image],
            ],
            /,
        ) -> "Service.Builder": ...

        @overload
        def image(self, value_or_callback: Never = ...) -> ListBuilderContext[Image.Builder]: ...

        def image(self, value_or_callback=None, /):
            """
            An image to use as the component's source. Only one of git, github, gitlab, or image may be set.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Image.Builder]()
                context._parent_builder = self
                context._field_name = "image"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Image.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("image", value)

        def instance_count(self, value: Optional[float], /) -> Self:
            """
            The amount of instances that this component should be scaled to.
            The amount of instances that this component should be scaled to.
            """
            return self._set("instance_count", value)

        def instance_size_slug(self, value: Optional[str], /) -> Self:
            """
            The instance size to use for this component. This determines the plan (basic or professional) and the available CPU and memory. The list of available instance sizes can be found with the API or using the doctl CLI (doctl apps tier instance-size list). Default: basic-xxs
            The instance size to use for this component.
            """
            return self._set("instance_size_slug", value)

        def internal_ports(self, value: Optional[List[float]], /) -> Self:
            """
            A list of ports on which this service will listen for internal traffic.
            """
            return self._set("internal_ports", value)

        @overload
        def log_destination(
            self, value_or_callback: List[LogDestination], /
        ) -> "Service.Builder": ...

        @overload
        def log_destination(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[LogDestination, LogDestination.Builder]],
                GenericListBuilder[LogDestination, LogDestination.Builder] | List[LogDestination],
            ],
            /,
        ) -> "Service.Builder": ...

        @overload
        def log_destination(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[LogDestination.Builder]: ...

        def log_destination(self, value_or_callback=None, /):
            """
            Describes a log forwarding destination.
            Logs
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[LogDestination.Builder]()
                context._parent_builder = self
                context._field_name = "log_destination"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(LogDestination.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("log_destination", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            The name of the app. Must be unique across all apps in the same account.
            The name of the component
            """
            return self._set("name", value)

        @overload
        def routes(self, value_or_callback: List[Route], /) -> "Service.Builder": ...

        @overload
        def routes(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Route, Route.Builder]],
                GenericListBuilder[Route, Route.Builder] | List[Route],
            ],
            /,
        ) -> "Service.Builder": ...

        @overload
        def routes(self, value_or_callback: Never = ...) -> ListBuilderContext[Route.Builder]: ...

        def routes(self, value_or_callback=None, /):
            """
            (Deprecated - use ingress) An HTTP paths that should be routed to this component.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Route.Builder]()
                context._parent_builder = self
                context._field_name = "routes"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Route.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("routes", value)

        def run_command(self, value: Optional[str], /) -> Self:
            """
            An optional run command to override the component's default.
            An optional run command to override the component's default.
            """
            return self._set("run_command", value)

        def source_dir(self, value: Optional[str], /) -> Self:
            """
            An optional path to the working directory to use for the build.
            An optional path to the working directory to use for the build.
            """
            return self._set("source_dir", value)

    class BuilderContext(BuilderContextBase["Service.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Service.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Service."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Service", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Service.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    alert: Optional[List[AlertModel]] = None
    """
    Describes an alert policy for the app.
    Alert policies for the app component
    """
    autoscaling: Optional[List[Autoscaling]] = None
    """
    Configuration for automatically scaling this component based on metrics.
    """
    build_command: Annotated[Optional[str], Field(alias="buildCommand")] = None
    """
    An optional build command to run while building this component from source.
    An optional build command to run while building this component from source.
    """
    cors: Optional[List[Cor]] = None
    """
    The CORS policies of the app.
    """
    dockerfile_path: Annotated[Optional[str], Field(alias="dockerfilePath")] = None
    """
    The path to a Dockerfile relative to the root of the repo. If set, overrides usage of buildpacks.
    The path to a Dockerfile relative to the root of the repo. If set, overrides usage of buildpacks.
    """
    env: Optional[List[Env]] = None
    """
    Describes an app-wide environment variable made available to all components.
    """
    environment_slug: Annotated[Optional[str], Field(alias="environmentSlug")] = None
    """
    An environment slug describing the type of this app.
    An environment slug describing the type of this app.
    """
    git: Optional[List[Git]] = None
    """
    A Git repo to use as the component's source. The repository must be able to be cloned without authentication. Only one of git, github or gitlab may be set
    """
    github: Optional[List[Github]] = None
    """
    A GitHub repo to use as the component's source. DigitalOcean App Platform must have access to the repository. Only one of git, github, gitlab, or image may be set.
    """
    gitlab: Optional[List[Gitlab]] = None
    """
    A Gitlab repo to use as the component's source. DigitalOcean App Platform must have access to the repository. Only one of git, github, gitlab, or image may be set.
    """
    health_check: Annotated[Optional[List[HealthCheck]], Field(alias="healthCheck")] = None
    """
    A health check to determine the availability of this component.
    """
    http_port: Annotated[Optional[float], Field(alias="httpPort")] = None
    """
    The internal port on which this service's run command will listen.
    The internal port on which this service's run command will listen.
    """
    image: Optional[List[Image]] = None
    """
    An image to use as the component's source. Only one of git, github, gitlab, or image may be set.
    """
    instance_count: Annotated[Optional[float], Field(alias="instanceCount")] = None
    """
    The amount of instances that this component should be scaled to.
    The amount of instances that this component should be scaled to.
    """
    instance_size_slug: Annotated[Optional[str], Field(alias="instanceSizeSlug")] = None
    """
    The instance size to use for this component. This determines the plan (basic or professional) and the available CPU and memory. The list of available instance sizes can be found with the API or using the doctl CLI (doctl apps tier instance-size list). Default: basic-xxs
    The instance size to use for this component.
    """
    internal_ports: Annotated[Optional[List[float]], Field(alias="internalPorts")] = None
    """
    A list of ports on which this service will listen for internal traffic.
    """
    log_destination: Annotated[Optional[List[LogDestination]], Field(alias="logDestination")] = None
    """
    Describes a log forwarding destination.
    Logs
    """
    name: Optional[str] = None
    """
    The name of the app. Must be unique across all apps in the same account.
    The name of the component
    """
    routes: Optional[List[Route]] = None
    """
    (Deprecated - use ingress) An HTTP paths that should be routed to this component.
    """
    run_command: Annotated[Optional[str], Field(alias="runCommand")] = None
    """
    An optional run command to override the component's default.
    An optional run command to override the component's default.
    """
    source_dir: Annotated[Optional[str], Field(alias="sourceDir")] = None
    """
    An optional path to the working directory to use for the build.
    An optional path to the working directory to use for the build.
    """


class StaticSite(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["StaticSite"]:
            return StaticSite

        def build(self) -> "StaticSite":
            return StaticSite(**self._attrs)

        def build_command(self, value: Optional[str], /) -> Self:
            """
            An optional build command to run while building this component from source.
            An optional build command to run while building this component from source.
            """
            return self._set("build_command", value)

        def catchall_document(self, value: Optional[str], /) -> Self:
            """
            The name of the document to use as the fallback for any requests to documents that are not found when serving this static site.
            The name of the document to use as the fallback for any requests to documents that are not found when serving this static site.
            """
            return self._set("catchall_document", value)

        @overload
        def cors(self, value_or_callback: List[Cor], /) -> "StaticSite.Builder": ...

        @overload
        def cors(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Cor, Cor.Builder]],
                GenericListBuilder[Cor, Cor.Builder] | List[Cor],
            ],
            /,
        ) -> "StaticSite.Builder": ...

        @overload
        def cors(self, value_or_callback: Never = ...) -> ListBuilderContext[Cor.Builder]: ...

        def cors(self, value_or_callback=None, /):
            """
            The CORS policies of the app.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Cor.Builder]()
                context._parent_builder = self
                context._field_name = "cors"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Cor.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("cors", value)

        def dockerfile_path(self, value: Optional[str], /) -> Self:
            """
            The path to a Dockerfile relative to the root of the repo. If set, overrides usage of buildpacks.
            The path to a Dockerfile relative to the root of the repo. If set, overrides usage of buildpacks.
            """
            return self._set("dockerfile_path", value)

        @overload
        def env(self, value_or_callback: List[Env], /) -> "StaticSite.Builder": ...

        @overload
        def env(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Env, Env.Builder]],
                GenericListBuilder[Env, Env.Builder] | List[Env],
            ],
            /,
        ) -> "StaticSite.Builder": ...

        @overload
        def env(self, value_or_callback: Never = ...) -> ListBuilderContext[Env.Builder]: ...

        def env(self, value_or_callback=None, /):
            """
            Describes an app-wide environment variable made available to all components.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Env.Builder]()
                context._parent_builder = self
                context._field_name = "env"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Env.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("env", value)

        def environment_slug(self, value: Optional[str], /) -> Self:
            """
            An environment slug describing the type of this app.
            An environment slug describing the type of this app.
            """
            return self._set("environment_slug", value)

        def error_document(self, value: Optional[str], /) -> Self:
            """
            The name of the error document to use when serving this static site.
            The name of the error document to use when serving this static site.
            """
            return self._set("error_document", value)

        @overload
        def git(self, value_or_callback: List[Git], /) -> "StaticSite.Builder": ...

        @overload
        def git(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Git, Git.Builder]],
                GenericListBuilder[Git, Git.Builder] | List[Git],
            ],
            /,
        ) -> "StaticSite.Builder": ...

        @overload
        def git(self, value_or_callback: Never = ...) -> ListBuilderContext[Git.Builder]: ...

        def git(self, value_or_callback=None, /):
            """
            A Git repo to use as the component's source. The repository must be able to be cloned without authentication. Only one of git, github or gitlab may be set
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Git.Builder]()
                context._parent_builder = self
                context._field_name = "git"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Git.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("git", value)

        @overload
        def github(self, value_or_callback: List[Github], /) -> "StaticSite.Builder": ...

        @overload
        def github(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Github, Github.Builder]],
                GenericListBuilder[Github, Github.Builder] | List[Github],
            ],
            /,
        ) -> "StaticSite.Builder": ...

        @overload
        def github(self, value_or_callback: Never = ...) -> ListBuilderContext[Github.Builder]: ...

        def github(self, value_or_callback=None, /):
            """
            A GitHub repo to use as the component's source. DigitalOcean App Platform must have access to the repository. Only one of git, github, gitlab, or image may be set.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Github.Builder]()
                context._parent_builder = self
                context._field_name = "github"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Github.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("github", value)

        @overload
        def gitlab(self, value_or_callback: List[Gitlab], /) -> "StaticSite.Builder": ...

        @overload
        def gitlab(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Gitlab, Gitlab.Builder]],
                GenericListBuilder[Gitlab, Gitlab.Builder] | List[Gitlab],
            ],
            /,
        ) -> "StaticSite.Builder": ...

        @overload
        def gitlab(self, value_or_callback: Never = ...) -> ListBuilderContext[Gitlab.Builder]: ...

        def gitlab(self, value_or_callback=None, /):
            """
            A Gitlab repo to use as the component's source. DigitalOcean App Platform must have access to the repository. Only one of git, github, gitlab, or image may be set.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Gitlab.Builder]()
                context._parent_builder = self
                context._field_name = "gitlab"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Gitlab.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("gitlab", value)

        def index_document(self, value: Optional[str], /) -> Self:
            """
            The name of the index document to use when serving this static site.
            The name of the index document to use when serving this static site.
            """
            return self._set("index_document", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            The name of the app. Must be unique across all apps in the same account.
            The name of the component
            """
            return self._set("name", value)

        def output_dir(self, value: Optional[str], /) -> Self:
            """
            An optional path to where the built assets will be located, relative to the build context. If not set, App Platform will automatically scan for these directory names: _static, dist, public.
            An optional path to where the built assets will be located, relative to the build context. If not set, App Platform will automatically scan for these directory names: `_static`, `dist`, `public`.
            """
            return self._set("output_dir", value)

        @overload
        def routes(self, value_or_callback: List[Route], /) -> "StaticSite.Builder": ...

        @overload
        def routes(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Route, Route.Builder]],
                GenericListBuilder[Route, Route.Builder] | List[Route],
            ],
            /,
        ) -> "StaticSite.Builder": ...

        @overload
        def routes(self, value_or_callback: Never = ...) -> ListBuilderContext[Route.Builder]: ...

        def routes(self, value_or_callback=None, /):
            """
            (Deprecated - use ingress) An HTTP paths that should be routed to this component.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Route.Builder]()
                context._parent_builder = self
                context._field_name = "routes"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Route.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("routes", value)

        def source_dir(self, value: Optional[str], /) -> Self:
            """
            An optional path to the working directory to use for the build.
            An optional path to the working directory to use for the build.
            """
            return self._set("source_dir", value)

    class BuilderContext(BuilderContextBase["StaticSite.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = StaticSite.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for StaticSite."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["StaticSite", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use StaticSite.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    build_command: Annotated[Optional[str], Field(alias="buildCommand")] = None
    """
    An optional build command to run while building this component from source.
    An optional build command to run while building this component from source.
    """
    catchall_document: Annotated[Optional[str], Field(alias="catchallDocument")] = None
    """
    The name of the document to use as the fallback for any requests to documents that are not found when serving this static site.
    The name of the document to use as the fallback for any requests to documents that are not found when serving this static site.
    """
    cors: Optional[List[Cor]] = None
    """
    The CORS policies of the app.
    """
    dockerfile_path: Annotated[Optional[str], Field(alias="dockerfilePath")] = None
    """
    The path to a Dockerfile relative to the root of the repo. If set, overrides usage of buildpacks.
    The path to a Dockerfile relative to the root of the repo. If set, overrides usage of buildpacks.
    """
    env: Optional[List[Env]] = None
    """
    Describes an app-wide environment variable made available to all components.
    """
    environment_slug: Annotated[Optional[str], Field(alias="environmentSlug")] = None
    """
    An environment slug describing the type of this app.
    An environment slug describing the type of this app.
    """
    error_document: Annotated[Optional[str], Field(alias="errorDocument")] = None
    """
    The name of the error document to use when serving this static site.
    The name of the error document to use when serving this static site.
    """
    git: Optional[List[Git]] = None
    """
    A Git repo to use as the component's source. The repository must be able to be cloned without authentication. Only one of git, github or gitlab may be set
    """
    github: Optional[List[Github]] = None
    """
    A GitHub repo to use as the component's source. DigitalOcean App Platform must have access to the repository. Only one of git, github, gitlab, or image may be set.
    """
    gitlab: Optional[List[Gitlab]] = None
    """
    A Gitlab repo to use as the component's source. DigitalOcean App Platform must have access to the repository. Only one of git, github, gitlab, or image may be set.
    """
    index_document: Annotated[Optional[str], Field(alias="indexDocument")] = None
    """
    The name of the index document to use when serving this static site.
    The name of the index document to use when serving this static site.
    """
    name: Optional[str] = None
    """
    The name of the app. Must be unique across all apps in the same account.
    The name of the component
    """
    output_dir: Annotated[Optional[str], Field(alias="outputDir")] = None
    """
    An optional path to where the built assets will be located, relative to the build context. If not set, App Platform will automatically scan for these directory names: _static, dist, public.
    An optional path to where the built assets will be located, relative to the build context. If not set, App Platform will automatically scan for these directory names: `_static`, `dist`, `public`.
    """
    routes: Optional[List[Route]] = None
    """
    (Deprecated - use ingress) An HTTP paths that should be routed to this component.
    """
    source_dir: Annotated[Optional[str], Field(alias="sourceDir")] = None
    """
    An optional path to the working directory to use for the build.
    An optional path to the working directory to use for the build.
    """


class Worker(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Worker"]:
            return Worker

        def build(self) -> "Worker":
            return Worker(**self._attrs)

        @overload
        def alert(self, value_or_callback: List[AlertModel], /) -> "Worker.Builder": ...

        @overload
        def alert(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[AlertModel, AlertModel.Builder]],
                GenericListBuilder[AlertModel, AlertModel.Builder] | List[AlertModel],
            ],
            /,
        ) -> "Worker.Builder": ...

        @overload
        def alert(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[AlertModel.Builder]: ...

        def alert(self, value_or_callback=None, /):
            """
            Describes an alert policy for the app.
            Alert policies for the app component
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[AlertModel.Builder]()
                context._parent_builder = self
                context._field_name = "alert"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AlertModel.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("alert", value)

        def build_command(self, value: Optional[str], /) -> Self:
            """
            An optional build command to run while building this component from source.
            An optional build command to run while building this component from source.
            """
            return self._set("build_command", value)

        def dockerfile_path(self, value: Optional[str], /) -> Self:
            """
            The path to a Dockerfile relative to the root of the repo. If set, overrides usage of buildpacks.
            The path to a Dockerfile relative to the root of the repo. If set, overrides usage of buildpacks.
            """
            return self._set("dockerfile_path", value)

        @overload
        def env(self, value_or_callback: List[Env], /) -> "Worker.Builder": ...

        @overload
        def env(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Env, Env.Builder]],
                GenericListBuilder[Env, Env.Builder] | List[Env],
            ],
            /,
        ) -> "Worker.Builder": ...

        @overload
        def env(self, value_or_callback: Never = ...) -> ListBuilderContext[Env.Builder]: ...

        def env(self, value_or_callback=None, /):
            """
            Describes an app-wide environment variable made available to all components.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Env.Builder]()
                context._parent_builder = self
                context._field_name = "env"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Env.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("env", value)

        def environment_slug(self, value: Optional[str], /) -> Self:
            """
            An environment slug describing the type of this app.
            An environment slug describing the type of this app.
            """
            return self._set("environment_slug", value)

        @overload
        def git(self, value_or_callback: List[Git], /) -> "Worker.Builder": ...

        @overload
        def git(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Git, Git.Builder]],
                GenericListBuilder[Git, Git.Builder] | List[Git],
            ],
            /,
        ) -> "Worker.Builder": ...

        @overload
        def git(self, value_or_callback: Never = ...) -> ListBuilderContext[Git.Builder]: ...

        def git(self, value_or_callback=None, /):
            """
            A Git repo to use as the component's source. The repository must be able to be cloned without authentication. Only one of git, github or gitlab may be set
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Git.Builder]()
                context._parent_builder = self
                context._field_name = "git"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Git.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("git", value)

        @overload
        def github(self, value_or_callback: List[Github], /) -> "Worker.Builder": ...

        @overload
        def github(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Github, Github.Builder]],
                GenericListBuilder[Github, Github.Builder] | List[Github],
            ],
            /,
        ) -> "Worker.Builder": ...

        @overload
        def github(self, value_or_callback: Never = ...) -> ListBuilderContext[Github.Builder]: ...

        def github(self, value_or_callback=None, /):
            """
            A GitHub repo to use as the component's source. DigitalOcean App Platform must have access to the repository. Only one of git, github, gitlab, or image may be set.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Github.Builder]()
                context._parent_builder = self
                context._field_name = "github"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Github.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("github", value)

        @overload
        def gitlab(self, value_or_callback: List[Gitlab], /) -> "Worker.Builder": ...

        @overload
        def gitlab(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Gitlab, Gitlab.Builder]],
                GenericListBuilder[Gitlab, Gitlab.Builder] | List[Gitlab],
            ],
            /,
        ) -> "Worker.Builder": ...

        @overload
        def gitlab(self, value_or_callback: Never = ...) -> ListBuilderContext[Gitlab.Builder]: ...

        def gitlab(self, value_or_callback=None, /):
            """
            A Gitlab repo to use as the component's source. DigitalOcean App Platform must have access to the repository. Only one of git, github, gitlab, or image may be set.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Gitlab.Builder]()
                context._parent_builder = self
                context._field_name = "gitlab"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Gitlab.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("gitlab", value)

        @overload
        def image(self, value_or_callback: List[Image], /) -> "Worker.Builder": ...

        @overload
        def image(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Image, Image.Builder]],
                GenericListBuilder[Image, Image.Builder] | List[Image],
            ],
            /,
        ) -> "Worker.Builder": ...

        @overload
        def image(self, value_or_callback: Never = ...) -> ListBuilderContext[Image.Builder]: ...

        def image(self, value_or_callback=None, /):
            """
            An image to use as the component's source. Only one of git, github, gitlab, or image may be set.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Image.Builder]()
                context._parent_builder = self
                context._field_name = "image"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Image.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("image", value)

        def instance_count(self, value: Optional[float], /) -> Self:
            """
            The amount of instances that this component should be scaled to.
            The amount of instances that this component should be scaled to.
            """
            return self._set("instance_count", value)

        def instance_size_slug(self, value: Optional[str], /) -> Self:
            """
            The instance size to use for this component. This determines the plan (basic or professional) and the available CPU and memory. The list of available instance sizes can be found with the API or using the doctl CLI (doctl apps tier instance-size list). Default: basic-xxs
            The instance size to use for this component.
            """
            return self._set("instance_size_slug", value)

        @overload
        def log_destination(
            self, value_or_callback: List[LogDestination], /
        ) -> "Worker.Builder": ...

        @overload
        def log_destination(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[LogDestination, LogDestination.Builder]],
                GenericListBuilder[LogDestination, LogDestination.Builder] | List[LogDestination],
            ],
            /,
        ) -> "Worker.Builder": ...

        @overload
        def log_destination(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[LogDestination.Builder]: ...

        def log_destination(self, value_or_callback=None, /):
            """
            Describes a log forwarding destination.
            Logs
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[LogDestination.Builder]()
                context._parent_builder = self
                context._field_name = "log_destination"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(LogDestination.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("log_destination", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            The name of the app. Must be unique across all apps in the same account.
            The name of the component
            """
            return self._set("name", value)

        def run_command(self, value: Optional[str], /) -> Self:
            """
            An optional run command to override the component's default.
            An optional run command to override the component's default.
            """
            return self._set("run_command", value)

        def source_dir(self, value: Optional[str], /) -> Self:
            """
            An optional path to the working directory to use for the build.
            An optional path to the working directory to use for the build.
            """
            return self._set("source_dir", value)

    class BuilderContext(BuilderContextBase["Worker.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Worker.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Worker."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Worker", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Worker.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    alert: Optional[List[AlertModel]] = None
    """
    Describes an alert policy for the app.
    Alert policies for the app component
    """
    build_command: Annotated[Optional[str], Field(alias="buildCommand")] = None
    """
    An optional build command to run while building this component from source.
    An optional build command to run while building this component from source.
    """
    dockerfile_path: Annotated[Optional[str], Field(alias="dockerfilePath")] = None
    """
    The path to a Dockerfile relative to the root of the repo. If set, overrides usage of buildpacks.
    The path to a Dockerfile relative to the root of the repo. If set, overrides usage of buildpacks.
    """
    env: Optional[List[Env]] = None
    """
    Describes an app-wide environment variable made available to all components.
    """
    environment_slug: Annotated[Optional[str], Field(alias="environmentSlug")] = None
    """
    An environment slug describing the type of this app.
    An environment slug describing the type of this app.
    """
    git: Optional[List[Git]] = None
    """
    A Git repo to use as the component's source. The repository must be able to be cloned without authentication. Only one of git, github or gitlab may be set
    """
    github: Optional[List[Github]] = None
    """
    A GitHub repo to use as the component's source. DigitalOcean App Platform must have access to the repository. Only one of git, github, gitlab, or image may be set.
    """
    gitlab: Optional[List[Gitlab]] = None
    """
    A Gitlab repo to use as the component's source. DigitalOcean App Platform must have access to the repository. Only one of git, github, gitlab, or image may be set.
    """
    image: Optional[List[Image]] = None
    """
    An image to use as the component's source. Only one of git, github, gitlab, or image may be set.
    """
    instance_count: Annotated[Optional[float], Field(alias="instanceCount")] = None
    """
    The amount of instances that this component should be scaled to.
    The amount of instances that this component should be scaled to.
    """
    instance_size_slug: Annotated[Optional[str], Field(alias="instanceSizeSlug")] = None
    """
    The instance size to use for this component. This determines the plan (basic or professional) and the available CPU and memory. The list of available instance sizes can be found with the API or using the doctl CLI (doctl apps tier instance-size list). Default: basic-xxs
    The instance size to use for this component.
    """
    log_destination: Annotated[Optional[List[LogDestination]], Field(alias="logDestination")] = None
    """
    Describes a log forwarding destination.
    Logs
    """
    name: Optional[str] = None
    """
    The name of the app. Must be unique across all apps in the same account.
    The name of the component
    """
    run_command: Annotated[Optional[str], Field(alias="runCommand")] = None
    """
    An optional run command to override the component's default.
    An optional run command to override the component's default.
    """
    source_dir: Annotated[Optional[str], Field(alias="sourceDir")] = None
    """
    An optional path to the working directory to use for the build.
    An optional path to the working directory to use for the build.
    """


class Spec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Spec"]:
            return Spec

        def build(self) -> "Spec":
            return Spec(**self._attrs)

        @overload
        def alert(self, value_or_callback: List[Alert], /) -> "Spec.Builder": ...

        @overload
        def alert(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Alert, Alert.Builder]],
                GenericListBuilder[Alert, Alert.Builder] | List[Alert],
            ],
            /,
        ) -> "Spec.Builder": ...

        @overload
        def alert(self, value_or_callback: Never = ...) -> ListBuilderContext[Alert.Builder]: ...

        def alert(self, value_or_callback=None, /):
            """
            Describes an alert policy for the app.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Alert.Builder]()
                context._parent_builder = self
                context._field_name = "alert"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Alert.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("alert", value)

        @overload
        def database(self, value_or_callback: List[Database], /) -> "Spec.Builder": ...

        @overload
        def database(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Database, Database.Builder]],
                GenericListBuilder[Database, Database.Builder] | List[Database],
            ],
            /,
        ) -> "Spec.Builder": ...

        @overload
        def database(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Database.Builder]: ...

        def database(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Database.Builder]()
                context._parent_builder = self
                context._field_name = "database"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Database.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("database", value)

        @overload
        def domain(self, value_or_callback: List[Domain], /) -> "Spec.Builder": ...

        @overload
        def domain(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Domain, Domain.Builder]],
                GenericListBuilder[Domain, Domain.Builder] | List[Domain],
            ],
            /,
        ) -> "Spec.Builder": ...

        @overload
        def domain(self, value_or_callback: Never = ...) -> ListBuilderContext[Domain.Builder]: ...

        def domain(self, value_or_callback=None, /):
            """
            Describes a domain where the application will be made available.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Domain.Builder]()
                context._parent_builder = self
                context._field_name = "domain"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Domain.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("domain", value)

        def domains(self, value: Optional[List[str]], /) -> Self:
            return self._set("domains", value)

        @overload
        def egress(self, value_or_callback: List[Egres], /) -> "Spec.Builder": ...

        @overload
        def egress(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Egres, Egres.Builder]],
                GenericListBuilder[Egres, Egres.Builder] | List[Egres],
            ],
            /,
        ) -> "Spec.Builder": ...

        @overload
        def egress(self, value_or_callback: Never = ...) -> ListBuilderContext[Egres.Builder]: ...

        def egress(self, value_or_callback=None, /):
            """
            Specification for app egress configurations.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Egres.Builder]()
                context._parent_builder = self
                context._field_name = "egress"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Egres.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("egress", value)

        @overload
        def env(self, value_or_callback: List[Env], /) -> "Spec.Builder": ...

        @overload
        def env(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Env, Env.Builder]],
                GenericListBuilder[Env, Env.Builder] | List[Env],
            ],
            /,
        ) -> "Spec.Builder": ...

        @overload
        def env(self, value_or_callback: Never = ...) -> ListBuilderContext[Env.Builder]: ...

        def env(self, value_or_callback=None, /):
            """
            Describes an app-wide environment variable made available to all components.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Env.Builder]()
                context._parent_builder = self
                context._field_name = "env"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Env.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("env", value)

        def features(self, value: Optional[List[str]], /) -> Self:
            """
            A list of the features applied to the app. The default buildpack can be overridden here. List of available buildpacks can be found using the doctl CLI
            List of features which is applied to the app
            """
            return self._set("features", value)

        @overload
        def function(self, value_or_callback: List[Function], /) -> "Spec.Builder": ...

        @overload
        def function(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Function, Function.Builder]],
                GenericListBuilder[Function, Function.Builder] | List[Function],
            ],
            /,
        ) -> "Spec.Builder": ...

        @overload
        def function(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Function.Builder]: ...

        def function(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Function.Builder]()
                context._parent_builder = self
                context._field_name = "function"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Function.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("function", value)

        @overload
        def ingress(self, value_or_callback: List[Ingres], /) -> "Spec.Builder": ...

        @overload
        def ingress(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Ingres, Ingres.Builder]],
                GenericListBuilder[Ingres, Ingres.Builder] | List[Ingres],
            ],
            /,
        ) -> "Spec.Builder": ...

        @overload
        def ingress(self, value_or_callback: Never = ...) -> ListBuilderContext[Ingres.Builder]: ...

        def ingress(self, value_or_callback=None, /):
            """
            Specification for component routing, rewrites, and redirects.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Ingres.Builder]()
                context._parent_builder = self
                context._field_name = "ingress"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Ingres.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("ingress", value)

        @overload
        def job(self, value_or_callback: List[Job], /) -> "Spec.Builder": ...

        @overload
        def job(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Job, Job.Builder]],
                GenericListBuilder[Job, Job.Builder] | List[Job],
            ],
            /,
        ) -> "Spec.Builder": ...

        @overload
        def job(self, value_or_callback: Never = ...) -> ListBuilderContext[Job.Builder]: ...

        def job(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Job.Builder]()
                context._parent_builder = self
                context._field_name = "job"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Job.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("job", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            The name of the app. Must be unique across all apps in the same account.
            The name of the app. Must be unique across all apps in the same account.
            """
            return self._set("name", value)

        def region(self, value: Optional[str], /) -> Self:
            """
            The slug for the DigitalOcean data center region hosting the app.
            The slug for the DigitalOcean data center region hosting the app
            """
            return self._set("region", value)

        @overload
        def service(self, value_or_callback: List[Service], /) -> "Spec.Builder": ...

        @overload
        def service(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Service, Service.Builder]],
                GenericListBuilder[Service, Service.Builder] | List[Service],
            ],
            /,
        ) -> "Spec.Builder": ...

        @overload
        def service(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Service.Builder]: ...

        def service(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Service.Builder]()
                context._parent_builder = self
                context._field_name = "service"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Service.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("service", value)

        @overload
        def static_site(self, value_or_callback: List[StaticSite], /) -> "Spec.Builder": ...

        @overload
        def static_site(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[StaticSite, StaticSite.Builder]],
                GenericListBuilder[StaticSite, StaticSite.Builder] | List[StaticSite],
            ],
            /,
        ) -> "Spec.Builder": ...

        @overload
        def static_site(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[StaticSite.Builder]: ...

        def static_site(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[StaticSite.Builder]()
                context._parent_builder = self
                context._field_name = "static_site"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(StaticSite.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("static_site", value)

        @overload
        def worker(self, value_or_callback: List[Worker], /) -> "Spec.Builder": ...

        @overload
        def worker(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Worker, Worker.Builder]],
                GenericListBuilder[Worker, Worker.Builder] | List[Worker],
            ],
            /,
        ) -> "Spec.Builder": ...

        @overload
        def worker(self, value_or_callback: Never = ...) -> ListBuilderContext[Worker.Builder]: ...

        def worker(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Worker.Builder]()
                context._parent_builder = self
                context._field_name = "worker"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Worker.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("worker", value)

    class BuilderContext(BuilderContextBase["Spec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Spec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Spec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Spec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Spec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    alert: Optional[List[Alert]] = None
    """
    Describes an alert policy for the app.
    """
    database: Optional[List[Database]] = None
    domain: Optional[List[Domain]] = None
    """
    Describes a domain where the application will be made available.
    """
    domains: Optional[List[str]] = None
    egress: Optional[List[Egres]] = None
    """
    Specification for app egress configurations.
    """
    env: Optional[List[Env]] = None
    """
    Describes an app-wide environment variable made available to all components.
    """
    features: Optional[List[str]] = None
    """
    A list of the features applied to the app. The default buildpack can be overridden here. List of available buildpacks can be found using the doctl CLI
    List of features which is applied to the app
    """
    function: Optional[List[Function]] = None
    ingress: Optional[List[Ingres]] = None
    """
    Specification for component routing, rewrites, and redirects.
    """
    job: Optional[List[Job]] = None
    name: Optional[str] = None
    """
    The name of the app. Must be unique across all apps in the same account.
    The name of the app. Must be unique across all apps in the same account.
    """
    region: Optional[str] = None
    """
    The slug for the DigitalOcean data center region hosting the app.
    The slug for the DigitalOcean data center region hosting the app
    """
    service: Optional[List[Service]] = None
    static_site: Annotated[Optional[List[StaticSite]], Field(alias="staticSite")] = None
    worker: Optional[List[Worker]] = None


class ForProvider(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ForProvider"]:
            return ForProvider

        def build(self) -> "ForProvider":
            return ForProvider(**self._attrs)

        @overload
        def dedicated_ips(
            self, value_or_callback: List[DedicatedIp], /
        ) -> "ForProvider.Builder": ...

        @overload
        def dedicated_ips(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[DedicatedIp, DedicatedIp.Builder]],
                GenericListBuilder[DedicatedIp, DedicatedIp.Builder] | List[DedicatedIp],
            ],
            /,
        ) -> "ForProvider.Builder": ...

        @overload
        def dedicated_ips(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[DedicatedIp.Builder]: ...

        def dedicated_ips(self, value_or_callback=None, /):
            """
            The dedicated egress IP addresses associated with the app.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[DedicatedIp.Builder]()
                context._parent_builder = self
                context._field_name = "dedicated_ips"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(DedicatedIp.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("dedicated_ips", value)

        def project_id(self, value: Optional[str], /) -> Self:
            """
            The ID of the project that the app is assigned to.
            """
            return self._set("project_id", value)

        @overload
        def project_id_ref(
            self, value_or_callback: Optional[ProjectIdRef], /
        ) -> "ForProvider.Builder": ...

        @overload
        def project_id_ref(
            self,
            value_or_callback: Callable[
                [ProjectIdRef.Builder], ProjectIdRef.Builder | ProjectIdRef
            ],
            /,
        ) -> "ForProvider.Builder": ...

        @overload
        def project_id_ref(
            self, value_or_callback: Never = ...
        ) -> "ProjectIdRef.BuilderContext": ...

        def project_id_ref(self, value_or_callback=None, /):
            """
            Reference to a Project in project to populate projectId.
            """
            if self._in_context and value_or_callback is None:
                context = ProjectIdRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "project_id_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ProjectIdRef.builder())
                if isinstance(output, ProjectIdRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("project_id_ref", value)

        @overload
        def project_id_selector(
            self, value_or_callback: Optional[ProjectIdSelector], /
        ) -> "ForProvider.Builder": ...

        @overload
        def project_id_selector(
            self,
            value_or_callback: Callable[
                [ProjectIdSelector.Builder],
                ProjectIdSelector.Builder | ProjectIdSelector,
            ],
            /,
        ) -> "ForProvider.Builder": ...

        @overload
        def project_id_selector(
            self, value_or_callback: Never = ...
        ) -> "ProjectIdSelector.BuilderContext": ...

        def project_id_selector(self, value_or_callback=None, /):
            """
            Selector for a Project in project to populate projectId.
            """
            if self._in_context and value_or_callback is None:
                context = ProjectIdSelector.BuilderContext()
                context._parent_builder = self
                context._field_name = "project_id_selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ProjectIdSelector.builder())
                if isinstance(output, ProjectIdSelector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("project_id_selector", value)

        @overload
        def spec(self, value_or_callback: List[Spec], /) -> "ForProvider.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Spec, Spec.Builder]],
                GenericListBuilder[Spec, Spec.Builder] | List[Spec],
            ],
            /,
        ) -> "ForProvider.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> ListBuilderContext[Spec.Builder]: ...

        def spec(self, value_or_callback=None, /):
            """
            A DigitalOcean App spec describing the app.
            A DigitalOcean App Platform Spec
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Spec.Builder]()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Spec.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

    class BuilderContext(BuilderContextBase["ForProvider.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ForProvider.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ForProvider."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ForProvider", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ForProvider.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    dedicated_ips: Annotated[Optional[List[DedicatedIp]], Field(alias="dedicatedIps")] = None
    """
    The dedicated egress IP addresses associated with the app.
    """
    project_id: Annotated[Optional[str], Field(alias="projectId")] = None
    """
    The ID of the project that the app is assigned to.
    """
    project_id_ref: Annotated[Optional[ProjectIdRef], Field(alias="projectIdRef")] = None
    """
    Reference to a Project in project to populate projectId.
    """
    project_id_selector: Annotated[
        Optional[ProjectIdSelector], Field(alias="projectIdSelector")
    ] = None
    """
    Selector for a Project in project to populate projectId.
    """
    spec: Optional[List[Spec]] = None
    """
    A DigitalOcean App spec describing the app.
    A DigitalOcean App Platform Spec
    """


class AlertModel1(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AlertModel1"]:
            return AlertModel1

        def build(self) -> "AlertModel1":
            return AlertModel1(**self._attrs)

        def disabled(self, value: Optional[bool], /) -> Self:
            """
            Determines whether or not the alert is disabled (default: false).
            """
            return self._set("disabled", value)

        def rule(self, value: Optional[str], /) -> Self:
            """
            The type of the alert to configure. Top-level app alert policies can be: DEPLOYMENT_CANCELLED, DEPLOYMENT_FAILED, DEPLOYMENT_LIVE, DEPLOYMENT_STARTED, DOMAIN_FAILED, or DOMAIN_LIVE.
            """
            return self._set("rule", value)

    class BuilderContext(BuilderContextBase["AlertModel1.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AlertModel1.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AlertModel1."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AlertModel1", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AlertModel1.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    disabled: Optional[bool] = None
    """
    Determines whether or not the alert is disabled (default: false).
    """
    rule: Optional[str] = None
    """
    The type of the alert to configure. Top-level app alert policies can be: DEPLOYMENT_CANCELLED, DEPLOYMENT_FAILED, DEPLOYMENT_LIVE, DEPLOYMENT_STARTED, DOMAIN_FAILED, or DOMAIN_LIVE.
    """


class AlertModel2(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AlertModel2"]:
            return AlertModel2

        def build(self) -> "AlertModel2":
            return AlertModel2(**self._attrs)

        def disabled(self, value: Optional[bool], /) -> Self:
            """
            Determines whether or not the alert is disabled (default: false).
            """
            return self._set("disabled", value)

        def operator(self, value: Optional[str], /) -> Self:
            """
            The operator to use. This is either of GREATER_THAN or LESS_THAN.
            """
            return self._set("operator", value)

        def rule(self, value: Optional[str], /) -> Self:
            """
            The type of the alert to configure. Top-level app alert policies can be: DEPLOYMENT_CANCELLED, DEPLOYMENT_FAILED, DEPLOYMENT_LIVE, DEPLOYMENT_STARTED, DOMAIN_FAILED, or DOMAIN_LIVE.
            """
            return self._set("rule", value)

        def value(self, value: Optional[float], /) -> Self:
            """
            The value of the environment variable.
            """
            return self._set("value", value)

        def window(self, value: Optional[str], /) -> Self:
            """
            The time before alerts should be triggered. This is may be one of: FIVE_MINUTES, TEN_MINUTES, THIRTY_MINUTES, ONE_HOUR.
            """
            return self._set("window", value)

    class BuilderContext(BuilderContextBase["AlertModel2.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AlertModel2.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AlertModel2."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AlertModel2", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AlertModel2.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    disabled: Optional[bool] = None
    """
    Determines whether or not the alert is disabled (default: false).
    """
    operator: Optional[str] = None
    """
    The operator to use. This is either of GREATER_THAN or LESS_THAN.
    """
    rule: Optional[str] = None
    """
    The type of the alert to configure. Top-level app alert policies can be: DEPLOYMENT_CANCELLED, DEPLOYMENT_FAILED, DEPLOYMENT_LIVE, DEPLOYMENT_STARTED, DOMAIN_FAILED, or DOMAIN_LIVE.
    """
    value: Optional[float] = None
    """
    The value of the environment variable.
    """
    window: Optional[str] = None
    """
    The time before alerts should be triggered. This is may be one of: FIVE_MINUTES, TEN_MINUTES, THIRTY_MINUTES, ONE_HOUR.
    """


class InitProvider(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["InitProvider"]:
            return InitProvider

        def build(self) -> "InitProvider":
            return InitProvider(**self._attrs)

        @overload
        def dedicated_ips(
            self, value_or_callback: List[DedicatedIp], /
        ) -> "InitProvider.Builder": ...

        @overload
        def dedicated_ips(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[DedicatedIp, DedicatedIp.Builder]],
                GenericListBuilder[DedicatedIp, DedicatedIp.Builder] | List[DedicatedIp],
            ],
            /,
        ) -> "InitProvider.Builder": ...

        @overload
        def dedicated_ips(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[DedicatedIp.Builder]: ...

        def dedicated_ips(self, value_or_callback=None, /):
            """
            The dedicated egress IP addresses associated with the app.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[DedicatedIp.Builder]()
                context._parent_builder = self
                context._field_name = "dedicated_ips"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(DedicatedIp.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("dedicated_ips", value)

        def project_id(self, value: Optional[str], /) -> Self:
            """
            The ID of the project that the app is assigned to.
            """
            return self._set("project_id", value)

        @overload
        def project_id_ref(
            self, value_or_callback: Optional[ProjectIdRef], /
        ) -> "InitProvider.Builder": ...

        @overload
        def project_id_ref(
            self,
            value_or_callback: Callable[
                [ProjectIdRef.Builder], ProjectIdRef.Builder | ProjectIdRef
            ],
            /,
        ) -> "InitProvider.Builder": ...

        @overload
        def project_id_ref(
            self, value_or_callback: Never = ...
        ) -> "ProjectIdRef.BuilderContext": ...

        def project_id_ref(self, value_or_callback=None, /):
            """
            Reference to a Project in project to populate projectId.
            """
            if self._in_context and value_or_callback is None:
                context = ProjectIdRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "project_id_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ProjectIdRef.builder())
                if isinstance(output, ProjectIdRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("project_id_ref", value)

        @overload
        def project_id_selector(
            self, value_or_callback: Optional[ProjectIdSelector], /
        ) -> "InitProvider.Builder": ...

        @overload
        def project_id_selector(
            self,
            value_or_callback: Callable[
                [ProjectIdSelector.Builder],
                ProjectIdSelector.Builder | ProjectIdSelector,
            ],
            /,
        ) -> "InitProvider.Builder": ...

        @overload
        def project_id_selector(
            self, value_or_callback: Never = ...
        ) -> "ProjectIdSelector.BuilderContext": ...

        def project_id_selector(self, value_or_callback=None, /):
            """
            Selector for a Project in project to populate projectId.
            """
            if self._in_context and value_or_callback is None:
                context = ProjectIdSelector.BuilderContext()
                context._parent_builder = self
                context._field_name = "project_id_selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ProjectIdSelector.builder())
                if isinstance(output, ProjectIdSelector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("project_id_selector", value)

        @overload
        def spec(self, value_or_callback: List[Spec], /) -> "InitProvider.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Spec, Spec.Builder]],
                GenericListBuilder[Spec, Spec.Builder] | List[Spec],
            ],
            /,
        ) -> "InitProvider.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> ListBuilderContext[Spec.Builder]: ...

        def spec(self, value_or_callback=None, /):
            """
            A DigitalOcean App spec describing the app.
            A DigitalOcean App Platform Spec
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Spec.Builder]()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Spec.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

    class BuilderContext(BuilderContextBase["InitProvider.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = InitProvider.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for InitProvider."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["InitProvider", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use InitProvider.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    dedicated_ips: Annotated[Optional[List[DedicatedIp]], Field(alias="dedicatedIps")] = None
    """
    The dedicated egress IP addresses associated with the app.
    """
    project_id: Annotated[Optional[str], Field(alias="projectId")] = None
    """
    The ID of the project that the app is assigned to.
    """
    project_id_ref: Annotated[Optional[ProjectIdRef], Field(alias="projectIdRef")] = None
    """
    Reference to a Project in project to populate projectId.
    """
    project_id_selector: Annotated[
        Optional[ProjectIdSelector], Field(alias="projectIdSelector")
    ] = None
    """
    Selector for a Project in project to populate projectId.
    """
    spec: Optional[List[Spec]] = None
    """
    A DigitalOcean App spec describing the app.
    A DigitalOcean App Platform Spec
    """


class ProviderConfigRef(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ProviderConfigRef"]:
            return ProviderConfigRef

        def build(self) -> "ProviderConfigRef":
            return ProviderConfigRef(**self._attrs)

        def name(self, value: str, /) -> Self:
            """
            Name of the referenced object.
            """
            return self._set("name", value)

        @overload
        def policy(self, value_or_callback: Optional[Policy], /) -> "ProviderConfigRef.Builder": ...

        @overload
        def policy(
            self,
            value_or_callback: Callable[[Policy.Builder], Policy.Builder | Policy],
            /,
        ) -> "ProviderConfigRef.Builder": ...

        @overload
        def policy(self, value_or_callback: Never = ...) -> "Policy.BuilderContext": ...

        def policy(self, value_or_callback=None, /):
            """
            Policies for referencing.
            """
            if self._in_context and value_or_callback is None:
                context = Policy.BuilderContext()
                context._parent_builder = self
                context._field_name = "policy"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Policy.builder())
                if isinstance(output, Policy.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("policy", value)

    class BuilderContext(BuilderContextBase["ProviderConfigRef.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ProviderConfigRef.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ProviderConfigRef."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ProviderConfigRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ProviderConfigRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: str
    """
    Name of the referenced object.
    """
    policy: Optional[Policy] = None
    """
    Policies for referencing.
    """


class ConfigRef(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ConfigRef"]:
            return ConfigRef

        def build(self) -> "ConfigRef":
            return ConfigRef(**self._attrs)

        def name(self, value: str, /) -> Self:
            """
            Name of the referenced object.
            """
            return self._set("name", value)

        @overload
        def policy(self, value_or_callback: Optional[Policy], /) -> "ConfigRef.Builder": ...

        @overload
        def policy(
            self,
            value_or_callback: Callable[[Policy.Builder], Policy.Builder | Policy],
            /,
        ) -> "ConfigRef.Builder": ...

        @overload
        def policy(self, value_or_callback: Never = ...) -> "Policy.BuilderContext": ...

        def policy(self, value_or_callback=None, /):
            """
            Policies for referencing.
            """
            if self._in_context and value_or_callback is None:
                context = Policy.BuilderContext()
                context._parent_builder = self
                context._field_name = "policy"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Policy.builder())
                if isinstance(output, Policy.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("policy", value)

    class BuilderContext(BuilderContextBase["ConfigRef.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ConfigRef.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ConfigRef."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ConfigRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ConfigRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: str
    """
    Name of the referenced object.
    """
    policy: Optional[Policy] = None
    """
    Policies for referencing.
    """


class Metadata(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Metadata"]:
            return Metadata

        def build(self) -> "Metadata":
            return Metadata(**self._attrs)

        def annotations(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            Annotations are the annotations to be added to connection secret.
            - For Kubernetes secrets, this will be used as "metadata.annotations".
            - It is up to Secret Store implementation for others store types.
            """
            return self._set("annotations", value)

        def labels(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            Labels are the labels/tags to be added to connection secret.
            - For Kubernetes secrets, this will be used as "metadata.labels".
            - It is up to Secret Store implementation for others store types.
            """
            return self._set("labels", value)

        def type(self, value: Optional[str], /) -> Self:
            """
            Type is the SecretType for the connection secret.
            - Only valid for Kubernetes Secret Stores.
            """
            return self._set("type", value)

    class BuilderContext(BuilderContextBase["Metadata.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Metadata.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Metadata."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Metadata", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Metadata.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    annotations: Optional[Dict[str, str]] = None
    """
    Annotations are the annotations to be added to connection secret.
    - For Kubernetes secrets, this will be used as "metadata.annotations".
    - It is up to Secret Store implementation for others store types.
    """
    labels: Optional[Dict[str, str]] = None
    """
    Labels are the labels/tags to be added to connection secret.
    - For Kubernetes secrets, this will be used as "metadata.labels".
    - It is up to Secret Store implementation for others store types.
    """
    type: Optional[str] = None
    """
    Type is the SecretType for the connection secret.
    - Only valid for Kubernetes Secret Stores.
    """


class PublishConnectionDetailsTo(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PublishConnectionDetailsTo"]:
            return PublishConnectionDetailsTo

        def build(self) -> "PublishConnectionDetailsTo":
            return PublishConnectionDetailsTo(**self._attrs)

        @overload
        def config_ref(
            self, value_or_callback: Optional[ConfigRef], /
        ) -> "PublishConnectionDetailsTo.Builder": ...

        @overload
        def config_ref(
            self,
            value_or_callback: Callable[[ConfigRef.Builder], ConfigRef.Builder | ConfigRef],
            /,
        ) -> "PublishConnectionDetailsTo.Builder": ...

        @overload
        def config_ref(self, value_or_callback: Never = ...) -> "ConfigRef.BuilderContext": ...

        def config_ref(self, value_or_callback=None, /):
            """
            SecretStoreConfigRef specifies which secret store config should be used
            for this ConnectionSecret.
            """
            if self._in_context and value_or_callback is None:
                context = ConfigRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "config_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ConfigRef.builder())
                if isinstance(output, ConfigRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("config_ref", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[Metadata], /
        ) -> "PublishConnectionDetailsTo.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[[Metadata.Builder], Metadata.Builder | Metadata],
            /,
        ) -> "PublishConnectionDetailsTo.Builder": ...

        @overload
        def metadata(self, value_or_callback: Never = ...) -> "Metadata.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            """
            Metadata is the metadata for connection secret.
            """
            if self._in_context and value_or_callback is None:
                context = Metadata.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Metadata.builder())
                if isinstance(output, Metadata.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        def name(self, value: str, /) -> Self:
            """
            Name is the name of the connection secret.
            """
            return self._set("name", value)

    class BuilderContext(BuilderContextBase["PublishConnectionDetailsTo.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PublishConnectionDetailsTo.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PublishConnectionDetailsTo."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["PublishConnectionDetailsTo", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PublishConnectionDetailsTo.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    config_ref: Annotated[
        Optional[ConfigRef],
        Field(
            default_factory=lambda: ConfigRef.model_validate({"name": "default"}),
            alias="configRef",
        ),
    ] = {"name": "default"}
    """
    SecretStoreConfigRef specifies which secret store config should be used
    for this ConnectionSecret.
    """
    metadata: Optional[Metadata] = None
    """
    Metadata is the metadata for connection secret.
    """
    name: str
    """
    Name is the name of the connection secret.
    """


class WriteConnectionSecretToRef(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["WriteConnectionSecretToRef"]:
            return WriteConnectionSecretToRef

        def build(self) -> "WriteConnectionSecretToRef":
            return WriteConnectionSecretToRef(**self._attrs)

        def name(self, value: str, /) -> Self:
            """
            Name of the secret.
            """
            return self._set("name", value)

        def namespace(self, value: str, /) -> Self:
            """
            Namespace of the secret.
            """
            return self._set("namespace", value)

    class BuilderContext(BuilderContextBase["WriteConnectionSecretToRef.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = WriteConnectionSecretToRef.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for WriteConnectionSecretToRef."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["WriteConnectionSecretToRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use WriteConnectionSecretToRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: str
    """
    Name of the secret.
    """
    namespace: str
    """
    Namespace of the secret.
    """


class AppSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AppSpec"]:
            return AppSpec

        def build(self) -> "AppSpec":
            return AppSpec(**self._attrs)

        def deletion_policy(self, value: Optional[Literal["Orphan", "Delete"]], /) -> Self:
            """
            DeletionPolicy specifies what will happen to the underlying external
            when this managed resource is deleted - either "Delete" or "Orphan" the
            external resource.
            This field is planned to be deprecated in favor of the ManagementPolicies
            field in a future release. Currently, both could be set independently and
            non-default values would be honored if the feature flag is enabled.
            See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
            """
            return self._set("deletion_policy", value)

        @overload
        def for_provider(self, value_or_callback: ForProvider, /) -> "AppSpec.Builder": ...

        @overload
        def for_provider(
            self,
            value_or_callback: Callable[[ForProvider.Builder], ForProvider.Builder | ForProvider],
            /,
        ) -> "AppSpec.Builder": ...

        @overload
        def for_provider(self, value_or_callback: Never = ...) -> "ForProvider.BuilderContext": ...

        def for_provider(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ForProvider.BuilderContext()
                context._parent_builder = self
                context._field_name = "for_provider"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ForProvider.builder())
                if isinstance(output, ForProvider.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("for_provider", value)

        @overload
        def init_provider(
            self, value_or_callback: Optional[InitProvider], /
        ) -> "AppSpec.Builder": ...

        @overload
        def init_provider(
            self,
            value_or_callback: Callable[
                [InitProvider.Builder], InitProvider.Builder | InitProvider
            ],
            /,
        ) -> "AppSpec.Builder": ...

        @overload
        def init_provider(
            self, value_or_callback: Never = ...
        ) -> "InitProvider.BuilderContext": ...

        def init_provider(self, value_or_callback=None, /):
            """
            THIS IS A BETA FIELD. It will be honored
            unless the Management Policies feature flag is disabled.
            InitProvider holds the same fields as ForProvider, with the exception
            of Identifier and other resource reference fields. The fields that are
            in InitProvider are merged into ForProvider when the resource is created.
            The same fields are also added to the terraform ignore_changes hook, to
            avoid updating them after creation. This is useful for fields that are
            required on creation, but we do not desire to update them after creation,
            for example because of an external controller is managing them, like an
            autoscaler.
            """
            if self._in_context and value_or_callback is None:
                context = InitProvider.BuilderContext()
                context._parent_builder = self
                context._field_name = "init_provider"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(InitProvider.builder())
                if isinstance(output, InitProvider.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("init_provider", value)

        def management_policies(
            self,
            value: Optional[
                List[Literal["Observe", "Create", "Update", "Delete", "LateInitialize", "*"]]
            ],
            /,
        ) -> Self:
            """
            THIS IS A BETA FIELD. It is on by default but can be opted out
            through a Crossplane feature flag.
            ManagementPolicies specify the array of actions Crossplane is allowed to
            take on the managed and external resources.
            This field is planned to replace the DeletionPolicy field in a future
            release. Currently, both could be set independently and non-default
            values would be honored if the feature flag is enabled. If both are
            custom, the DeletionPolicy field will be ignored.
            See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
            and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
            """
            return self._set("management_policies", value)

        @overload
        def provider_config_ref(
            self, value_or_callback: Optional[ProviderConfigRef], /
        ) -> "AppSpec.Builder": ...

        @overload
        def provider_config_ref(
            self,
            value_or_callback: Callable[
                [ProviderConfigRef.Builder],
                ProviderConfigRef.Builder | ProviderConfigRef,
            ],
            /,
        ) -> "AppSpec.Builder": ...

        @overload
        def provider_config_ref(
            self, value_or_callback: Never = ...
        ) -> "ProviderConfigRef.BuilderContext": ...

        def provider_config_ref(self, value_or_callback=None, /):
            """
            ProviderConfigReference specifies how the provider that will be used to
            create, observe, update, and delete this managed resource should be
            configured.
            """
            if self._in_context and value_or_callback is None:
                context = ProviderConfigRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "provider_config_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ProviderConfigRef.builder())
                if isinstance(output, ProviderConfigRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("provider_config_ref", value)

        @overload
        def publish_connection_details_to(
            self, value_or_callback: Optional[PublishConnectionDetailsTo], /
        ) -> "AppSpec.Builder": ...

        @overload
        def publish_connection_details_to(
            self,
            value_or_callback: Callable[
                [PublishConnectionDetailsTo.Builder],
                PublishConnectionDetailsTo.Builder | PublishConnectionDetailsTo,
            ],
            /,
        ) -> "AppSpec.Builder": ...

        @overload
        def publish_connection_details_to(
            self, value_or_callback: Never = ...
        ) -> "PublishConnectionDetailsTo.BuilderContext": ...

        def publish_connection_details_to(self, value_or_callback=None, /):
            """
            PublishConnectionDetailsTo specifies the connection secret config which
            contains a name, metadata and a reference to secret store config to
            which any connection details for this managed resource should be written.
            Connection details frequently include the endpoint, username,
            and password required to connect to the managed resource.
            """
            if self._in_context and value_or_callback is None:
                context = PublishConnectionDetailsTo.BuilderContext()
                context._parent_builder = self
                context._field_name = "publish_connection_details_to"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PublishConnectionDetailsTo.builder())
                if isinstance(output, PublishConnectionDetailsTo.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("publish_connection_details_to", value)

        @overload
        def write_connection_secret_to_ref(
            self, value_or_callback: Optional[WriteConnectionSecretToRef], /
        ) -> "AppSpec.Builder": ...

        @overload
        def write_connection_secret_to_ref(
            self,
            value_or_callback: Callable[
                [WriteConnectionSecretToRef.Builder],
                WriteConnectionSecretToRef.Builder | WriteConnectionSecretToRef,
            ],
            /,
        ) -> "AppSpec.Builder": ...

        @overload
        def write_connection_secret_to_ref(
            self, value_or_callback: Never = ...
        ) -> "WriteConnectionSecretToRef.BuilderContext": ...

        def write_connection_secret_to_ref(self, value_or_callback=None, /):
            """
            WriteConnectionSecretToReference specifies the namespace and name of a
            Secret to which any connection details for this managed resource should
            be written. Connection details frequently include the endpoint, username,
            and password required to connect to the managed resource.
            This field is planned to be replaced in a future release in favor of
            PublishConnectionDetailsTo. Currently, both could be set independently
            and connection details would be published to both without affecting
            each other.
            """
            if self._in_context and value_or_callback is None:
                context = WriteConnectionSecretToRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "write_connection_secret_to_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(WriteConnectionSecretToRef.builder())
                if isinstance(output, WriteConnectionSecretToRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("write_connection_secret_to_ref", value)

    class BuilderContext(BuilderContextBase["AppSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AppSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AppSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AppSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AppSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    deletion_policy: Annotated[
        Optional[Literal["Orphan", "Delete"]], Field(alias="deletionPolicy")
    ] = "Delete"
    """
    DeletionPolicy specifies what will happen to the underlying external
    when this managed resource is deleted - either "Delete" or "Orphan" the
    external resource.
    This field is planned to be deprecated in favor of the ManagementPolicies
    field in a future release. Currently, both could be set independently and
    non-default values would be honored if the feature flag is enabled.
    See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    """
    for_provider: Annotated[ForProvider, Field(alias="forProvider")]
    init_provider: Annotated[Optional[InitProvider], Field(alias="initProvider")] = None
    """
    THIS IS A BETA FIELD. It will be honored
    unless the Management Policies feature flag is disabled.
    InitProvider holds the same fields as ForProvider, with the exception
    of Identifier and other resource reference fields. The fields that are
    in InitProvider are merged into ForProvider when the resource is created.
    The same fields are also added to the terraform ignore_changes hook, to
    avoid updating them after creation. This is useful for fields that are
    required on creation, but we do not desire to update them after creation,
    for example because of an external controller is managing them, like an
    autoscaler.
    """
    management_policies: Annotated[
        Optional[List[Literal["Observe", "Create", "Update", "Delete", "LateInitialize", "*"]]],
        Field(alias="managementPolicies"),
    ] = ["*"]
    """
    THIS IS A BETA FIELD. It is on by default but can be opted out
    through a Crossplane feature flag.
    ManagementPolicies specify the array of actions Crossplane is allowed to
    take on the managed and external resources.
    This field is planned to replace the DeletionPolicy field in a future
    release. Currently, both could be set independently and non-default
    values would be honored if the feature flag is enabled. If both are
    custom, the DeletionPolicy field will be ignored.
    See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
    """
    provider_config_ref: Annotated[
        Optional[ProviderConfigRef],
        Field(
            default_factory=lambda: ProviderConfigRef.model_validate({"name": "default"}),
            alias="providerConfigRef",
        ),
    ] = {"name": "default"}
    """
    ProviderConfigReference specifies how the provider that will be used to
    create, observe, update, and delete this managed resource should be
    configured.
    """
    publish_connection_details_to: Annotated[
        Optional[PublishConnectionDetailsTo], Field(alias="publishConnectionDetailsTo")
    ] = None
    """
    PublishConnectionDetailsTo specifies the connection secret config which
    contains a name, metadata and a reference to secret store config to
    which any connection details for this managed resource should be written.
    Connection details frequently include the endpoint, username,
    and password required to connect to the managed resource.
    """
    write_connection_secret_to_ref: Annotated[
        Optional[WriteConnectionSecretToRef], Field(alias="writeConnectionSecretToRef")
    ] = None
    """
    WriteConnectionSecretToReference specifies the namespace and name of a
    Secret to which any connection details for this managed resource should
    be written. Connection details frequently include the endpoint, username,
    and password required to connect to the managed resource.
    This field is planned to be replaced in a future release in favor of
    PublishConnectionDetailsTo. Currently, both could be set independently
    and connection details would be published to both without affecting
    each other.
    """


class AlertModel3(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AlertModel3"]:
            return AlertModel3

        def build(self) -> "AlertModel3":
            return AlertModel3(**self._attrs)

        def disabled(self, value: Optional[bool], /) -> Self:
            """
            Determines whether or not the alert is disabled (default: false).
            """
            return self._set("disabled", value)

        def rule(self, value: Optional[str], /) -> Self:
            """
            The type of the alert to configure. Top-level app alert policies can be: DEPLOYMENT_CANCELLED, DEPLOYMENT_FAILED, DEPLOYMENT_LIVE, DEPLOYMENT_STARTED, DOMAIN_FAILED, or DOMAIN_LIVE.
            """
            return self._set("rule", value)

    class BuilderContext(BuilderContextBase["AlertModel3.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AlertModel3.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AlertModel3."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AlertModel3", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AlertModel3.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    disabled: Optional[bool] = None
    """
    Determines whether or not the alert is disabled (default: false).
    """
    rule: Optional[str] = None
    """
    The type of the alert to configure. Top-level app alert policies can be: DEPLOYMENT_CANCELLED, DEPLOYMENT_FAILED, DEPLOYMENT_LIVE, DEPLOYMENT_STARTED, DOMAIN_FAILED, or DOMAIN_LIVE.
    """


class EnvModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["EnvModel"]:
            return EnvModel

        def build(self) -> "EnvModel":
            return EnvModel(**self._attrs)

        def key(self, value: Optional[str], /) -> Self:
            """
            The name of the environment variable.
            The name of the environment variable.
            """
            return self._set("key", value)

        def scope(self, value: Optional[str], /) -> Self:
            """
            The visibility scope of the environment variable. One of RUN_TIME, BUILD_TIME, or RUN_AND_BUILD_TIME (default).
            The visibility scope of the environment variable.
            """
            return self._set("scope", value)

        def type(self, value: Optional[str], /) -> Self:
            """
            The domain type, which can be one of the following:
            The type of the environment variable.
            """
            return self._set("type", value)

    class BuilderContext(BuilderContextBase["EnvModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = EnvModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for EnvModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["EnvModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use EnvModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: Optional[str] = None
    """
    The name of the environment variable.
    The name of the environment variable.
    """
    scope: Optional[str] = None
    """
    The visibility scope of the environment variable. One of RUN_TIME, BUILD_TIME, or RUN_AND_BUILD_TIME (default).
    The visibility scope of the environment variable.
    """
    type: Optional[str] = None
    """
    The domain type, which can be one of the following:
    The type of the environment variable.
    """


class AlertModel4(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AlertModel4"]:
            return AlertModel4

        def build(self) -> "AlertModel4":
            return AlertModel4(**self._attrs)

        def disabled(self, value: Optional[bool], /) -> Self:
            """
            Determines whether or not the alert is disabled (default: false).
            """
            return self._set("disabled", value)

        def operator(self, value: Optional[str], /) -> Self:
            """
            The operator to use. This is either of GREATER_THAN or LESS_THAN.
            """
            return self._set("operator", value)

        def rule(self, value: Optional[str], /) -> Self:
            """
            The type of the alert to configure. Top-level app alert policies can be: DEPLOYMENT_CANCELLED, DEPLOYMENT_FAILED, DEPLOYMENT_LIVE, DEPLOYMENT_STARTED, DOMAIN_FAILED, or DOMAIN_LIVE.
            """
            return self._set("rule", value)

        def value(self, value: Optional[float], /) -> Self:
            """
            The value of the environment variable.
            """
            return self._set("value", value)

        def window(self, value: Optional[str], /) -> Self:
            """
            The time before alerts should be triggered. This is may be one of: FIVE_MINUTES, TEN_MINUTES, THIRTY_MINUTES, ONE_HOUR.
            """
            return self._set("window", value)

    class BuilderContext(BuilderContextBase["AlertModel4.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AlertModel4.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AlertModel4."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AlertModel4", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AlertModel4.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    disabled: Optional[bool] = None
    """
    Determines whether or not the alert is disabled (default: false).
    """
    operator: Optional[str] = None
    """
    The operator to use. This is either of GREATER_THAN or LESS_THAN.
    """
    rule: Optional[str] = None
    """
    The type of the alert to configure. Top-level app alert policies can be: DEPLOYMENT_CANCELLED, DEPLOYMENT_FAILED, DEPLOYMENT_LIVE, DEPLOYMENT_STARTED, DOMAIN_FAILED, or DOMAIN_LIVE.
    """
    value: Optional[float] = None
    """
    The value of the environment variable.
    """
    window: Optional[str] = None
    """
    The time before alerts should be triggered. This is may be one of: FIVE_MINUTES, TEN_MINUTES, THIRTY_MINUTES, ONE_HOUR.
    """


class BasicAuthModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["BasicAuthModel"]:
            return BasicAuthModel

        def build(self) -> "BasicAuthModel":
            return BasicAuthModel(**self._attrs)

        def user(self, value: Optional[str], /) -> Self:
            """
            Username to authenticate with. Only required when endpoint is set. Defaults to doadmin when cluster_name is set.
            user for basic authentication.
            """
            return self._set("user", value)

    class BuilderContext(BuilderContextBase["BasicAuthModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = BasicAuthModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for BasicAuthModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["BasicAuthModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use BasicAuthModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    user: Optional[str] = None
    """
    Username to authenticate with. Only required when endpoint is set. Defaults to doadmin when cluster_name is set.
    user for basic authentication.
    """


class ImageModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ImageModel"]:
            return ImageModel

        def build(self) -> "ImageModel":
            return ImageModel(**self._attrs)

        @overload
        def deploy_on_push(
            self, value_or_callback: List[DeployOnPush], /
        ) -> "ImageModel.Builder": ...

        @overload
        def deploy_on_push(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[DeployOnPush, DeployOnPush.Builder]],
                GenericListBuilder[DeployOnPush, DeployOnPush.Builder] | List[DeployOnPush],
            ],
            /,
        ) -> "ImageModel.Builder": ...

        @overload
        def deploy_on_push(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[DeployOnPush.Builder]: ...

        def deploy_on_push(self, value_or_callback=None, /):
            """
            Whether to automatically deploy new commits made to the repo.
            Configures automatically deploying images pushed to DOCR.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[DeployOnPush.Builder]()
                context._parent_builder = self
                context._field_name = "deploy_on_push"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(DeployOnPush.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("deploy_on_push", value)

        def registry(self, value: Optional[str], /) -> Self:
            """
            The registry name. Must be left empty for the DOCR registry type. Required for the DOCKER_HUB registry type.
            The registry name. Must be left empty for the DOCR registry type.
            """
            return self._set("registry", value)

        def registry_type(self, value: Optional[str], /) -> Self:
            """
            The registry type. One of DOCR (DigitalOcean container registry) or DOCKER_HUB.
            The registry type.
            """
            return self._set("registry_type", value)

        def repository(self, value: Optional[str], /) -> Self:
            """
            The repository name.
            The repository name.
            """
            return self._set("repository", value)

        def tag(self, value: Optional[str], /) -> Self:
            """
            The repository tag. Defaults to latest if not provided.
            The repository tag. Defaults to latest if not provided.
            """
            return self._set("tag", value)

    class BuilderContext(BuilderContextBase["ImageModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ImageModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ImageModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ImageModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ImageModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    deploy_on_push: Annotated[Optional[List[DeployOnPush]], Field(alias="deployOnPush")] = None
    """
    Whether to automatically deploy new commits made to the repo.
    Configures automatically deploying images pushed to DOCR.
    """
    registry: Optional[str] = None
    """
    The registry name. Must be left empty for the DOCR registry type. Required for the DOCKER_HUB registry type.
    The registry name. Must be left empty for the DOCR registry type.
    """
    registry_type: Annotated[Optional[str], Field(alias="registryType")] = None
    """
    The registry type. One of DOCR (DigitalOcean container registry) or DOCKER_HUB.
    The registry type.
    """
    repository: Optional[str] = None
    """
    The repository name.
    The repository name.
    """
    tag: Optional[str] = None
    """
    The repository tag. Defaults to latest if not provided.
    The repository tag. Defaults to latest if not provided.
    """


class AtProvider(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AtProvider"]:
            return AtProvider

        def build(self) -> "AtProvider":
            return AtProvider(**self._attrs)

        def active_deployment_id(self, value: Optional[str], /) -> Self:
            """
            The ID the app's currently active deployment.
            The ID the App's currently active deployment
            """
            return self._set("active_deployment_id", value)

        def created_at(self, value: Optional[str], /) -> Self:
            """
            The date and time of when the app was created.
            The date and time of when the App was created
            """
            return self._set("created_at", value)

        @overload
        def dedicated_ips(
            self, value_or_callback: List[DedicatedIp], /
        ) -> "AtProvider.Builder": ...

        @overload
        def dedicated_ips(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[DedicatedIp, DedicatedIp.Builder]],
                GenericListBuilder[DedicatedIp, DedicatedIp.Builder] | List[DedicatedIp],
            ],
            /,
        ) -> "AtProvider.Builder": ...

        @overload
        def dedicated_ips(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[DedicatedIp.Builder]: ...

        def dedicated_ips(self, value_or_callback=None, /):
            """
            The dedicated egress IP addresses associated with the app.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[DedicatedIp.Builder]()
                context._parent_builder = self
                context._field_name = "dedicated_ips"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(DedicatedIp.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("dedicated_ips", value)

        def default_ingress(self, value: Optional[str], /) -> Self:
            """
            The default URL to access the app.
            The default URL to access the App
            """
            return self._set("default_ingress", value)

        def id(self, value: Optional[str], /) -> Self:
            """
            The ID of the app.
            """
            return self._set("id", value)

        def live_domain(self, value: Optional[str], /) -> Self:
            """
            The live domain of the app.
            """
            return self._set("live_domain", value)

        def live_url(self, value: Optional[str], /) -> Self:
            """
            The live URL of the app.
            """
            return self._set("live_url", value)

        def project_id(self, value: Optional[str], /) -> Self:
            """
            The ID of the project that the app is assigned to.
            """
            return self._set("project_id", value)

        @overload
        def spec(self, value_or_callback: List[Spec], /) -> "AtProvider.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Spec, Spec.Builder]],
                GenericListBuilder[Spec, Spec.Builder] | List[Spec],
            ],
            /,
        ) -> "AtProvider.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> ListBuilderContext[Spec.Builder]: ...

        def spec(self, value_or_callback=None, /):
            """
            A DigitalOcean App spec describing the app.
            A DigitalOcean App Platform Spec
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Spec.Builder]()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Spec.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        def updated_at(self, value: Optional[str], /) -> Self:
            """
            The date and time of when the app was last updated.
            The date and time of when the App was last updated
            """
            return self._set("updated_at", value)

        def urn(self, value: Optional[str], /) -> Self:
            """
            The uniform resource identifier for the app.
            The uniform resource identifier for the app
            """
            return self._set("urn", value)

    class BuilderContext(BuilderContextBase["AtProvider.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AtProvider.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AtProvider."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AtProvider", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AtProvider.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    active_deployment_id: Annotated[Optional[str], Field(alias="activeDeploymentId")] = None
    """
    The ID the app's currently active deployment.
    The ID the App's currently active deployment
    """
    created_at: Annotated[Optional[str], Field(alias="createdAt")] = None
    """
    The date and time of when the app was created.
    The date and time of when the App was created
    """
    dedicated_ips: Annotated[Optional[List[DedicatedIp]], Field(alias="dedicatedIps")] = None
    """
    The dedicated egress IP addresses associated with the app.
    """
    default_ingress: Annotated[Optional[str], Field(alias="defaultIngress")] = None
    """
    The default URL to access the app.
    The default URL to access the App
    """
    id: Optional[str] = None
    """
    The ID of the app.
    """
    live_domain: Annotated[Optional[str], Field(alias="liveDomain")] = None
    """
    The live domain of the app.
    """
    live_url: Annotated[Optional[str], Field(alias="liveUrl")] = None
    """
    The live URL of the app.
    """
    project_id: Annotated[Optional[str], Field(alias="projectId")] = None
    """
    The ID of the project that the app is assigned to.
    """
    spec: Optional[List[Spec]] = None
    """
    A DigitalOcean App spec describing the app.
    A DigitalOcean App Platform Spec
    """
    updated_at: Annotated[Optional[str], Field(alias="updatedAt")] = None
    """
    The date and time of when the app was last updated.
    The date and time of when the App was last updated
    """
    urn: Optional[str] = None
    """
    The uniform resource identifier for the app.
    The uniform resource identifier for the app
    """


class Condition(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Condition"]:
            return Condition

        def build(self) -> "Condition":
            return Condition(**self._attrs)

        def last_transition_time(self, value: AwareDatetime, /) -> Self:
            """
            LastTransitionTime is the last time this condition transitioned from one
            status to another.
            """
            return self._set("last_transition_time", value)

        def message(self, value: Optional[str], /) -> Self:
            """
            A Message containing details about this condition's last transition from
            one status to another, if any.
            """
            return self._set("message", value)

        def observed_generation(self, value: Optional[int], /) -> Self:
            """
            ObservedGeneration represents the .metadata.generation that the condition was set based upon.
            For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
            with respect to the current state of the instance.
            """
            return self._set("observed_generation", value)

        def reason(self, value: str, /) -> Self:
            """
            A Reason for this condition's last transition from one status to another.
            """
            return self._set("reason", value)

        def status(self, value: str, /) -> Self:
            """
            Status of this condition; is it currently True, False, or Unknown?
            """
            return self._set("status", value)

        def type(self, value: str, /) -> Self:
            """
            Type of this condition. At most one of each condition type may apply to
            a resource at any point in time.
            """
            return self._set("type", value)

    class BuilderContext(BuilderContextBase["Condition.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Condition.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Condition."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Condition", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Condition.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    last_transition_time: Annotated[AwareDatetime, Field(alias="lastTransitionTime")]
    """
    LastTransitionTime is the last time this condition transitioned from one
    status to another.
    """
    message: Optional[str] = None
    """
    A Message containing details about this condition's last transition from
    one status to another, if any.
    """
    observed_generation: Annotated[Optional[int], Field(alias="observedGeneration")] = None
    """
    ObservedGeneration represents the .metadata.generation that the condition was set based upon.
    For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
    with respect to the current state of the instance.
    """
    reason: str
    """
    A Reason for this condition's last transition from one status to another.
    """
    status: str
    """
    Status of this condition; is it currently True, False, or Unknown?
    """
    type: str
    """
    Type of this condition. At most one of each condition type may apply to
    a resource at any point in time.
    """


class AppStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AppStatus"]:
            return AppStatus

        def build(self) -> "AppStatus":
            return AppStatus(**self._attrs)

        @overload
        def at_provider(
            self, value_or_callback: Optional[AtProvider], /
        ) -> "AppStatus.Builder": ...

        @overload
        def at_provider(
            self,
            value_or_callback: Callable[[AtProvider.Builder], AtProvider.Builder | AtProvider],
            /,
        ) -> "AppStatus.Builder": ...

        @overload
        def at_provider(self, value_or_callback: Never = ...) -> "AtProvider.BuilderContext": ...

        def at_provider(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = AtProvider.BuilderContext()
                context._parent_builder = self
                context._field_name = "at_provider"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AtProvider.builder())
                if isinstance(output, AtProvider.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("at_provider", value)

        @overload
        def conditions(self, value_or_callback: List[Condition], /) -> "AppStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Condition, Condition.Builder]],
                GenericListBuilder[Condition, Condition.Builder] | List[Condition],
            ],
            /,
        ) -> "AppStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            """
            Conditions of the resource.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        def observed_generation(self, value: Optional[int], /) -> Self:
            """
            ObservedGeneration is the latest metadata.generation
            which resulted in either a ready state, or stalled due to error
            it can not recover from without human intervention.
            """
            return self._set("observed_generation", value)

    class BuilderContext(BuilderContextBase["AppStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AppStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AppStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AppStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AppStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    at_provider: Annotated[Optional[AtProvider], Field(alias="atProvider")] = None
    conditions: Optional[List[Condition]] = None
    """
    Conditions of the resource.
    """
    observed_generation: Annotated[Optional[int], Field(alias="observedGeneration")] = None
    """
    ObservedGeneration is the latest metadata.generation
    which resulted in either a ready state, or stalled due to error
    it can not recover from without human intervention.
    """


class ForProviderModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ForProviderModel"]:
            return ForProviderModel

        def build(self) -> "ForProviderModel":
            return ForProviderModel(**self._attrs)

        def name(self, value: Optional[str], /) -> Self:
            """
            The name of the tag
            """
            return self._set("name", value)

    class BuilderContext(BuilderContextBase["ForProviderModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ForProviderModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ForProviderModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ForProviderModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ForProviderModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: Optional[str] = None
    """
    The name of the tag
    """


class InitProviderModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["InitProviderModel"]:
            return InitProviderModel

        def build(self) -> "InitProviderModel":
            return InitProviderModel(**self._attrs)

        def name(self, value: Optional[str], /) -> Self:
            """
            The name of the tag
            """
            return self._set("name", value)

    class BuilderContext(BuilderContextBase["InitProviderModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = InitProviderModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for InitProviderModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["InitProviderModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use InitProviderModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: Optional[str] = None
    """
    The name of the tag
    """


class TagSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["TagSpec"]:
            return TagSpec

        def build(self) -> "TagSpec":
            return TagSpec(**self._attrs)

        def deletion_policy(self, value: Optional[Literal["Orphan", "Delete"]], /) -> Self:
            """
            DeletionPolicy specifies what will happen to the underlying external
            when this managed resource is deleted - either "Delete" or "Orphan" the
            external resource.
            This field is planned to be deprecated in favor of the ManagementPolicies
            field in a future release. Currently, both could be set independently and
            non-default values would be honored if the feature flag is enabled.
            See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
            """
            return self._set("deletion_policy", value)

        @overload
        def for_provider(self, value_or_callback: ForProviderModel, /) -> "TagSpec.Builder": ...

        @overload
        def for_provider(
            self,
            value_or_callback: Callable[
                [ForProviderModel.Builder], ForProviderModel.Builder | ForProviderModel
            ],
            /,
        ) -> "TagSpec.Builder": ...

        @overload
        def for_provider(
            self, value_or_callback: Never = ...
        ) -> "ForProviderModel.BuilderContext": ...

        def for_provider(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ForProviderModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "for_provider"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ForProviderModel.builder())
                if isinstance(output, ForProviderModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("for_provider", value)

        @overload
        def init_provider(
            self, value_or_callback: Optional[InitProviderModel], /
        ) -> "TagSpec.Builder": ...

        @overload
        def init_provider(
            self,
            value_or_callback: Callable[
                [InitProviderModel.Builder],
                InitProviderModel.Builder | InitProviderModel,
            ],
            /,
        ) -> "TagSpec.Builder": ...

        @overload
        def init_provider(
            self, value_or_callback: Never = ...
        ) -> "InitProviderModel.BuilderContext": ...

        def init_provider(self, value_or_callback=None, /):
            """
            THIS IS A BETA FIELD. It will be honored
            unless the Management Policies feature flag is disabled.
            InitProvider holds the same fields as ForProvider, with the exception
            of Identifier and other resource reference fields. The fields that are
            in InitProvider are merged into ForProvider when the resource is created.
            The same fields are also added to the terraform ignore_changes hook, to
            avoid updating them after creation. This is useful for fields that are
            required on creation, but we do not desire to update them after creation,
            for example because of an external controller is managing them, like an
            autoscaler.
            """
            if self._in_context and value_or_callback is None:
                context = InitProviderModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "init_provider"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(InitProviderModel.builder())
                if isinstance(output, InitProviderModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("init_provider", value)

        def management_policies(
            self,
            value: Optional[
                List[Literal["Observe", "Create", "Update", "Delete", "LateInitialize", "*"]]
            ],
            /,
        ) -> Self:
            """
            THIS IS A BETA FIELD. It is on by default but can be opted out
            through a Crossplane feature flag.
            ManagementPolicies specify the array of actions Crossplane is allowed to
            take on the managed and external resources.
            This field is planned to replace the DeletionPolicy field in a future
            release. Currently, both could be set independently and non-default
            values would be honored if the feature flag is enabled. If both are
            custom, the DeletionPolicy field will be ignored.
            See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
            and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
            """
            return self._set("management_policies", value)

        @overload
        def provider_config_ref(
            self, value_or_callback: Optional[ProviderConfigRef], /
        ) -> "TagSpec.Builder": ...

        @overload
        def provider_config_ref(
            self,
            value_or_callback: Callable[
                [ProviderConfigRef.Builder],
                ProviderConfigRef.Builder | ProviderConfigRef,
            ],
            /,
        ) -> "TagSpec.Builder": ...

        @overload
        def provider_config_ref(
            self, value_or_callback: Never = ...
        ) -> "ProviderConfigRef.BuilderContext": ...

        def provider_config_ref(self, value_or_callback=None, /):
            """
            ProviderConfigReference specifies how the provider that will be used to
            create, observe, update, and delete this managed resource should be
            configured.
            """
            if self._in_context and value_or_callback is None:
                context = ProviderConfigRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "provider_config_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ProviderConfigRef.builder())
                if isinstance(output, ProviderConfigRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("provider_config_ref", value)

        @overload
        def publish_connection_details_to(
            self, value_or_callback: Optional[PublishConnectionDetailsTo], /
        ) -> "TagSpec.Builder": ...

        @overload
        def publish_connection_details_to(
            self,
            value_or_callback: Callable[
                [PublishConnectionDetailsTo.Builder],
                PublishConnectionDetailsTo.Builder | PublishConnectionDetailsTo,
            ],
            /,
        ) -> "TagSpec.Builder": ...

        @overload
        def publish_connection_details_to(
            self, value_or_callback: Never = ...
        ) -> "PublishConnectionDetailsTo.BuilderContext": ...

        def publish_connection_details_to(self, value_or_callback=None, /):
            """
            PublishConnectionDetailsTo specifies the connection secret config which
            contains a name, metadata and a reference to secret store config to
            which any connection details for this managed resource should be written.
            Connection details frequently include the endpoint, username,
            and password required to connect to the managed resource.
            """
            if self._in_context and value_or_callback is None:
                context = PublishConnectionDetailsTo.BuilderContext()
                context._parent_builder = self
                context._field_name = "publish_connection_details_to"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PublishConnectionDetailsTo.builder())
                if isinstance(output, PublishConnectionDetailsTo.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("publish_connection_details_to", value)

        @overload
        def write_connection_secret_to_ref(
            self, value_or_callback: Optional[WriteConnectionSecretToRef], /
        ) -> "TagSpec.Builder": ...

        @overload
        def write_connection_secret_to_ref(
            self,
            value_or_callback: Callable[
                [WriteConnectionSecretToRef.Builder],
                WriteConnectionSecretToRef.Builder | WriteConnectionSecretToRef,
            ],
            /,
        ) -> "TagSpec.Builder": ...

        @overload
        def write_connection_secret_to_ref(
            self, value_or_callback: Never = ...
        ) -> "WriteConnectionSecretToRef.BuilderContext": ...

        def write_connection_secret_to_ref(self, value_or_callback=None, /):
            """
            WriteConnectionSecretToReference specifies the namespace and name of a
            Secret to which any connection details for this managed resource should
            be written. Connection details frequently include the endpoint, username,
            and password required to connect to the managed resource.
            This field is planned to be replaced in a future release in favor of
            PublishConnectionDetailsTo. Currently, both could be set independently
            and connection details would be published to both without affecting
            each other.
            """
            if self._in_context and value_or_callback is None:
                context = WriteConnectionSecretToRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "write_connection_secret_to_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(WriteConnectionSecretToRef.builder())
                if isinstance(output, WriteConnectionSecretToRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("write_connection_secret_to_ref", value)

    class BuilderContext(BuilderContextBase["TagSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = TagSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for TagSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["TagSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use TagSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    deletion_policy: Annotated[
        Optional[Literal["Orphan", "Delete"]], Field(alias="deletionPolicy")
    ] = "Delete"
    """
    DeletionPolicy specifies what will happen to the underlying external
    when this managed resource is deleted - either "Delete" or "Orphan" the
    external resource.
    This field is planned to be deprecated in favor of the ManagementPolicies
    field in a future release. Currently, both could be set independently and
    non-default values would be honored if the feature flag is enabled.
    See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    """
    for_provider: Annotated[ForProviderModel, Field(alias="forProvider")]
    init_provider: Annotated[Optional[InitProviderModel], Field(alias="initProvider")] = None
    """
    THIS IS A BETA FIELD. It will be honored
    unless the Management Policies feature flag is disabled.
    InitProvider holds the same fields as ForProvider, with the exception
    of Identifier and other resource reference fields. The fields that are
    in InitProvider are merged into ForProvider when the resource is created.
    The same fields are also added to the terraform ignore_changes hook, to
    avoid updating them after creation. This is useful for fields that are
    required on creation, but we do not desire to update them after creation,
    for example because of an external controller is managing them, like an
    autoscaler.
    """
    management_policies: Annotated[
        Optional[List[Literal["Observe", "Create", "Update", "Delete", "LateInitialize", "*"]]],
        Field(alias="managementPolicies"),
    ] = ["*"]
    """
    THIS IS A BETA FIELD. It is on by default but can be opted out
    through a Crossplane feature flag.
    ManagementPolicies specify the array of actions Crossplane is allowed to
    take on the managed and external resources.
    This field is planned to replace the DeletionPolicy field in a future
    release. Currently, both could be set independently and non-default
    values would be honored if the feature flag is enabled. If both are
    custom, the DeletionPolicy field will be ignored.
    See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
    """
    provider_config_ref: Annotated[
        Optional[ProviderConfigRef],
        Field(
            default_factory=lambda: ProviderConfigRef.model_validate({"name": "default"}),
            alias="providerConfigRef",
        ),
    ] = {"name": "default"}
    """
    ProviderConfigReference specifies how the provider that will be used to
    create, observe, update, and delete this managed resource should be
    configured.
    """
    publish_connection_details_to: Annotated[
        Optional[PublishConnectionDetailsTo], Field(alias="publishConnectionDetailsTo")
    ] = None
    """
    PublishConnectionDetailsTo specifies the connection secret config which
    contains a name, metadata and a reference to secret store config to
    which any connection details for this managed resource should be written.
    Connection details frequently include the endpoint, username,
    and password required to connect to the managed resource.
    """
    write_connection_secret_to_ref: Annotated[
        Optional[WriteConnectionSecretToRef], Field(alias="writeConnectionSecretToRef")
    ] = None
    """
    WriteConnectionSecretToReference specifies the namespace and name of a
    Secret to which any connection details for this managed resource should
    be written. Connection details frequently include the endpoint, username,
    and password required to connect to the managed resource.
    This field is planned to be replaced in a future release in favor of
    PublishConnectionDetailsTo. Currently, both could be set independently
    and connection details would be published to both without affecting
    each other.
    """


class AtProviderModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AtProviderModel"]:
            return AtProviderModel

        def build(self) -> "AtProviderModel":
            return AtProviderModel(**self._attrs)

        def databases_count(self, value: Optional[float], /) -> Self:
            """
            A count of the database clusters that the tag is applied to.
            """
            return self._set("databases_count", value)

        def droplets_count(self, value: Optional[float], /) -> Self:
            """
            A count of the Droplets the tag is applied to.
            """
            return self._set("droplets_count", value)

        def id(self, value: Optional[str], /) -> Self:
            """
            The id of the tag
            """
            return self._set("id", value)

        def images_count(self, value: Optional[float], /) -> Self:
            """
            A count of the images that the tag is applied to.
            """
            return self._set("images_count", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            The name of the tag
            """
            return self._set("name", value)

        def total_resource_count(self, value: Optional[float], /) -> Self:
            """
            A count of the total number of resources that the tag is applied to.
            """
            return self._set("total_resource_count", value)

        def volume_snapshots_count(self, value: Optional[float], /) -> Self:
            """
            A count of the volume snapshots that the tag is applied to.
            """
            return self._set("volume_snapshots_count", value)

        def volumes_count(self, value: Optional[float], /) -> Self:
            """
            A count of the volumes that the tag is applied to.
            """
            return self._set("volumes_count", value)

    class BuilderContext(BuilderContextBase["AtProviderModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AtProviderModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AtProviderModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AtProviderModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AtProviderModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    databases_count: Annotated[Optional[float], Field(alias="databasesCount")] = None
    """
    A count of the database clusters that the tag is applied to.
    """
    droplets_count: Annotated[Optional[float], Field(alias="dropletsCount")] = None
    """
    A count of the Droplets the tag is applied to.
    """
    id: Optional[str] = None
    """
    The id of the tag
    """
    images_count: Annotated[Optional[float], Field(alias="imagesCount")] = None
    """
    A count of the images that the tag is applied to.
    """
    name: Optional[str] = None
    """
    The name of the tag
    """
    total_resource_count: Annotated[Optional[float], Field(alias="totalResourceCount")] = None
    """
    A count of the total number of resources that the tag is applied to.
    """
    volume_snapshots_count: Annotated[Optional[float], Field(alias="volumeSnapshotsCount")] = None
    """
    A count of the volume snapshots that the tag is applied to.
    """
    volumes_count: Annotated[Optional[float], Field(alias="volumesCount")] = None
    """
    A count of the volumes that the tag is applied to.
    """


class TagStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["TagStatus"]:
            return TagStatus

        def build(self) -> "TagStatus":
            return TagStatus(**self._attrs)

        @overload
        def at_provider(
            self, value_or_callback: Optional[AtProviderModel], /
        ) -> "TagStatus.Builder": ...

        @overload
        def at_provider(
            self,
            value_or_callback: Callable[
                [AtProviderModel.Builder], AtProviderModel.Builder | AtProviderModel
            ],
            /,
        ) -> "TagStatus.Builder": ...

        @overload
        def at_provider(
            self, value_or_callback: Never = ...
        ) -> "AtProviderModel.BuilderContext": ...

        def at_provider(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = AtProviderModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "at_provider"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AtProviderModel.builder())
                if isinstance(output, AtProviderModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("at_provider", value)

        @overload
        def conditions(self, value_or_callback: List[Condition], /) -> "TagStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Condition, Condition.Builder]],
                GenericListBuilder[Condition, Condition.Builder] | List[Condition],
            ],
            /,
        ) -> "TagStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            """
            Conditions of the resource.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        def observed_generation(self, value: Optional[int], /) -> Self:
            """
            ObservedGeneration is the latest metadata.generation
            which resulted in either a ready state, or stalled due to error
            it can not recover from without human intervention.
            """
            return self._set("observed_generation", value)

    class BuilderContext(BuilderContextBase["TagStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = TagStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for TagStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["TagStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use TagStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    at_provider: Annotated[Optional[AtProviderModel], Field(alias="atProvider")] = None
    conditions: Optional[List[Condition]] = None
    """
    Conditions of the resource.
    """
    observed_generation: Annotated[Optional[int], Field(alias="observedGeneration")] = None
    """
    ObservedGeneration is the latest metadata.generation
    which resulted in either a ready state, or stalled due to error
    it can not recover from without human intervention.
    """


class App(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["App"]:
            return App

        def build(self) -> "App":
            return App(**self._attrs)

        def api_version(
            self,
            value: Optional[Literal["digitalocean.digitalocean.crossplane.io/v1alpha1"]],
            /,
        ) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["App"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "App.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "App.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(self, value_or_callback: AppSpec, /) -> "App.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[[AppSpec.Builder], AppSpec.Builder | AppSpec],
            /,
        ) -> "App.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "AppSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = AppSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AppSpec.builder())
                if isinstance(output, AppSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(self, value_or_callback: Optional[AppStatus], /) -> "App.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[[AppStatus.Builder], AppStatus.Builder | AppStatus],
            /,
        ) -> "App.Builder": ...

        @overload
        def status(self, value_or_callback: Never = ...) -> "AppStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = AppStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AppStatus.builder())
                if isinstance(output, AppStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["App.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = App.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for App."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["App", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use App.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[
        Optional[Literal["digitalocean.digitalocean.crossplane.io/v1alpha1"]],
        Field(alias="apiVersion"),
    ] = "digitalocean.digitalocean.crossplane.io/v1alpha1"
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["App"]] = "App"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: AppSpec
    status: Optional[AppStatus] = None


class Tag(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Tag"]:
            return Tag

        def build(self) -> "Tag":
            return Tag(**self._attrs)

        def api_version(
            self,
            value: Optional[Literal["digitalocean.digitalocean.crossplane.io/v1alpha1"]],
            /,
        ) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["Tag"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "Tag.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "Tag.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(self, value_or_callback: TagSpec, /) -> "Tag.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[[TagSpec.Builder], TagSpec.Builder | TagSpec],
            /,
        ) -> "Tag.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "TagSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = TagSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(TagSpec.builder())
                if isinstance(output, TagSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(self, value_or_callback: Optional[TagStatus], /) -> "Tag.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[[TagStatus.Builder], TagStatus.Builder | TagStatus],
            /,
        ) -> "Tag.Builder": ...

        @overload
        def status(self, value_or_callback: Never = ...) -> "TagStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = TagStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(TagStatus.builder())
                if isinstance(output, TagStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["Tag.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Tag.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Tag."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Tag", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Tag.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[
        Optional[Literal["digitalocean.digitalocean.crossplane.io/v1alpha1"]],
        Field(alias="apiVersion"),
    ] = "digitalocean.digitalocean.crossplane.io/v1alpha1"
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["Tag"]] = "Tag"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: TagSpec
    status: Optional[TagStatus] = None
