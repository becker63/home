# Generated by cloudcoil-model-codegen v0.5.8
# DO NOT EDIT


from __future__ import annotations

from typing import (
    Annotated,
    Callable,
    Dict,
    List,
    Literal,
    Optional,
    Type,
    overload,
)

from cloudcoil import apimachinery
from cloudcoil.pydantic import (
    BaseModel,
    BaseModelBuilder,
    BuilderContextBase,
    GenericListBuilder,
    ListBuilderContext,
    Never,
    Self,
)
from cloudcoil.resources import Resource
from pydantic import AwareDatetime, Field


class BackupRestore(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["BackupRestore"]:
            return BackupRestore

        def build(self) -> "BackupRestore":
            return BackupRestore(**self._attrs)

        def backup_created_at(self, value: Optional[str], /) -> Self:
            """
            The timestamp of an existing database cluster backup in ISO8601 combined date and time format. The most recent backup will be used if excluded.
            """
            return self._set("backup_created_at", value)

        def database_name(self, value: Optional[str], /) -> Self:
            """
            The name of an existing database cluster from which the backup will be restored.
            """
            return self._set("database_name", value)

    class BuilderContext(BuilderContextBase["BackupRestore.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = BackupRestore.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for BackupRestore."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["BackupRestore", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use BackupRestore.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    backup_created_at: Annotated[Optional[str], Field(alias="backupCreatedAt")] = None
    """
    The timestamp of an existing database cluster backup in ISO8601 combined date and time format. The most recent backup will be used if excluded.
    """
    database_name: Annotated[Optional[str], Field(alias="databaseName")] = None
    """
    The name of an existing database cluster from which the backup will be restored.
    """


class MaintenanceWindow(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["MaintenanceWindow"]:
            return MaintenanceWindow

        def build(self) -> "MaintenanceWindow":
            return MaintenanceWindow(**self._attrs)

        def day(self, value: Optional[str], /) -> Self:
            """
            The day of the week on which to apply maintenance updates.
            """
            return self._set("day", value)

        def hour(self, value: Optional[str], /) -> Self:
            """
            The hour in UTC at which maintenance updates will be applied in 24 hour format.
            """
            return self._set("hour", value)

    class BuilderContext(BuilderContextBase["MaintenanceWindow.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = MaintenanceWindow.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for MaintenanceWindow."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["MaintenanceWindow", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use MaintenanceWindow.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    day: Optional[str] = None
    """
    The day of the week on which to apply maintenance updates.
    """
    hour: Optional[str] = None
    """
    The hour in UTC at which maintenance updates will be applied in 24 hour format.
    """


class Policy(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Policy"]:
            return Policy

        def build(self) -> "Policy":
            return Policy(**self._attrs)

        def resolution(self, value: Optional[Literal["Required", "Optional"]], /) -> Self:
            """
            Resolution specifies whether resolution of this reference is required.
            The default is 'Required', which means the reconcile will fail if the
            reference cannot be resolved. 'Optional' means this reference will be
            a no-op if it cannot be resolved.
            """
            return self._set("resolution", value)

        def resolve(self, value: Optional[Literal["Always", "IfNotPresent"]], /) -> Self:
            """
            Resolve specifies when this reference should be resolved. The default
            is 'IfNotPresent', which will attempt to resolve the reference only when
            the corresponding field is not present. Use 'Always' to resolve the
            reference on every reconcile.
            """
            return self._set("resolve", value)

    class BuilderContext(BuilderContextBase["Policy.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Policy.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Policy."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Policy", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Policy.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    resolution: Optional[Literal["Required", "Optional"]] = "Required"
    """
    Resolution specifies whether resolution of this reference is required.
    The default is 'Required', which means the reconcile will fail if the
    reference cannot be resolved. 'Optional' means this reference will be
    a no-op if it cannot be resolved.
    """
    resolve: Optional[Literal["Always", "IfNotPresent"]] = None
    """
    Resolve specifies when this reference should be resolved. The default
    is 'IfNotPresent', which will attempt to resolve the reference only when
    the corresponding field is not present. Use 'Always' to resolve the
    reference on every reconcile.
    """


class PrivateNetworkUuidRef(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PrivateNetworkUuidRef"]:
            return PrivateNetworkUuidRef

        def build(self) -> "PrivateNetworkUuidRef":
            return PrivateNetworkUuidRef(**self._attrs)

        def name(self, value: str, /) -> Self:
            """
            Name of the referenced object.
            """
            return self._set("name", value)

        @overload
        def policy(
            self, value_or_callback: Optional[Policy], /
        ) -> "PrivateNetworkUuidRef.Builder": ...

        @overload
        def policy(
            self,
            value_or_callback: Callable[[Policy.Builder], Policy.Builder | Policy],
            /,
        ) -> "PrivateNetworkUuidRef.Builder": ...

        @overload
        def policy(self, value_or_callback: Never = ...) -> "Policy.BuilderContext": ...

        def policy(self, value_or_callback=None, /):
            """
            Policies for referencing.
            """
            if self._in_context and value_or_callback is None:
                context = Policy.BuilderContext()
                context._parent_builder = self
                context._field_name = "policy"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Policy.builder())
                if isinstance(output, Policy.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("policy", value)

    class BuilderContext(BuilderContextBase["PrivateNetworkUuidRef.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PrivateNetworkUuidRef.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PrivateNetworkUuidRef."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["PrivateNetworkUuidRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PrivateNetworkUuidRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: str
    """
    Name of the referenced object.
    """
    policy: Optional[Policy] = None
    """
    Policies for referencing.
    """


class PrivateNetworkUuidSelector(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PrivateNetworkUuidSelector"]:
            return PrivateNetworkUuidSelector

        def build(self) -> "PrivateNetworkUuidSelector":
            return PrivateNetworkUuidSelector(**self._attrs)

        def match_controller_ref(self, value: Optional[bool], /) -> Self:
            """
            MatchControllerRef ensures an object with the same controller reference
            as the selecting object is selected.
            """
            return self._set("match_controller_ref", value)

        def match_labels(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            MatchLabels ensures an object with matching labels is selected.
            """
            return self._set("match_labels", value)

        @overload
        def policy(
            self, value_or_callback: Optional[Policy], /
        ) -> "PrivateNetworkUuidSelector.Builder": ...

        @overload
        def policy(
            self,
            value_or_callback: Callable[[Policy.Builder], Policy.Builder | Policy],
            /,
        ) -> "PrivateNetworkUuidSelector.Builder": ...

        @overload
        def policy(self, value_or_callback: Never = ...) -> "Policy.BuilderContext": ...

        def policy(self, value_or_callback=None, /):
            """
            Policies for selection.
            """
            if self._in_context and value_or_callback is None:
                context = Policy.BuilderContext()
                context._parent_builder = self
                context._field_name = "policy"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Policy.builder())
                if isinstance(output, Policy.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("policy", value)

    class BuilderContext(BuilderContextBase["PrivateNetworkUuidSelector.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PrivateNetworkUuidSelector.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PrivateNetworkUuidSelector."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["PrivateNetworkUuidSelector", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PrivateNetworkUuidSelector.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    match_controller_ref: Annotated[Optional[bool], Field(alias="matchControllerRef")] = None
    """
    MatchControllerRef ensures an object with the same controller reference
    as the selecting object is selected.
    """
    match_labels: Annotated[Optional[Dict[str, str]], Field(alias="matchLabels")] = None
    """
    MatchLabels ensures an object with matching labels is selected.
    """
    policy: Optional[Policy] = None
    """
    Policies for selection.
    """


class ProjectIdRef(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ProjectIdRef"]:
            return ProjectIdRef

        def build(self) -> "ProjectIdRef":
            return ProjectIdRef(**self._attrs)

        def name(self, value: str, /) -> Self:
            """
            Name of the referenced object.
            """
            return self._set("name", value)

        @overload
        def policy(self, value_or_callback: Optional[Policy], /) -> "ProjectIdRef.Builder": ...

        @overload
        def policy(
            self,
            value_or_callback: Callable[[Policy.Builder], Policy.Builder | Policy],
            /,
        ) -> "ProjectIdRef.Builder": ...

        @overload
        def policy(self, value_or_callback: Never = ...) -> "Policy.BuilderContext": ...

        def policy(self, value_or_callback=None, /):
            """
            Policies for referencing.
            """
            if self._in_context and value_or_callback is None:
                context = Policy.BuilderContext()
                context._parent_builder = self
                context._field_name = "policy"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Policy.builder())
                if isinstance(output, Policy.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("policy", value)

    class BuilderContext(BuilderContextBase["ProjectIdRef.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ProjectIdRef.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ProjectIdRef."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ProjectIdRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ProjectIdRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: str
    """
    Name of the referenced object.
    """
    policy: Optional[Policy] = None
    """
    Policies for referencing.
    """


class ProjectIdSelector(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ProjectIdSelector"]:
            return ProjectIdSelector

        def build(self) -> "ProjectIdSelector":
            return ProjectIdSelector(**self._attrs)

        def match_controller_ref(self, value: Optional[bool], /) -> Self:
            """
            MatchControllerRef ensures an object with the same controller reference
            as the selecting object is selected.
            """
            return self._set("match_controller_ref", value)

        def match_labels(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            MatchLabels ensures an object with matching labels is selected.
            """
            return self._set("match_labels", value)

        @overload
        def policy(self, value_or_callback: Optional[Policy], /) -> "ProjectIdSelector.Builder": ...

        @overload
        def policy(
            self,
            value_or_callback: Callable[[Policy.Builder], Policy.Builder | Policy],
            /,
        ) -> "ProjectIdSelector.Builder": ...

        @overload
        def policy(self, value_or_callback: Never = ...) -> "Policy.BuilderContext": ...

        def policy(self, value_or_callback=None, /):
            """
            Policies for selection.
            """
            if self._in_context and value_or_callback is None:
                context = Policy.BuilderContext()
                context._parent_builder = self
                context._field_name = "policy"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Policy.builder())
                if isinstance(output, Policy.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("policy", value)

    class BuilderContext(BuilderContextBase["ProjectIdSelector.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ProjectIdSelector.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ProjectIdSelector."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ProjectIdSelector", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ProjectIdSelector.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    match_controller_ref: Annotated[Optional[bool], Field(alias="matchControllerRef")] = None
    """
    MatchControllerRef ensures an object with the same controller reference
    as the selecting object is selected.
    """
    match_labels: Annotated[Optional[Dict[str, str]], Field(alias="matchLabels")] = None
    """
    MatchLabels ensures an object with matching labels is selected.
    """
    policy: Optional[Policy] = None
    """
    Policies for selection.
    """


class ForProvider(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ForProvider"]:
            return ForProvider

        def build(self) -> "ForProvider":
            return ForProvider(**self._attrs)

        @overload
        def backup_restore(
            self, value_or_callback: List[BackupRestore], /
        ) -> "ForProvider.Builder": ...

        @overload
        def backup_restore(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[BackupRestore, BackupRestore.Builder]],
                GenericListBuilder[BackupRestore, BackupRestore.Builder] | List[BackupRestore],
            ],
            /,
        ) -> "ForProvider.Builder": ...

        @overload
        def backup_restore(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[BackupRestore.Builder]: ...

        def backup_restore(self, value_or_callback=None, /):
            """
            Create a new database cluster based on a backup of an existing cluster.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[BackupRestore.Builder]()
                context._parent_builder = self
                context._field_name = "backup_restore"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(BackupRestore.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("backup_restore", value)

        def engine(self, value: Optional[str], /) -> Self:
            """
            Database engine used by the cluster (ex. pg for PostreSQL, mysql for MySQL, redis for Redis, mongodb for MongoDB, or kafka for Kafka).
            """
            return self._set("engine", value)

        def eviction_policy(self, value: Optional[str], /) -> Self:
            """
            A string specifying the eviction policy for a Redis cluster. Valid values are: noeviction, allkeys_lru, allkeys_random, volatile_lru, volatile_random, or volatile_ttl.
            """
            return self._set("eviction_policy", value)

        @overload
        def maintenance_window(
            self, value_or_callback: List[MaintenanceWindow], /
        ) -> "ForProvider.Builder": ...

        @overload
        def maintenance_window(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[MaintenanceWindow, MaintenanceWindow.Builder]],
                GenericListBuilder[MaintenanceWindow, MaintenanceWindow.Builder]
                | List[MaintenanceWindow],
            ],
            /,
        ) -> "ForProvider.Builder": ...

        @overload
        def maintenance_window(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[MaintenanceWindow.Builder]: ...

        def maintenance_window(self, value_or_callback=None, /):
            """
            Defines when the automatic maintenance should be performed for the database cluster.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[MaintenanceWindow.Builder]()
                context._parent_builder = self
                context._field_name = "maintenance_window"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(MaintenanceWindow.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("maintenance_window", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            The name of the database cluster.
            """
            return self._set("name", value)

        def node_count(self, value: Optional[float], /) -> Self:
            """
            Number of nodes that will be included in the cluster. For kafka clusters, this must be 3.
            """
            return self._set("node_count", value)

        def private_network_uuid(self, value: Optional[str], /) -> Self:
            """
            The ID of the VPC where the database cluster will be located.
            """
            return self._set("private_network_uuid", value)

        @overload
        def private_network_uuid_ref(
            self, value_or_callback: Optional[PrivateNetworkUuidRef], /
        ) -> "ForProvider.Builder": ...

        @overload
        def private_network_uuid_ref(
            self,
            value_or_callback: Callable[
                [PrivateNetworkUuidRef.Builder],
                PrivateNetworkUuidRef.Builder | PrivateNetworkUuidRef,
            ],
            /,
        ) -> "ForProvider.Builder": ...

        @overload
        def private_network_uuid_ref(
            self, value_or_callback: Never = ...
        ) -> "PrivateNetworkUuidRef.BuilderContext": ...

        def private_network_uuid_ref(self, value_or_callback=None, /):
            """
            Reference to a VPC in vpc to populate privateNetworkUuid.
            """
            if self._in_context and value_or_callback is None:
                context = PrivateNetworkUuidRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "private_network_uuid_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PrivateNetworkUuidRef.builder())
                if isinstance(output, PrivateNetworkUuidRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("private_network_uuid_ref", value)

        @overload
        def private_network_uuid_selector(
            self, value_or_callback: Optional[PrivateNetworkUuidSelector], /
        ) -> "ForProvider.Builder": ...

        @overload
        def private_network_uuid_selector(
            self,
            value_or_callback: Callable[
                [PrivateNetworkUuidSelector.Builder],
                PrivateNetworkUuidSelector.Builder | PrivateNetworkUuidSelector,
            ],
            /,
        ) -> "ForProvider.Builder": ...

        @overload
        def private_network_uuid_selector(
            self, value_or_callback: Never = ...
        ) -> "PrivateNetworkUuidSelector.BuilderContext": ...

        def private_network_uuid_selector(self, value_or_callback=None, /):
            """
            Selector for a VPC in vpc to populate privateNetworkUuid.
            """
            if self._in_context and value_or_callback is None:
                context = PrivateNetworkUuidSelector.BuilderContext()
                context._parent_builder = self
                context._field_name = "private_network_uuid_selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PrivateNetworkUuidSelector.builder())
                if isinstance(output, PrivateNetworkUuidSelector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("private_network_uuid_selector", value)

        def project_id(self, value: Optional[str], /) -> Self:
            """
            The ID of the project that the database cluster is assigned to. If excluded when creating a new database cluster, it will be assigned to your default project.
            """
            return self._set("project_id", value)

        @overload
        def project_id_ref(
            self, value_or_callback: Optional[ProjectIdRef], /
        ) -> "ForProvider.Builder": ...

        @overload
        def project_id_ref(
            self,
            value_or_callback: Callable[
                [ProjectIdRef.Builder], ProjectIdRef.Builder | ProjectIdRef
            ],
            /,
        ) -> "ForProvider.Builder": ...

        @overload
        def project_id_ref(
            self, value_or_callback: Never = ...
        ) -> "ProjectIdRef.BuilderContext": ...

        def project_id_ref(self, value_or_callback=None, /):
            """
            Reference to a Project in project to populate projectId.
            """
            if self._in_context and value_or_callback is None:
                context = ProjectIdRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "project_id_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ProjectIdRef.builder())
                if isinstance(output, ProjectIdRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("project_id_ref", value)

        @overload
        def project_id_selector(
            self, value_or_callback: Optional[ProjectIdSelector], /
        ) -> "ForProvider.Builder": ...

        @overload
        def project_id_selector(
            self,
            value_or_callback: Callable[
                [ProjectIdSelector.Builder],
                ProjectIdSelector.Builder | ProjectIdSelector,
            ],
            /,
        ) -> "ForProvider.Builder": ...

        @overload
        def project_id_selector(
            self, value_or_callback: Never = ...
        ) -> "ProjectIdSelector.BuilderContext": ...

        def project_id_selector(self, value_or_callback=None, /):
            """
            Selector for a Project in project to populate projectId.
            """
            if self._in_context and value_or_callback is None:
                context = ProjectIdSelector.BuilderContext()
                context._parent_builder = self
                context._field_name = "project_id_selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ProjectIdSelector.builder())
                if isinstance(output, ProjectIdSelector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("project_id_selector", value)

        def region(self, value: Optional[str], /) -> Self:
            """
            DigitalOcean region where the cluster will reside.
            """
            return self._set("region", value)

        def size(self, value: Optional[str], /) -> Self:
            """
            Database Droplet size associated with the cluster (ex. db-s-1vcpu-1gb). See here for a list of valid size slugs.
            """
            return self._set("size", value)

        def sql_mode(self, value: Optional[str], /) -> Self:
            """
            A comma separated string specifying the  SQL modes for a MySQL cluster.
            """
            return self._set("sql_mode", value)

        def storage_size_mib(self, value: Optional[str], /) -> Self:
            """
            Defines the disk size, in MiB, allocated to the cluster. This can be adjusted on MySQL and PostreSQL clusters based on predefined ranges for each slug/droplet size.
            """
            return self._set("storage_size_mib", value)

        def tags(self, value: Optional[List[str]], /) -> Self:
            """
            A list of tag names to be applied to the database cluster.
            """
            return self._set("tags", value)

        def version(self, value: Optional[str], /) -> Self:
            """
            Engine version used by the cluster (ex. 14 for PostgreSQL 14).
            When this value is changed, a call to the Upgrade major Version for a Database API operation is made with the new version.
            """
            return self._set("version", value)

    class BuilderContext(BuilderContextBase["ForProvider.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ForProvider.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ForProvider."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ForProvider", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ForProvider.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    backup_restore: Annotated[Optional[List[BackupRestore]], Field(alias="backupRestore")] = None
    """
    Create a new database cluster based on a backup of an existing cluster.
    """
    engine: Optional[str] = None
    """
    Database engine used by the cluster (ex. pg for PostreSQL, mysql for MySQL, redis for Redis, mongodb for MongoDB, or kafka for Kafka).
    """
    eviction_policy: Annotated[Optional[str], Field(alias="evictionPolicy")] = None
    """
    A string specifying the eviction policy for a Redis cluster. Valid values are: noeviction, allkeys_lru, allkeys_random, volatile_lru, volatile_random, or volatile_ttl.
    """
    maintenance_window: Annotated[
        Optional[List[MaintenanceWindow]], Field(alias="maintenanceWindow")
    ] = None
    """
    Defines when the automatic maintenance should be performed for the database cluster.
    """
    name: Optional[str] = None
    """
    The name of the database cluster.
    """
    node_count: Annotated[Optional[float], Field(alias="nodeCount")] = None
    """
    Number of nodes that will be included in the cluster. For kafka clusters, this must be 3.
    """
    private_network_uuid: Annotated[Optional[str], Field(alias="privateNetworkUuid")] = None
    """
    The ID of the VPC where the database cluster will be located.
    """
    private_network_uuid_ref: Annotated[
        Optional[PrivateNetworkUuidRef], Field(alias="privateNetworkUuidRef")
    ] = None
    """
    Reference to a VPC in vpc to populate privateNetworkUuid.
    """
    private_network_uuid_selector: Annotated[
        Optional[PrivateNetworkUuidSelector], Field(alias="privateNetworkUuidSelector")
    ] = None
    """
    Selector for a VPC in vpc to populate privateNetworkUuid.
    """
    project_id: Annotated[Optional[str], Field(alias="projectId")] = None
    """
    The ID of the project that the database cluster is assigned to. If excluded when creating a new database cluster, it will be assigned to your default project.
    """
    project_id_ref: Annotated[Optional[ProjectIdRef], Field(alias="projectIdRef")] = None
    """
    Reference to a Project in project to populate projectId.
    """
    project_id_selector: Annotated[
        Optional[ProjectIdSelector], Field(alias="projectIdSelector")
    ] = None
    """
    Selector for a Project in project to populate projectId.
    """
    region: Optional[str] = None
    """
    DigitalOcean region where the cluster will reside.
    """
    size: Optional[str] = None
    """
    Database Droplet size associated with the cluster (ex. db-s-1vcpu-1gb). See here for a list of valid size slugs.
    """
    sql_mode: Annotated[Optional[str], Field(alias="sqlMode")] = None
    """
    A comma separated string specifying the  SQL modes for a MySQL cluster.
    """
    storage_size_mib: Annotated[Optional[str], Field(alias="storageSizeMib")] = None
    """
    Defines the disk size, in MiB, allocated to the cluster. This can be adjusted on MySQL and PostreSQL clusters based on predefined ranges for each slug/droplet size.
    """
    tags: Optional[List[str]] = None
    """
    A list of tag names to be applied to the database cluster.
    """
    version: Optional[str] = None
    """
    Engine version used by the cluster (ex. 14 for PostgreSQL 14).
    When this value is changed, a call to the Upgrade major Version for a Database API operation is made with the new version.
    """


class InitProvider(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["InitProvider"]:
            return InitProvider

        def build(self) -> "InitProvider":
            return InitProvider(**self._attrs)

        @overload
        def backup_restore(
            self, value_or_callback: List[BackupRestore], /
        ) -> "InitProvider.Builder": ...

        @overload
        def backup_restore(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[BackupRestore, BackupRestore.Builder]],
                GenericListBuilder[BackupRestore, BackupRestore.Builder] | List[BackupRestore],
            ],
            /,
        ) -> "InitProvider.Builder": ...

        @overload
        def backup_restore(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[BackupRestore.Builder]: ...

        def backup_restore(self, value_or_callback=None, /):
            """
            Create a new database cluster based on a backup of an existing cluster.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[BackupRestore.Builder]()
                context._parent_builder = self
                context._field_name = "backup_restore"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(BackupRestore.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("backup_restore", value)

        def engine(self, value: Optional[str], /) -> Self:
            """
            Database engine used by the cluster (ex. pg for PostreSQL, mysql for MySQL, redis for Redis, mongodb for MongoDB, or kafka for Kafka).
            """
            return self._set("engine", value)

        def eviction_policy(self, value: Optional[str], /) -> Self:
            """
            A string specifying the eviction policy for a Redis cluster. Valid values are: noeviction, allkeys_lru, allkeys_random, volatile_lru, volatile_random, or volatile_ttl.
            """
            return self._set("eviction_policy", value)

        @overload
        def maintenance_window(
            self, value_or_callback: List[MaintenanceWindow], /
        ) -> "InitProvider.Builder": ...

        @overload
        def maintenance_window(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[MaintenanceWindow, MaintenanceWindow.Builder]],
                GenericListBuilder[MaintenanceWindow, MaintenanceWindow.Builder]
                | List[MaintenanceWindow],
            ],
            /,
        ) -> "InitProvider.Builder": ...

        @overload
        def maintenance_window(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[MaintenanceWindow.Builder]: ...

        def maintenance_window(self, value_or_callback=None, /):
            """
            Defines when the automatic maintenance should be performed for the database cluster.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[MaintenanceWindow.Builder]()
                context._parent_builder = self
                context._field_name = "maintenance_window"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(MaintenanceWindow.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("maintenance_window", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            The name of the database cluster.
            """
            return self._set("name", value)

        def node_count(self, value: Optional[float], /) -> Self:
            """
            Number of nodes that will be included in the cluster. For kafka clusters, this must be 3.
            """
            return self._set("node_count", value)

        def private_network_uuid(self, value: Optional[str], /) -> Self:
            """
            The ID of the VPC where the database cluster will be located.
            """
            return self._set("private_network_uuid", value)

        @overload
        def private_network_uuid_ref(
            self, value_or_callback: Optional[PrivateNetworkUuidRef], /
        ) -> "InitProvider.Builder": ...

        @overload
        def private_network_uuid_ref(
            self,
            value_or_callback: Callable[
                [PrivateNetworkUuidRef.Builder],
                PrivateNetworkUuidRef.Builder | PrivateNetworkUuidRef,
            ],
            /,
        ) -> "InitProvider.Builder": ...

        @overload
        def private_network_uuid_ref(
            self, value_or_callback: Never = ...
        ) -> "PrivateNetworkUuidRef.BuilderContext": ...

        def private_network_uuid_ref(self, value_or_callback=None, /):
            """
            Reference to a VPC in vpc to populate privateNetworkUuid.
            """
            if self._in_context and value_or_callback is None:
                context = PrivateNetworkUuidRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "private_network_uuid_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PrivateNetworkUuidRef.builder())
                if isinstance(output, PrivateNetworkUuidRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("private_network_uuid_ref", value)

        @overload
        def private_network_uuid_selector(
            self, value_or_callback: Optional[PrivateNetworkUuidSelector], /
        ) -> "InitProvider.Builder": ...

        @overload
        def private_network_uuid_selector(
            self,
            value_or_callback: Callable[
                [PrivateNetworkUuidSelector.Builder],
                PrivateNetworkUuidSelector.Builder | PrivateNetworkUuidSelector,
            ],
            /,
        ) -> "InitProvider.Builder": ...

        @overload
        def private_network_uuid_selector(
            self, value_or_callback: Never = ...
        ) -> "PrivateNetworkUuidSelector.BuilderContext": ...

        def private_network_uuid_selector(self, value_or_callback=None, /):
            """
            Selector for a VPC in vpc to populate privateNetworkUuid.
            """
            if self._in_context and value_or_callback is None:
                context = PrivateNetworkUuidSelector.BuilderContext()
                context._parent_builder = self
                context._field_name = "private_network_uuid_selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PrivateNetworkUuidSelector.builder())
                if isinstance(output, PrivateNetworkUuidSelector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("private_network_uuid_selector", value)

        def project_id(self, value: Optional[str], /) -> Self:
            """
            The ID of the project that the database cluster is assigned to. If excluded when creating a new database cluster, it will be assigned to your default project.
            """
            return self._set("project_id", value)

        @overload
        def project_id_ref(
            self, value_or_callback: Optional[ProjectIdRef], /
        ) -> "InitProvider.Builder": ...

        @overload
        def project_id_ref(
            self,
            value_or_callback: Callable[
                [ProjectIdRef.Builder], ProjectIdRef.Builder | ProjectIdRef
            ],
            /,
        ) -> "InitProvider.Builder": ...

        @overload
        def project_id_ref(
            self, value_or_callback: Never = ...
        ) -> "ProjectIdRef.BuilderContext": ...

        def project_id_ref(self, value_or_callback=None, /):
            """
            Reference to a Project in project to populate projectId.
            """
            if self._in_context and value_or_callback is None:
                context = ProjectIdRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "project_id_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ProjectIdRef.builder())
                if isinstance(output, ProjectIdRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("project_id_ref", value)

        @overload
        def project_id_selector(
            self, value_or_callback: Optional[ProjectIdSelector], /
        ) -> "InitProvider.Builder": ...

        @overload
        def project_id_selector(
            self,
            value_or_callback: Callable[
                [ProjectIdSelector.Builder],
                ProjectIdSelector.Builder | ProjectIdSelector,
            ],
            /,
        ) -> "InitProvider.Builder": ...

        @overload
        def project_id_selector(
            self, value_or_callback: Never = ...
        ) -> "ProjectIdSelector.BuilderContext": ...

        def project_id_selector(self, value_or_callback=None, /):
            """
            Selector for a Project in project to populate projectId.
            """
            if self._in_context and value_or_callback is None:
                context = ProjectIdSelector.BuilderContext()
                context._parent_builder = self
                context._field_name = "project_id_selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ProjectIdSelector.builder())
                if isinstance(output, ProjectIdSelector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("project_id_selector", value)

        def region(self, value: Optional[str], /) -> Self:
            """
            DigitalOcean region where the cluster will reside.
            """
            return self._set("region", value)

        def size(self, value: Optional[str], /) -> Self:
            """
            Database Droplet size associated with the cluster (ex. db-s-1vcpu-1gb). See here for a list of valid size slugs.
            """
            return self._set("size", value)

        def sql_mode(self, value: Optional[str], /) -> Self:
            """
            A comma separated string specifying the  SQL modes for a MySQL cluster.
            """
            return self._set("sql_mode", value)

        def storage_size_mib(self, value: Optional[str], /) -> Self:
            """
            Defines the disk size, in MiB, allocated to the cluster. This can be adjusted on MySQL and PostreSQL clusters based on predefined ranges for each slug/droplet size.
            """
            return self._set("storage_size_mib", value)

        def tags(self, value: Optional[List[str]], /) -> Self:
            """
            A list of tag names to be applied to the database cluster.
            """
            return self._set("tags", value)

        def version(self, value: Optional[str], /) -> Self:
            """
            Engine version used by the cluster (ex. 14 for PostgreSQL 14).
            When this value is changed, a call to the Upgrade major Version for a Database API operation is made with the new version.
            """
            return self._set("version", value)

    class BuilderContext(BuilderContextBase["InitProvider.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = InitProvider.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for InitProvider."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["InitProvider", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use InitProvider.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    backup_restore: Annotated[Optional[List[BackupRestore]], Field(alias="backupRestore")] = None
    """
    Create a new database cluster based on a backup of an existing cluster.
    """
    engine: Optional[str] = None
    """
    Database engine used by the cluster (ex. pg for PostreSQL, mysql for MySQL, redis for Redis, mongodb for MongoDB, or kafka for Kafka).
    """
    eviction_policy: Annotated[Optional[str], Field(alias="evictionPolicy")] = None
    """
    A string specifying the eviction policy for a Redis cluster. Valid values are: noeviction, allkeys_lru, allkeys_random, volatile_lru, volatile_random, or volatile_ttl.
    """
    maintenance_window: Annotated[
        Optional[List[MaintenanceWindow]], Field(alias="maintenanceWindow")
    ] = None
    """
    Defines when the automatic maintenance should be performed for the database cluster.
    """
    name: Optional[str] = None
    """
    The name of the database cluster.
    """
    node_count: Annotated[Optional[float], Field(alias="nodeCount")] = None
    """
    Number of nodes that will be included in the cluster. For kafka clusters, this must be 3.
    """
    private_network_uuid: Annotated[Optional[str], Field(alias="privateNetworkUuid")] = None
    """
    The ID of the VPC where the database cluster will be located.
    """
    private_network_uuid_ref: Annotated[
        Optional[PrivateNetworkUuidRef], Field(alias="privateNetworkUuidRef")
    ] = None
    """
    Reference to a VPC in vpc to populate privateNetworkUuid.
    """
    private_network_uuid_selector: Annotated[
        Optional[PrivateNetworkUuidSelector], Field(alias="privateNetworkUuidSelector")
    ] = None
    """
    Selector for a VPC in vpc to populate privateNetworkUuid.
    """
    project_id: Annotated[Optional[str], Field(alias="projectId")] = None
    """
    The ID of the project that the database cluster is assigned to. If excluded when creating a new database cluster, it will be assigned to your default project.
    """
    project_id_ref: Annotated[Optional[ProjectIdRef], Field(alias="projectIdRef")] = None
    """
    Reference to a Project in project to populate projectId.
    """
    project_id_selector: Annotated[
        Optional[ProjectIdSelector], Field(alias="projectIdSelector")
    ] = None
    """
    Selector for a Project in project to populate projectId.
    """
    region: Optional[str] = None
    """
    DigitalOcean region where the cluster will reside.
    """
    size: Optional[str] = None
    """
    Database Droplet size associated with the cluster (ex. db-s-1vcpu-1gb). See here for a list of valid size slugs.
    """
    sql_mode: Annotated[Optional[str], Field(alias="sqlMode")] = None
    """
    A comma separated string specifying the  SQL modes for a MySQL cluster.
    """
    storage_size_mib: Annotated[Optional[str], Field(alias="storageSizeMib")] = None
    """
    Defines the disk size, in MiB, allocated to the cluster. This can be adjusted on MySQL and PostreSQL clusters based on predefined ranges for each slug/droplet size.
    """
    tags: Optional[List[str]] = None
    """
    A list of tag names to be applied to the database cluster.
    """
    version: Optional[str] = None
    """
    Engine version used by the cluster (ex. 14 for PostgreSQL 14).
    When this value is changed, a call to the Upgrade major Version for a Database API operation is made with the new version.
    """


class ProviderConfigRef(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ProviderConfigRef"]:
            return ProviderConfigRef

        def build(self) -> "ProviderConfigRef":
            return ProviderConfigRef(**self._attrs)

        def name(self, value: str, /) -> Self:
            """
            Name of the referenced object.
            """
            return self._set("name", value)

        @overload
        def policy(self, value_or_callback: Optional[Policy], /) -> "ProviderConfigRef.Builder": ...

        @overload
        def policy(
            self,
            value_or_callback: Callable[[Policy.Builder], Policy.Builder | Policy],
            /,
        ) -> "ProviderConfigRef.Builder": ...

        @overload
        def policy(self, value_or_callback: Never = ...) -> "Policy.BuilderContext": ...

        def policy(self, value_or_callback=None, /):
            """
            Policies for referencing.
            """
            if self._in_context and value_or_callback is None:
                context = Policy.BuilderContext()
                context._parent_builder = self
                context._field_name = "policy"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Policy.builder())
                if isinstance(output, Policy.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("policy", value)

    class BuilderContext(BuilderContextBase["ProviderConfigRef.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ProviderConfigRef.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ProviderConfigRef."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ProviderConfigRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ProviderConfigRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: str
    """
    Name of the referenced object.
    """
    policy: Optional[Policy] = None
    """
    Policies for referencing.
    """


class ConfigRef(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ConfigRef"]:
            return ConfigRef

        def build(self) -> "ConfigRef":
            return ConfigRef(**self._attrs)

        def name(self, value: str, /) -> Self:
            """
            Name of the referenced object.
            """
            return self._set("name", value)

        @overload
        def policy(self, value_or_callback: Optional[Policy], /) -> "ConfigRef.Builder": ...

        @overload
        def policy(
            self,
            value_or_callback: Callable[[Policy.Builder], Policy.Builder | Policy],
            /,
        ) -> "ConfigRef.Builder": ...

        @overload
        def policy(self, value_or_callback: Never = ...) -> "Policy.BuilderContext": ...

        def policy(self, value_or_callback=None, /):
            """
            Policies for referencing.
            """
            if self._in_context and value_or_callback is None:
                context = Policy.BuilderContext()
                context._parent_builder = self
                context._field_name = "policy"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Policy.builder())
                if isinstance(output, Policy.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("policy", value)

    class BuilderContext(BuilderContextBase["ConfigRef.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ConfigRef.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ConfigRef."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ConfigRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ConfigRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: str
    """
    Name of the referenced object.
    """
    policy: Optional[Policy] = None
    """
    Policies for referencing.
    """


class Metadata(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Metadata"]:
            return Metadata

        def build(self) -> "Metadata":
            return Metadata(**self._attrs)

        def annotations(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            Annotations are the annotations to be added to connection secret.
            - For Kubernetes secrets, this will be used as "metadata.annotations".
            - It is up to Secret Store implementation for others store types.
            """
            return self._set("annotations", value)

        def labels(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            Labels are the labels/tags to be added to connection secret.
            - For Kubernetes secrets, this will be used as "metadata.labels".
            - It is up to Secret Store implementation for others store types.
            """
            return self._set("labels", value)

        def type(self, value: Optional[str], /) -> Self:
            """
            Type is the SecretType for the connection secret.
            - Only valid for Kubernetes Secret Stores.
            """
            return self._set("type", value)

    class BuilderContext(BuilderContextBase["Metadata.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Metadata.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Metadata."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Metadata", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Metadata.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    annotations: Optional[Dict[str, str]] = None
    """
    Annotations are the annotations to be added to connection secret.
    - For Kubernetes secrets, this will be used as "metadata.annotations".
    - It is up to Secret Store implementation for others store types.
    """
    labels: Optional[Dict[str, str]] = None
    """
    Labels are the labels/tags to be added to connection secret.
    - For Kubernetes secrets, this will be used as "metadata.labels".
    - It is up to Secret Store implementation for others store types.
    """
    type: Optional[str] = None
    """
    Type is the SecretType for the connection secret.
    - Only valid for Kubernetes Secret Stores.
    """


class PublishConnectionDetailsTo(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PublishConnectionDetailsTo"]:
            return PublishConnectionDetailsTo

        def build(self) -> "PublishConnectionDetailsTo":
            return PublishConnectionDetailsTo(**self._attrs)

        @overload
        def config_ref(
            self, value_or_callback: Optional[ConfigRef], /
        ) -> "PublishConnectionDetailsTo.Builder": ...

        @overload
        def config_ref(
            self,
            value_or_callback: Callable[[ConfigRef.Builder], ConfigRef.Builder | ConfigRef],
            /,
        ) -> "PublishConnectionDetailsTo.Builder": ...

        @overload
        def config_ref(self, value_or_callback: Never = ...) -> "ConfigRef.BuilderContext": ...

        def config_ref(self, value_or_callback=None, /):
            """
            SecretStoreConfigRef specifies which secret store config should be used
            for this ConnectionSecret.
            """
            if self._in_context and value_or_callback is None:
                context = ConfigRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "config_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ConfigRef.builder())
                if isinstance(output, ConfigRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("config_ref", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[Metadata], /
        ) -> "PublishConnectionDetailsTo.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[[Metadata.Builder], Metadata.Builder | Metadata],
            /,
        ) -> "PublishConnectionDetailsTo.Builder": ...

        @overload
        def metadata(self, value_or_callback: Never = ...) -> "Metadata.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            """
            Metadata is the metadata for connection secret.
            """
            if self._in_context and value_or_callback is None:
                context = Metadata.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Metadata.builder())
                if isinstance(output, Metadata.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        def name(self, value: str, /) -> Self:
            """
            Name is the name of the connection secret.
            """
            return self._set("name", value)

    class BuilderContext(BuilderContextBase["PublishConnectionDetailsTo.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PublishConnectionDetailsTo.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PublishConnectionDetailsTo."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["PublishConnectionDetailsTo", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PublishConnectionDetailsTo.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    config_ref: Annotated[
        Optional[ConfigRef],
        Field(
            default_factory=lambda: ConfigRef.model_validate({"name": "default"}),
            alias="configRef",
        ),
    ] = {"name": "default"}
    """
    SecretStoreConfigRef specifies which secret store config should be used
    for this ConnectionSecret.
    """
    metadata: Optional[Metadata] = None
    """
    Metadata is the metadata for connection secret.
    """
    name: str
    """
    Name is the name of the connection secret.
    """


class WriteConnectionSecretToRef(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["WriteConnectionSecretToRef"]:
            return WriteConnectionSecretToRef

        def build(self) -> "WriteConnectionSecretToRef":
            return WriteConnectionSecretToRef(**self._attrs)

        def name(self, value: str, /) -> Self:
            """
            Name of the secret.
            """
            return self._set("name", value)

        def namespace(self, value: str, /) -> Self:
            """
            Namespace of the secret.
            """
            return self._set("namespace", value)

    class BuilderContext(BuilderContextBase["WriteConnectionSecretToRef.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = WriteConnectionSecretToRef.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for WriteConnectionSecretToRef."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["WriteConnectionSecretToRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use WriteConnectionSecretToRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: str
    """
    Name of the secret.
    """
    namespace: str
    """
    Namespace of the secret.
    """


class ClusterSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ClusterSpec"]:
            return ClusterSpec

        def build(self) -> "ClusterSpec":
            return ClusterSpec(**self._attrs)

        def deletion_policy(self, value: Optional[Literal["Orphan", "Delete"]], /) -> Self:
            """
            DeletionPolicy specifies what will happen to the underlying external
            when this managed resource is deleted - either "Delete" or "Orphan" the
            external resource.
            This field is planned to be deprecated in favor of the ManagementPolicies
            field in a future release. Currently, both could be set independently and
            non-default values would be honored if the feature flag is enabled.
            See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
            """
            return self._set("deletion_policy", value)

        @overload
        def for_provider(self, value_or_callback: ForProvider, /) -> "ClusterSpec.Builder": ...

        @overload
        def for_provider(
            self,
            value_or_callback: Callable[[ForProvider.Builder], ForProvider.Builder | ForProvider],
            /,
        ) -> "ClusterSpec.Builder": ...

        @overload
        def for_provider(self, value_or_callback: Never = ...) -> "ForProvider.BuilderContext": ...

        def for_provider(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ForProvider.BuilderContext()
                context._parent_builder = self
                context._field_name = "for_provider"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ForProvider.builder())
                if isinstance(output, ForProvider.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("for_provider", value)

        @overload
        def init_provider(
            self, value_or_callback: Optional[InitProvider], /
        ) -> "ClusterSpec.Builder": ...

        @overload
        def init_provider(
            self,
            value_or_callback: Callable[
                [InitProvider.Builder], InitProvider.Builder | InitProvider
            ],
            /,
        ) -> "ClusterSpec.Builder": ...

        @overload
        def init_provider(
            self, value_or_callback: Never = ...
        ) -> "InitProvider.BuilderContext": ...

        def init_provider(self, value_or_callback=None, /):
            """
            THIS IS A BETA FIELD. It will be honored
            unless the Management Policies feature flag is disabled.
            InitProvider holds the same fields as ForProvider, with the exception
            of Identifier and other resource reference fields. The fields that are
            in InitProvider are merged into ForProvider when the resource is created.
            The same fields are also added to the terraform ignore_changes hook, to
            avoid updating them after creation. This is useful for fields that are
            required on creation, but we do not desire to update them after creation,
            for example because of an external controller is managing them, like an
            autoscaler.
            """
            if self._in_context and value_or_callback is None:
                context = InitProvider.BuilderContext()
                context._parent_builder = self
                context._field_name = "init_provider"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(InitProvider.builder())
                if isinstance(output, InitProvider.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("init_provider", value)

        def management_policies(
            self,
            value: Optional[
                List[Literal["Observe", "Create", "Update", "Delete", "LateInitialize", "*"]]
            ],
            /,
        ) -> Self:
            """
            THIS IS A BETA FIELD. It is on by default but can be opted out
            through a Crossplane feature flag.
            ManagementPolicies specify the array of actions Crossplane is allowed to
            take on the managed and external resources.
            This field is planned to replace the DeletionPolicy field in a future
            release. Currently, both could be set independently and non-default
            values would be honored if the feature flag is enabled. If both are
            custom, the DeletionPolicy field will be ignored.
            See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
            and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
            """
            return self._set("management_policies", value)

        @overload
        def provider_config_ref(
            self, value_or_callback: Optional[ProviderConfigRef], /
        ) -> "ClusterSpec.Builder": ...

        @overload
        def provider_config_ref(
            self,
            value_or_callback: Callable[
                [ProviderConfigRef.Builder],
                ProviderConfigRef.Builder | ProviderConfigRef,
            ],
            /,
        ) -> "ClusterSpec.Builder": ...

        @overload
        def provider_config_ref(
            self, value_or_callback: Never = ...
        ) -> "ProviderConfigRef.BuilderContext": ...

        def provider_config_ref(self, value_or_callback=None, /):
            """
            ProviderConfigReference specifies how the provider that will be used to
            create, observe, update, and delete this managed resource should be
            configured.
            """
            if self._in_context and value_or_callback is None:
                context = ProviderConfigRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "provider_config_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ProviderConfigRef.builder())
                if isinstance(output, ProviderConfigRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("provider_config_ref", value)

        @overload
        def publish_connection_details_to(
            self, value_or_callback: Optional[PublishConnectionDetailsTo], /
        ) -> "ClusterSpec.Builder": ...

        @overload
        def publish_connection_details_to(
            self,
            value_or_callback: Callable[
                [PublishConnectionDetailsTo.Builder],
                PublishConnectionDetailsTo.Builder | PublishConnectionDetailsTo,
            ],
            /,
        ) -> "ClusterSpec.Builder": ...

        @overload
        def publish_connection_details_to(
            self, value_or_callback: Never = ...
        ) -> "PublishConnectionDetailsTo.BuilderContext": ...

        def publish_connection_details_to(self, value_or_callback=None, /):
            """
            PublishConnectionDetailsTo specifies the connection secret config which
            contains a name, metadata and a reference to secret store config to
            which any connection details for this managed resource should be written.
            Connection details frequently include the endpoint, username,
            and password required to connect to the managed resource.
            """
            if self._in_context and value_or_callback is None:
                context = PublishConnectionDetailsTo.BuilderContext()
                context._parent_builder = self
                context._field_name = "publish_connection_details_to"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PublishConnectionDetailsTo.builder())
                if isinstance(output, PublishConnectionDetailsTo.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("publish_connection_details_to", value)

        @overload
        def write_connection_secret_to_ref(
            self, value_or_callback: Optional[WriteConnectionSecretToRef], /
        ) -> "ClusterSpec.Builder": ...

        @overload
        def write_connection_secret_to_ref(
            self,
            value_or_callback: Callable[
                [WriteConnectionSecretToRef.Builder],
                WriteConnectionSecretToRef.Builder | WriteConnectionSecretToRef,
            ],
            /,
        ) -> "ClusterSpec.Builder": ...

        @overload
        def write_connection_secret_to_ref(
            self, value_or_callback: Never = ...
        ) -> "WriteConnectionSecretToRef.BuilderContext": ...

        def write_connection_secret_to_ref(self, value_or_callback=None, /):
            """
            WriteConnectionSecretToReference specifies the namespace and name of a
            Secret to which any connection details for this managed resource should
            be written. Connection details frequently include the endpoint, username,
            and password required to connect to the managed resource.
            This field is planned to be replaced in a future release in favor of
            PublishConnectionDetailsTo. Currently, both could be set independently
            and connection details would be published to both without affecting
            each other.
            """
            if self._in_context and value_or_callback is None:
                context = WriteConnectionSecretToRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "write_connection_secret_to_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(WriteConnectionSecretToRef.builder())
                if isinstance(output, WriteConnectionSecretToRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("write_connection_secret_to_ref", value)

    class BuilderContext(BuilderContextBase["ClusterSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ClusterSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ClusterSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ClusterSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ClusterSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    deletion_policy: Annotated[
        Optional[Literal["Orphan", "Delete"]], Field(alias="deletionPolicy")
    ] = "Delete"
    """
    DeletionPolicy specifies what will happen to the underlying external
    when this managed resource is deleted - either "Delete" or "Orphan" the
    external resource.
    This field is planned to be deprecated in favor of the ManagementPolicies
    field in a future release. Currently, both could be set independently and
    non-default values would be honored if the feature flag is enabled.
    See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    """
    for_provider: Annotated[ForProvider, Field(alias="forProvider")]
    init_provider: Annotated[Optional[InitProvider], Field(alias="initProvider")] = None
    """
    THIS IS A BETA FIELD. It will be honored
    unless the Management Policies feature flag is disabled.
    InitProvider holds the same fields as ForProvider, with the exception
    of Identifier and other resource reference fields. The fields that are
    in InitProvider are merged into ForProvider when the resource is created.
    The same fields are also added to the terraform ignore_changes hook, to
    avoid updating them after creation. This is useful for fields that are
    required on creation, but we do not desire to update them after creation,
    for example because of an external controller is managing them, like an
    autoscaler.
    """
    management_policies: Annotated[
        Optional[List[Literal["Observe", "Create", "Update", "Delete", "LateInitialize", "*"]]],
        Field(alias="managementPolicies"),
    ] = ["*"]
    """
    THIS IS A BETA FIELD. It is on by default but can be opted out
    through a Crossplane feature flag.
    ManagementPolicies specify the array of actions Crossplane is allowed to
    take on the managed and external resources.
    This field is planned to replace the DeletionPolicy field in a future
    release. Currently, both could be set independently and non-default
    values would be honored if the feature flag is enabled. If both are
    custom, the DeletionPolicy field will be ignored.
    See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
    """
    provider_config_ref: Annotated[
        Optional[ProviderConfigRef],
        Field(
            default_factory=lambda: ProviderConfigRef.model_validate({"name": "default"}),
            alias="providerConfigRef",
        ),
    ] = {"name": "default"}
    """
    ProviderConfigReference specifies how the provider that will be used to
    create, observe, update, and delete this managed resource should be
    configured.
    """
    publish_connection_details_to: Annotated[
        Optional[PublishConnectionDetailsTo], Field(alias="publishConnectionDetailsTo")
    ] = None
    """
    PublishConnectionDetailsTo specifies the connection secret config which
    contains a name, metadata and a reference to secret store config to
    which any connection details for this managed resource should be written.
    Connection details frequently include the endpoint, username,
    and password required to connect to the managed resource.
    """
    write_connection_secret_to_ref: Annotated[
        Optional[WriteConnectionSecretToRef], Field(alias="writeConnectionSecretToRef")
    ] = None
    """
    WriteConnectionSecretToReference specifies the namespace and name of a
    Secret to which any connection details for this managed resource should
    be written. Connection details frequently include the endpoint, username,
    and password required to connect to the managed resource.
    This field is planned to be replaced in a future release in favor of
    PublishConnectionDetailsTo. Currently, both could be set independently
    and connection details would be published to both without affecting
    each other.
    """


class AtProvider(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AtProvider"]:
            return AtProvider

        def build(self) -> "AtProvider":
            return AtProvider(**self._attrs)

        @overload
        def backup_restore(
            self, value_or_callback: List[BackupRestore], /
        ) -> "AtProvider.Builder": ...

        @overload
        def backup_restore(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[BackupRestore, BackupRestore.Builder]],
                GenericListBuilder[BackupRestore, BackupRestore.Builder] | List[BackupRestore],
            ],
            /,
        ) -> "AtProvider.Builder": ...

        @overload
        def backup_restore(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[BackupRestore.Builder]: ...

        def backup_restore(self, value_or_callback=None, /):
            """
            Create a new database cluster based on a backup of an existing cluster.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[BackupRestore.Builder]()
                context._parent_builder = self
                context._field_name = "backup_restore"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(BackupRestore.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("backup_restore", value)

        def database(self, value: Optional[str], /) -> Self:
            """
            Name of the cluster's default database.
            """
            return self._set("database", value)

        def engine(self, value: Optional[str], /) -> Self:
            """
            Database engine used by the cluster (ex. pg for PostreSQL, mysql for MySQL, redis for Redis, mongodb for MongoDB, or kafka for Kafka).
            """
            return self._set("engine", value)

        def eviction_policy(self, value: Optional[str], /) -> Self:
            """
            A string specifying the eviction policy for a Redis cluster. Valid values are: noeviction, allkeys_lru, allkeys_random, volatile_lru, volatile_random, or volatile_ttl.
            """
            return self._set("eviction_policy", value)

        def host(self, value: Optional[str], /) -> Self:
            """
            Database cluster's hostname.
            """
            return self._set("host", value)

        def id(self, value: Optional[str], /) -> Self:
            """
            The ID of the database cluster.
            """
            return self._set("id", value)

        @overload
        def maintenance_window(
            self, value_or_callback: List[MaintenanceWindow], /
        ) -> "AtProvider.Builder": ...

        @overload
        def maintenance_window(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[MaintenanceWindow, MaintenanceWindow.Builder]],
                GenericListBuilder[MaintenanceWindow, MaintenanceWindow.Builder]
                | List[MaintenanceWindow],
            ],
            /,
        ) -> "AtProvider.Builder": ...

        @overload
        def maintenance_window(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[MaintenanceWindow.Builder]: ...

        def maintenance_window(self, value_or_callback=None, /):
            """
            Defines when the automatic maintenance should be performed for the database cluster.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[MaintenanceWindow.Builder]()
                context._parent_builder = self
                context._field_name = "maintenance_window"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(MaintenanceWindow.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("maintenance_window", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            The name of the database cluster.
            """
            return self._set("name", value)

        def node_count(self, value: Optional[float], /) -> Self:
            """
            Number of nodes that will be included in the cluster. For kafka clusters, this must be 3.
            """
            return self._set("node_count", value)

        def port(self, value: Optional[float], /) -> Self:
            """
            Network port that the database cluster is listening on.
            """
            return self._set("port", value)

        def private_host(self, value: Optional[str], /) -> Self:
            """
            Same as host, but only accessible from resources within the account and in the same region.
            """
            return self._set("private_host", value)

        def private_network_uuid(self, value: Optional[str], /) -> Self:
            """
            The ID of the VPC where the database cluster will be located.
            """
            return self._set("private_network_uuid", value)

        def project_id(self, value: Optional[str], /) -> Self:
            """
            The ID of the project that the database cluster is assigned to. If excluded when creating a new database cluster, it will be assigned to your default project.
            """
            return self._set("project_id", value)

        def region(self, value: Optional[str], /) -> Self:
            """
            DigitalOcean region where the cluster will reside.
            """
            return self._set("region", value)

        def size(self, value: Optional[str], /) -> Self:
            """
            Database Droplet size associated with the cluster (ex. db-s-1vcpu-1gb). See here for a list of valid size slugs.
            """
            return self._set("size", value)

        def sql_mode(self, value: Optional[str], /) -> Self:
            """
            A comma separated string specifying the  SQL modes for a MySQL cluster.
            """
            return self._set("sql_mode", value)

        def storage_size_mib(self, value: Optional[str], /) -> Self:
            """
            Defines the disk size, in MiB, allocated to the cluster. This can be adjusted on MySQL and PostreSQL clusters based on predefined ranges for each slug/droplet size.
            """
            return self._set("storage_size_mib", value)

        def tags(self, value: Optional[List[str]], /) -> Self:
            """
            A list of tag names to be applied to the database cluster.
            """
            return self._set("tags", value)

        def ui_database(self, value: Optional[str], /) -> Self:
            """
            Name of the OpenSearch dashboard db.
            """
            return self._set("ui_database", value)

        def ui_host(self, value: Optional[str], /) -> Self:
            """
            Hostname for the OpenSearch dashboard.
            """
            return self._set("ui_host", value)

        def ui_port(self, value: Optional[float], /) -> Self:
            """
            Network port that the OpenSearch dashboard is listening on.
            """
            return self._set("ui_port", value)

        def ui_user(self, value: Optional[str], /) -> Self:
            """
            Username for OpenSearch dashboard's default user.
            """
            return self._set("ui_user", value)

        def urn(self, value: Optional[str], /) -> Self:
            """
            The uniform resource name of the database cluster.
            """
            return self._set("urn", value)

        def user(self, value: Optional[str], /) -> Self:
            """
            Username for the cluster's default user.
            """
            return self._set("user", value)

        def version(self, value: Optional[str], /) -> Self:
            """
            Engine version used by the cluster (ex. 14 for PostgreSQL 14).
            When this value is changed, a call to the Upgrade major Version for a Database API operation is made with the new version.
            """
            return self._set("version", value)

    class BuilderContext(BuilderContextBase["AtProvider.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AtProvider.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AtProvider."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AtProvider", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AtProvider.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    backup_restore: Annotated[Optional[List[BackupRestore]], Field(alias="backupRestore")] = None
    """
    Create a new database cluster based on a backup of an existing cluster.
    """
    database: Optional[str] = None
    """
    Name of the cluster's default database.
    """
    engine: Optional[str] = None
    """
    Database engine used by the cluster (ex. pg for PostreSQL, mysql for MySQL, redis for Redis, mongodb for MongoDB, or kafka for Kafka).
    """
    eviction_policy: Annotated[Optional[str], Field(alias="evictionPolicy")] = None
    """
    A string specifying the eviction policy for a Redis cluster. Valid values are: noeviction, allkeys_lru, allkeys_random, volatile_lru, volatile_random, or volatile_ttl.
    """
    host: Optional[str] = None
    """
    Database cluster's hostname.
    """
    id: Optional[str] = None
    """
    The ID of the database cluster.
    """
    maintenance_window: Annotated[
        Optional[List[MaintenanceWindow]], Field(alias="maintenanceWindow")
    ] = None
    """
    Defines when the automatic maintenance should be performed for the database cluster.
    """
    name: Optional[str] = None
    """
    The name of the database cluster.
    """
    node_count: Annotated[Optional[float], Field(alias="nodeCount")] = None
    """
    Number of nodes that will be included in the cluster. For kafka clusters, this must be 3.
    """
    port: Optional[float] = None
    """
    Network port that the database cluster is listening on.
    """
    private_host: Annotated[Optional[str], Field(alias="privateHost")] = None
    """
    Same as host, but only accessible from resources within the account and in the same region.
    """
    private_network_uuid: Annotated[Optional[str], Field(alias="privateNetworkUuid")] = None
    """
    The ID of the VPC where the database cluster will be located.
    """
    project_id: Annotated[Optional[str], Field(alias="projectId")] = None
    """
    The ID of the project that the database cluster is assigned to. If excluded when creating a new database cluster, it will be assigned to your default project.
    """
    region: Optional[str] = None
    """
    DigitalOcean region where the cluster will reside.
    """
    size: Optional[str] = None
    """
    Database Droplet size associated with the cluster (ex. db-s-1vcpu-1gb). See here for a list of valid size slugs.
    """
    sql_mode: Annotated[Optional[str], Field(alias="sqlMode")] = None
    """
    A comma separated string specifying the  SQL modes for a MySQL cluster.
    """
    storage_size_mib: Annotated[Optional[str], Field(alias="storageSizeMib")] = None
    """
    Defines the disk size, in MiB, allocated to the cluster. This can be adjusted on MySQL and PostreSQL clusters based on predefined ranges for each slug/droplet size.
    """
    tags: Optional[List[str]] = None
    """
    A list of tag names to be applied to the database cluster.
    """
    ui_database: Annotated[Optional[str], Field(alias="uiDatabase")] = None
    """
    Name of the OpenSearch dashboard db.
    """
    ui_host: Annotated[Optional[str], Field(alias="uiHost")] = None
    """
    Hostname for the OpenSearch dashboard.
    """
    ui_port: Annotated[Optional[float], Field(alias="uiPort")] = None
    """
    Network port that the OpenSearch dashboard is listening on.
    """
    ui_user: Annotated[Optional[str], Field(alias="uiUser")] = None
    """
    Username for OpenSearch dashboard's default user.
    """
    urn: Optional[str] = None
    """
    The uniform resource name of the database cluster.
    """
    user: Optional[str] = None
    """
    Username for the cluster's default user.
    """
    version: Optional[str] = None
    """
    Engine version used by the cluster (ex. 14 for PostgreSQL 14).
    When this value is changed, a call to the Upgrade major Version for a Database API operation is made with the new version.
    """


class Condition(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Condition"]:
            return Condition

        def build(self) -> "Condition":
            return Condition(**self._attrs)

        def last_transition_time(self, value: AwareDatetime, /) -> Self:
            """
            LastTransitionTime is the last time this condition transitioned from one
            status to another.
            """
            return self._set("last_transition_time", value)

        def message(self, value: Optional[str], /) -> Self:
            """
            A Message containing details about this condition's last transition from
            one status to another, if any.
            """
            return self._set("message", value)

        def observed_generation(self, value: Optional[int], /) -> Self:
            """
            ObservedGeneration represents the .metadata.generation that the condition was set based upon.
            For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
            with respect to the current state of the instance.
            """
            return self._set("observed_generation", value)

        def reason(self, value: str, /) -> Self:
            """
            A Reason for this condition's last transition from one status to another.
            """
            return self._set("reason", value)

        def status(self, value: str, /) -> Self:
            """
            Status of this condition; is it currently True, False, or Unknown?
            """
            return self._set("status", value)

        def type(self, value: str, /) -> Self:
            """
            Type of this condition. At most one of each condition type may apply to
            a resource at any point in time.
            """
            return self._set("type", value)

    class BuilderContext(BuilderContextBase["Condition.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Condition.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Condition."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Condition", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Condition.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    last_transition_time: Annotated[AwareDatetime, Field(alias="lastTransitionTime")]
    """
    LastTransitionTime is the last time this condition transitioned from one
    status to another.
    """
    message: Optional[str] = None
    """
    A Message containing details about this condition's last transition from
    one status to another, if any.
    """
    observed_generation: Annotated[Optional[int], Field(alias="observedGeneration")] = None
    """
    ObservedGeneration represents the .metadata.generation that the condition was set based upon.
    For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
    with respect to the current state of the instance.
    """
    reason: str
    """
    A Reason for this condition's last transition from one status to another.
    """
    status: str
    """
    Status of this condition; is it currently True, False, or Unknown?
    """
    type: str
    """
    Type of this condition. At most one of each condition type may apply to
    a resource at any point in time.
    """


class ClusterStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ClusterStatus"]:
            return ClusterStatus

        def build(self) -> "ClusterStatus":
            return ClusterStatus(**self._attrs)

        @overload
        def at_provider(
            self, value_or_callback: Optional[AtProvider], /
        ) -> "ClusterStatus.Builder": ...

        @overload
        def at_provider(
            self,
            value_or_callback: Callable[[AtProvider.Builder], AtProvider.Builder | AtProvider],
            /,
        ) -> "ClusterStatus.Builder": ...

        @overload
        def at_provider(self, value_or_callback: Never = ...) -> "AtProvider.BuilderContext": ...

        def at_provider(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = AtProvider.BuilderContext()
                context._parent_builder = self
                context._field_name = "at_provider"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AtProvider.builder())
                if isinstance(output, AtProvider.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("at_provider", value)

        @overload
        def conditions(self, value_or_callback: List[Condition], /) -> "ClusterStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Condition, Condition.Builder]],
                GenericListBuilder[Condition, Condition.Builder] | List[Condition],
            ],
            /,
        ) -> "ClusterStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            """
            Conditions of the resource.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        def observed_generation(self, value: Optional[int], /) -> Self:
            """
            ObservedGeneration is the latest metadata.generation
            which resulted in either a ready state, or stalled due to error
            it can not recover from without human intervention.
            """
            return self._set("observed_generation", value)

    class BuilderContext(BuilderContextBase["ClusterStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ClusterStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ClusterStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ClusterStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ClusterStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    at_provider: Annotated[Optional[AtProvider], Field(alias="atProvider")] = None
    conditions: Optional[List[Condition]] = None
    """
    Conditions of the resource.
    """
    observed_generation: Annotated[Optional[int], Field(alias="observedGeneration")] = None
    """
    ObservedGeneration is the latest metadata.generation
    which resulted in either a ready state, or stalled due to error
    it can not recover from without human intervention.
    """


class ClusterIdRef(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ClusterIdRef"]:
            return ClusterIdRef

        def build(self) -> "ClusterIdRef":
            return ClusterIdRef(**self._attrs)

        def name(self, value: str, /) -> Self:
            """
            Name of the referenced object.
            """
            return self._set("name", value)

        @overload
        def policy(self, value_or_callback: Optional[Policy], /) -> "ClusterIdRef.Builder": ...

        @overload
        def policy(
            self,
            value_or_callback: Callable[[Policy.Builder], Policy.Builder | Policy],
            /,
        ) -> "ClusterIdRef.Builder": ...

        @overload
        def policy(self, value_or_callback: Never = ...) -> "Policy.BuilderContext": ...

        def policy(self, value_or_callback=None, /):
            """
            Policies for referencing.
            """
            if self._in_context and value_or_callback is None:
                context = Policy.BuilderContext()
                context._parent_builder = self
                context._field_name = "policy"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Policy.builder())
                if isinstance(output, Policy.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("policy", value)

    class BuilderContext(BuilderContextBase["ClusterIdRef.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ClusterIdRef.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ClusterIdRef."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ClusterIdRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ClusterIdRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: str
    """
    Name of the referenced object.
    """
    policy: Optional[Policy] = None
    """
    Policies for referencing.
    """


class ClusterIdSelector(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ClusterIdSelector"]:
            return ClusterIdSelector

        def build(self) -> "ClusterIdSelector":
            return ClusterIdSelector(**self._attrs)

        def match_controller_ref(self, value: Optional[bool], /) -> Self:
            """
            MatchControllerRef ensures an object with the same controller reference
            as the selecting object is selected.
            """
            return self._set("match_controller_ref", value)

        def match_labels(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            MatchLabels ensures an object with matching labels is selected.
            """
            return self._set("match_labels", value)

        @overload
        def policy(self, value_or_callback: Optional[Policy], /) -> "ClusterIdSelector.Builder": ...

        @overload
        def policy(
            self,
            value_or_callback: Callable[[Policy.Builder], Policy.Builder | Policy],
            /,
        ) -> "ClusterIdSelector.Builder": ...

        @overload
        def policy(self, value_or_callback: Never = ...) -> "Policy.BuilderContext": ...

        def policy(self, value_or_callback=None, /):
            """
            Policies for selection.
            """
            if self._in_context and value_or_callback is None:
                context = Policy.BuilderContext()
                context._parent_builder = self
                context._field_name = "policy"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Policy.builder())
                if isinstance(output, Policy.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("policy", value)

    class BuilderContext(BuilderContextBase["ClusterIdSelector.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ClusterIdSelector.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ClusterIdSelector."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ClusterIdSelector", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ClusterIdSelector.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    match_controller_ref: Annotated[Optional[bool], Field(alias="matchControllerRef")] = None
    """
    MatchControllerRef ensures an object with the same controller reference
    as the selecting object is selected.
    """
    match_labels: Annotated[Optional[Dict[str, str]], Field(alias="matchLabels")] = None
    """
    MatchLabels ensures an object with matching labels is selected.
    """
    policy: Optional[Policy] = None
    """
    Policies for selection.
    """


class ForProviderModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ForProviderModel"]:
            return ForProviderModel

        def build(self) -> "ForProviderModel":
            return ForProviderModel(**self._attrs)

        def cluster_id(self, value: Optional[str], /) -> Self:
            """
            The ID of the source database cluster. Note: This must be a PostgreSQL cluster.
            """
            return self._set("cluster_id", value)

        @overload
        def cluster_id_ref(
            self, value_or_callback: Optional[ClusterIdRef], /
        ) -> "ForProviderModel.Builder": ...

        @overload
        def cluster_id_ref(
            self,
            value_or_callback: Callable[
                [ClusterIdRef.Builder], ClusterIdRef.Builder | ClusterIdRef
            ],
            /,
        ) -> "ForProviderModel.Builder": ...

        @overload
        def cluster_id_ref(
            self, value_or_callback: Never = ...
        ) -> "ClusterIdRef.BuilderContext": ...

        def cluster_id_ref(self, value_or_callback=None, /):
            """
            Reference to a Cluster in database to populate clusterId.
            """
            if self._in_context and value_or_callback is None:
                context = ClusterIdRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "cluster_id_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ClusterIdRef.builder())
                if isinstance(output, ClusterIdRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("cluster_id_ref", value)

        @overload
        def cluster_id_selector(
            self, value_or_callback: Optional[ClusterIdSelector], /
        ) -> "ForProviderModel.Builder": ...

        @overload
        def cluster_id_selector(
            self,
            value_or_callback: Callable[
                [ClusterIdSelector.Builder],
                ClusterIdSelector.Builder | ClusterIdSelector,
            ],
            /,
        ) -> "ForProviderModel.Builder": ...

        @overload
        def cluster_id_selector(
            self, value_or_callback: Never = ...
        ) -> "ClusterIdSelector.BuilderContext": ...

        def cluster_id_selector(self, value_or_callback=None, /):
            """
            Selector for a Cluster in database to populate clusterId.
            """
            if self._in_context and value_or_callback is None:
                context = ClusterIdSelector.BuilderContext()
                context._parent_builder = self
                context._field_name = "cluster_id_selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ClusterIdSelector.builder())
                if isinstance(output, ClusterIdSelector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("cluster_id_selector", value)

        def db_name(self, value: Optional[str], /) -> Self:
            """
            The database for use with the connection pool.
            """
            return self._set("db_name", value)

        def mode(self, value: Optional[str], /) -> Self:
            """
            The PGBouncer transaction mode for the connection pool. The allowed values are session, transaction, and statement.
            """
            return self._set("mode", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            The name for the database connection pool.
            """
            return self._set("name", value)

        def size(self, value: Optional[float], /) -> Self:
            """
            The desired size of the PGBouncer connection pool.
            """
            return self._set("size", value)

        def user(self, value: Optional[str], /) -> Self:
            """
            The name of the database user for use with the connection pool. When excluded, all sessions connect to the database as the inbound user.
            """
            return self._set("user", value)

    class BuilderContext(BuilderContextBase["ForProviderModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ForProviderModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ForProviderModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ForProviderModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ForProviderModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    cluster_id: Annotated[Optional[str], Field(alias="clusterId")] = None
    """
    The ID of the source database cluster. Note: This must be a PostgreSQL cluster.
    """
    cluster_id_ref: Annotated[Optional[ClusterIdRef], Field(alias="clusterIdRef")] = None
    """
    Reference to a Cluster in database to populate clusterId.
    """
    cluster_id_selector: Annotated[
        Optional[ClusterIdSelector], Field(alias="clusterIdSelector")
    ] = None
    """
    Selector for a Cluster in database to populate clusterId.
    """
    db_name: Annotated[Optional[str], Field(alias="dbName")] = None
    """
    The database for use with the connection pool.
    """
    mode: Optional[str] = None
    """
    The PGBouncer transaction mode for the connection pool. The allowed values are session, transaction, and statement.
    """
    name: Optional[str] = None
    """
    The name for the database connection pool.
    """
    size: Optional[float] = None
    """
    The desired size of the PGBouncer connection pool.
    """
    user: Optional[str] = None
    """
    The name of the database user for use with the connection pool. When excluded, all sessions connect to the database as the inbound user.
    """


class InitProviderModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["InitProviderModel"]:
            return InitProviderModel

        def build(self) -> "InitProviderModel":
            return InitProviderModel(**self._attrs)

        def cluster_id(self, value: Optional[str], /) -> Self:
            """
            The ID of the source database cluster. Note: This must be a PostgreSQL cluster.
            """
            return self._set("cluster_id", value)

        @overload
        def cluster_id_ref(
            self, value_or_callback: Optional[ClusterIdRef], /
        ) -> "InitProviderModel.Builder": ...

        @overload
        def cluster_id_ref(
            self,
            value_or_callback: Callable[
                [ClusterIdRef.Builder], ClusterIdRef.Builder | ClusterIdRef
            ],
            /,
        ) -> "InitProviderModel.Builder": ...

        @overload
        def cluster_id_ref(
            self, value_or_callback: Never = ...
        ) -> "ClusterIdRef.BuilderContext": ...

        def cluster_id_ref(self, value_or_callback=None, /):
            """
            Reference to a Cluster in database to populate clusterId.
            """
            if self._in_context and value_or_callback is None:
                context = ClusterIdRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "cluster_id_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ClusterIdRef.builder())
                if isinstance(output, ClusterIdRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("cluster_id_ref", value)

        @overload
        def cluster_id_selector(
            self, value_or_callback: Optional[ClusterIdSelector], /
        ) -> "InitProviderModel.Builder": ...

        @overload
        def cluster_id_selector(
            self,
            value_or_callback: Callable[
                [ClusterIdSelector.Builder],
                ClusterIdSelector.Builder | ClusterIdSelector,
            ],
            /,
        ) -> "InitProviderModel.Builder": ...

        @overload
        def cluster_id_selector(
            self, value_or_callback: Never = ...
        ) -> "ClusterIdSelector.BuilderContext": ...

        def cluster_id_selector(self, value_or_callback=None, /):
            """
            Selector for a Cluster in database to populate clusterId.
            """
            if self._in_context and value_or_callback is None:
                context = ClusterIdSelector.BuilderContext()
                context._parent_builder = self
                context._field_name = "cluster_id_selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ClusterIdSelector.builder())
                if isinstance(output, ClusterIdSelector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("cluster_id_selector", value)

        def db_name(self, value: Optional[str], /) -> Self:
            """
            The database for use with the connection pool.
            """
            return self._set("db_name", value)

        def mode(self, value: Optional[str], /) -> Self:
            """
            The PGBouncer transaction mode for the connection pool. The allowed values are session, transaction, and statement.
            """
            return self._set("mode", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            The name for the database connection pool.
            """
            return self._set("name", value)

        def size(self, value: Optional[float], /) -> Self:
            """
            The desired size of the PGBouncer connection pool.
            """
            return self._set("size", value)

        def user(self, value: Optional[str], /) -> Self:
            """
            The name of the database user for use with the connection pool. When excluded, all sessions connect to the database as the inbound user.
            """
            return self._set("user", value)

    class BuilderContext(BuilderContextBase["InitProviderModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = InitProviderModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for InitProviderModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["InitProviderModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use InitProviderModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    cluster_id: Annotated[Optional[str], Field(alias="clusterId")] = None
    """
    The ID of the source database cluster. Note: This must be a PostgreSQL cluster.
    """
    cluster_id_ref: Annotated[Optional[ClusterIdRef], Field(alias="clusterIdRef")] = None
    """
    Reference to a Cluster in database to populate clusterId.
    """
    cluster_id_selector: Annotated[
        Optional[ClusterIdSelector], Field(alias="clusterIdSelector")
    ] = None
    """
    Selector for a Cluster in database to populate clusterId.
    """
    db_name: Annotated[Optional[str], Field(alias="dbName")] = None
    """
    The database for use with the connection pool.
    """
    mode: Optional[str] = None
    """
    The PGBouncer transaction mode for the connection pool. The allowed values are session, transaction, and statement.
    """
    name: Optional[str] = None
    """
    The name for the database connection pool.
    """
    size: Optional[float] = None
    """
    The desired size of the PGBouncer connection pool.
    """
    user: Optional[str] = None
    """
    The name of the database user for use with the connection pool. When excluded, all sessions connect to the database as the inbound user.
    """


class ConnectionPoolSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ConnectionPoolSpec"]:
            return ConnectionPoolSpec

        def build(self) -> "ConnectionPoolSpec":
            return ConnectionPoolSpec(**self._attrs)

        def deletion_policy(self, value: Optional[Literal["Orphan", "Delete"]], /) -> Self:
            """
            DeletionPolicy specifies what will happen to the underlying external
            when this managed resource is deleted - either "Delete" or "Orphan" the
            external resource.
            This field is planned to be deprecated in favor of the ManagementPolicies
            field in a future release. Currently, both could be set independently and
            non-default values would be honored if the feature flag is enabled.
            See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
            """
            return self._set("deletion_policy", value)

        @overload
        def for_provider(
            self, value_or_callback: ForProviderModel, /
        ) -> "ConnectionPoolSpec.Builder": ...

        @overload
        def for_provider(
            self,
            value_or_callback: Callable[
                [ForProviderModel.Builder], ForProviderModel.Builder | ForProviderModel
            ],
            /,
        ) -> "ConnectionPoolSpec.Builder": ...

        @overload
        def for_provider(
            self, value_or_callback: Never = ...
        ) -> "ForProviderModel.BuilderContext": ...

        def for_provider(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ForProviderModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "for_provider"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ForProviderModel.builder())
                if isinstance(output, ForProviderModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("for_provider", value)

        @overload
        def init_provider(
            self, value_or_callback: Optional[InitProviderModel], /
        ) -> "ConnectionPoolSpec.Builder": ...

        @overload
        def init_provider(
            self,
            value_or_callback: Callable[
                [InitProviderModel.Builder],
                InitProviderModel.Builder | InitProviderModel,
            ],
            /,
        ) -> "ConnectionPoolSpec.Builder": ...

        @overload
        def init_provider(
            self, value_or_callback: Never = ...
        ) -> "InitProviderModel.BuilderContext": ...

        def init_provider(self, value_or_callback=None, /):
            """
            THIS IS A BETA FIELD. It will be honored
            unless the Management Policies feature flag is disabled.
            InitProvider holds the same fields as ForProvider, with the exception
            of Identifier and other resource reference fields. The fields that are
            in InitProvider are merged into ForProvider when the resource is created.
            The same fields are also added to the terraform ignore_changes hook, to
            avoid updating them after creation. This is useful for fields that are
            required on creation, but we do not desire to update them after creation,
            for example because of an external controller is managing them, like an
            autoscaler.
            """
            if self._in_context and value_or_callback is None:
                context = InitProviderModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "init_provider"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(InitProviderModel.builder())
                if isinstance(output, InitProviderModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("init_provider", value)

        def management_policies(
            self,
            value: Optional[
                List[Literal["Observe", "Create", "Update", "Delete", "LateInitialize", "*"]]
            ],
            /,
        ) -> Self:
            """
            THIS IS A BETA FIELD. It is on by default but can be opted out
            through a Crossplane feature flag.
            ManagementPolicies specify the array of actions Crossplane is allowed to
            take on the managed and external resources.
            This field is planned to replace the DeletionPolicy field in a future
            release. Currently, both could be set independently and non-default
            values would be honored if the feature flag is enabled. If both are
            custom, the DeletionPolicy field will be ignored.
            See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
            and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
            """
            return self._set("management_policies", value)

        @overload
        def provider_config_ref(
            self, value_or_callback: Optional[ProviderConfigRef], /
        ) -> "ConnectionPoolSpec.Builder": ...

        @overload
        def provider_config_ref(
            self,
            value_or_callback: Callable[
                [ProviderConfigRef.Builder],
                ProviderConfigRef.Builder | ProviderConfigRef,
            ],
            /,
        ) -> "ConnectionPoolSpec.Builder": ...

        @overload
        def provider_config_ref(
            self, value_or_callback: Never = ...
        ) -> "ProviderConfigRef.BuilderContext": ...

        def provider_config_ref(self, value_or_callback=None, /):
            """
            ProviderConfigReference specifies how the provider that will be used to
            create, observe, update, and delete this managed resource should be
            configured.
            """
            if self._in_context and value_or_callback is None:
                context = ProviderConfigRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "provider_config_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ProviderConfigRef.builder())
                if isinstance(output, ProviderConfigRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("provider_config_ref", value)

        @overload
        def publish_connection_details_to(
            self, value_or_callback: Optional[PublishConnectionDetailsTo], /
        ) -> "ConnectionPoolSpec.Builder": ...

        @overload
        def publish_connection_details_to(
            self,
            value_or_callback: Callable[
                [PublishConnectionDetailsTo.Builder],
                PublishConnectionDetailsTo.Builder | PublishConnectionDetailsTo,
            ],
            /,
        ) -> "ConnectionPoolSpec.Builder": ...

        @overload
        def publish_connection_details_to(
            self, value_or_callback: Never = ...
        ) -> "PublishConnectionDetailsTo.BuilderContext": ...

        def publish_connection_details_to(self, value_or_callback=None, /):
            """
            PublishConnectionDetailsTo specifies the connection secret config which
            contains a name, metadata and a reference to secret store config to
            which any connection details for this managed resource should be written.
            Connection details frequently include the endpoint, username,
            and password required to connect to the managed resource.
            """
            if self._in_context and value_or_callback is None:
                context = PublishConnectionDetailsTo.BuilderContext()
                context._parent_builder = self
                context._field_name = "publish_connection_details_to"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PublishConnectionDetailsTo.builder())
                if isinstance(output, PublishConnectionDetailsTo.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("publish_connection_details_to", value)

        @overload
        def write_connection_secret_to_ref(
            self, value_or_callback: Optional[WriteConnectionSecretToRef], /
        ) -> "ConnectionPoolSpec.Builder": ...

        @overload
        def write_connection_secret_to_ref(
            self,
            value_or_callback: Callable[
                [WriteConnectionSecretToRef.Builder],
                WriteConnectionSecretToRef.Builder | WriteConnectionSecretToRef,
            ],
            /,
        ) -> "ConnectionPoolSpec.Builder": ...

        @overload
        def write_connection_secret_to_ref(
            self, value_or_callback: Never = ...
        ) -> "WriteConnectionSecretToRef.BuilderContext": ...

        def write_connection_secret_to_ref(self, value_or_callback=None, /):
            """
            WriteConnectionSecretToReference specifies the namespace and name of a
            Secret to which any connection details for this managed resource should
            be written. Connection details frequently include the endpoint, username,
            and password required to connect to the managed resource.
            This field is planned to be replaced in a future release in favor of
            PublishConnectionDetailsTo. Currently, both could be set independently
            and connection details would be published to both without affecting
            each other.
            """
            if self._in_context and value_or_callback is None:
                context = WriteConnectionSecretToRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "write_connection_secret_to_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(WriteConnectionSecretToRef.builder())
                if isinstance(output, WriteConnectionSecretToRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("write_connection_secret_to_ref", value)

    class BuilderContext(BuilderContextBase["ConnectionPoolSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ConnectionPoolSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ConnectionPoolSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ConnectionPoolSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ConnectionPoolSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    deletion_policy: Annotated[
        Optional[Literal["Orphan", "Delete"]], Field(alias="deletionPolicy")
    ] = "Delete"
    """
    DeletionPolicy specifies what will happen to the underlying external
    when this managed resource is deleted - either "Delete" or "Orphan" the
    external resource.
    This field is planned to be deprecated in favor of the ManagementPolicies
    field in a future release. Currently, both could be set independently and
    non-default values would be honored if the feature flag is enabled.
    See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    """
    for_provider: Annotated[ForProviderModel, Field(alias="forProvider")]
    init_provider: Annotated[Optional[InitProviderModel], Field(alias="initProvider")] = None
    """
    THIS IS A BETA FIELD. It will be honored
    unless the Management Policies feature flag is disabled.
    InitProvider holds the same fields as ForProvider, with the exception
    of Identifier and other resource reference fields. The fields that are
    in InitProvider are merged into ForProvider when the resource is created.
    The same fields are also added to the terraform ignore_changes hook, to
    avoid updating them after creation. This is useful for fields that are
    required on creation, but we do not desire to update them after creation,
    for example because of an external controller is managing them, like an
    autoscaler.
    """
    management_policies: Annotated[
        Optional[List[Literal["Observe", "Create", "Update", "Delete", "LateInitialize", "*"]]],
        Field(alias="managementPolicies"),
    ] = ["*"]
    """
    THIS IS A BETA FIELD. It is on by default but can be opted out
    through a Crossplane feature flag.
    ManagementPolicies specify the array of actions Crossplane is allowed to
    take on the managed and external resources.
    This field is planned to replace the DeletionPolicy field in a future
    release. Currently, both could be set independently and non-default
    values would be honored if the feature flag is enabled. If both are
    custom, the DeletionPolicy field will be ignored.
    See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
    """
    provider_config_ref: Annotated[
        Optional[ProviderConfigRef],
        Field(
            default_factory=lambda: ProviderConfigRef.model_validate({"name": "default"}),
            alias="providerConfigRef",
        ),
    ] = {"name": "default"}
    """
    ProviderConfigReference specifies how the provider that will be used to
    create, observe, update, and delete this managed resource should be
    configured.
    """
    publish_connection_details_to: Annotated[
        Optional[PublishConnectionDetailsTo], Field(alias="publishConnectionDetailsTo")
    ] = None
    """
    PublishConnectionDetailsTo specifies the connection secret config which
    contains a name, metadata and a reference to secret store config to
    which any connection details for this managed resource should be written.
    Connection details frequently include the endpoint, username,
    and password required to connect to the managed resource.
    """
    write_connection_secret_to_ref: Annotated[
        Optional[WriteConnectionSecretToRef], Field(alias="writeConnectionSecretToRef")
    ] = None
    """
    WriteConnectionSecretToReference specifies the namespace and name of a
    Secret to which any connection details for this managed resource should
    be written. Connection details frequently include the endpoint, username,
    and password required to connect to the managed resource.
    This field is planned to be replaced in a future release in favor of
    PublishConnectionDetailsTo. Currently, both could be set independently
    and connection details would be published to both without affecting
    each other.
    """


class AtProviderModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AtProviderModel"]:
            return AtProviderModel

        def build(self) -> "AtProviderModel":
            return AtProviderModel(**self._attrs)

        def cluster_id(self, value: Optional[str], /) -> Self:
            """
            The ID of the source database cluster. Note: This must be a PostgreSQL cluster.
            """
            return self._set("cluster_id", value)

        def db_name(self, value: Optional[str], /) -> Self:
            """
            The database for use with the connection pool.
            """
            return self._set("db_name", value)

        def host(self, value: Optional[str], /) -> Self:
            """
            The hostname used to connect to the database connection pool.
            """
            return self._set("host", value)

        def id(self, value: Optional[str], /) -> Self:
            """
            The ID of the database connection pool.
            """
            return self._set("id", value)

        def mode(self, value: Optional[str], /) -> Self:
            """
            The PGBouncer transaction mode for the connection pool. The allowed values are session, transaction, and statement.
            """
            return self._set("mode", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            The name for the database connection pool.
            """
            return self._set("name", value)

        def port(self, value: Optional[float], /) -> Self:
            """
            Network port that the database connection pool is listening on.
            """
            return self._set("port", value)

        def private_host(self, value: Optional[str], /) -> Self:
            """
            Same as host, but only accessible from resources within the account and in the same region.
            """
            return self._set("private_host", value)

        def size(self, value: Optional[float], /) -> Self:
            """
            The desired size of the PGBouncer connection pool.
            """
            return self._set("size", value)

        def user(self, value: Optional[str], /) -> Self:
            """
            The name of the database user for use with the connection pool. When excluded, all sessions connect to the database as the inbound user.
            """
            return self._set("user", value)

    class BuilderContext(BuilderContextBase["AtProviderModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AtProviderModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AtProviderModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AtProviderModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AtProviderModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    cluster_id: Annotated[Optional[str], Field(alias="clusterId")] = None
    """
    The ID of the source database cluster. Note: This must be a PostgreSQL cluster.
    """
    db_name: Annotated[Optional[str], Field(alias="dbName")] = None
    """
    The database for use with the connection pool.
    """
    host: Optional[str] = None
    """
    The hostname used to connect to the database connection pool.
    """
    id: Optional[str] = None
    """
    The ID of the database connection pool.
    """
    mode: Optional[str] = None
    """
    The PGBouncer transaction mode for the connection pool. The allowed values are session, transaction, and statement.
    """
    name: Optional[str] = None
    """
    The name for the database connection pool.
    """
    port: Optional[float] = None
    """
    Network port that the database connection pool is listening on.
    """
    private_host: Annotated[Optional[str], Field(alias="privateHost")] = None
    """
    Same as host, but only accessible from resources within the account and in the same region.
    """
    size: Optional[float] = None
    """
    The desired size of the PGBouncer connection pool.
    """
    user: Optional[str] = None
    """
    The name of the database user for use with the connection pool. When excluded, all sessions connect to the database as the inbound user.
    """


class ConnectionPoolStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ConnectionPoolStatus"]:
            return ConnectionPoolStatus

        def build(self) -> "ConnectionPoolStatus":
            return ConnectionPoolStatus(**self._attrs)

        @overload
        def at_provider(
            self, value_or_callback: Optional[AtProviderModel], /
        ) -> "ConnectionPoolStatus.Builder": ...

        @overload
        def at_provider(
            self,
            value_or_callback: Callable[
                [AtProviderModel.Builder], AtProviderModel.Builder | AtProviderModel
            ],
            /,
        ) -> "ConnectionPoolStatus.Builder": ...

        @overload
        def at_provider(
            self, value_or_callback: Never = ...
        ) -> "AtProviderModel.BuilderContext": ...

        def at_provider(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = AtProviderModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "at_provider"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AtProviderModel.builder())
                if isinstance(output, AtProviderModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("at_provider", value)

        @overload
        def conditions(
            self, value_or_callback: List[Condition], /
        ) -> "ConnectionPoolStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Condition, Condition.Builder]],
                GenericListBuilder[Condition, Condition.Builder] | List[Condition],
            ],
            /,
        ) -> "ConnectionPoolStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            """
            Conditions of the resource.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        def observed_generation(self, value: Optional[int], /) -> Self:
            """
            ObservedGeneration is the latest metadata.generation
            which resulted in either a ready state, or stalled due to error
            it can not recover from without human intervention.
            """
            return self._set("observed_generation", value)

    class BuilderContext(BuilderContextBase["ConnectionPoolStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ConnectionPoolStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ConnectionPoolStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ConnectionPoolStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ConnectionPoolStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    at_provider: Annotated[Optional[AtProviderModel], Field(alias="atProvider")] = None
    conditions: Optional[List[Condition]] = None
    """
    Conditions of the resource.
    """
    observed_generation: Annotated[Optional[int], Field(alias="observedGeneration")] = None
    """
    ObservedGeneration is the latest metadata.generation
    which resulted in either a ready state, or stalled due to error
    it can not recover from without human intervention.
    """


class ForProviderModel1(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ForProviderModel1"]:
            return ForProviderModel1

        def build(self) -> "ForProviderModel1":
            return ForProviderModel1(**self._attrs)

        def cluster_id(self, value: Optional[str], /) -> Self:
            """
            The ID of the original source database cluster.
            """
            return self._set("cluster_id", value)

        @overload
        def cluster_id_ref(
            self, value_or_callback: Optional[ClusterIdRef], /
        ) -> "ForProviderModel1.Builder": ...

        @overload
        def cluster_id_ref(
            self,
            value_or_callback: Callable[
                [ClusterIdRef.Builder], ClusterIdRef.Builder | ClusterIdRef
            ],
            /,
        ) -> "ForProviderModel1.Builder": ...

        @overload
        def cluster_id_ref(
            self, value_or_callback: Never = ...
        ) -> "ClusterIdRef.BuilderContext": ...

        def cluster_id_ref(self, value_or_callback=None, /):
            """
            Reference to a Cluster in database to populate clusterId.
            """
            if self._in_context and value_or_callback is None:
                context = ClusterIdRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "cluster_id_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ClusterIdRef.builder())
                if isinstance(output, ClusterIdRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("cluster_id_ref", value)

        @overload
        def cluster_id_selector(
            self, value_or_callback: Optional[ClusterIdSelector], /
        ) -> "ForProviderModel1.Builder": ...

        @overload
        def cluster_id_selector(
            self,
            value_or_callback: Callable[
                [ClusterIdSelector.Builder],
                ClusterIdSelector.Builder | ClusterIdSelector,
            ],
            /,
        ) -> "ForProviderModel1.Builder": ...

        @overload
        def cluster_id_selector(
            self, value_or_callback: Never = ...
        ) -> "ClusterIdSelector.BuilderContext": ...

        def cluster_id_selector(self, value_or_callback=None, /):
            """
            Selector for a Cluster in database to populate clusterId.
            """
            if self._in_context and value_or_callback is None:
                context = ClusterIdSelector.BuilderContext()
                context._parent_builder = self
                context._field_name = "cluster_id_selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ClusterIdSelector.builder())
                if isinstance(output, ClusterIdSelector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("cluster_id_selector", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            The name for the database.
            """
            return self._set("name", value)

    class BuilderContext(BuilderContextBase["ForProviderModel1.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ForProviderModel1.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ForProviderModel1."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ForProviderModel1", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ForProviderModel1.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    cluster_id: Annotated[Optional[str], Field(alias="clusterId")] = None
    """
    The ID of the original source database cluster.
    """
    cluster_id_ref: Annotated[Optional[ClusterIdRef], Field(alias="clusterIdRef")] = None
    """
    Reference to a Cluster in database to populate clusterId.
    """
    cluster_id_selector: Annotated[
        Optional[ClusterIdSelector], Field(alias="clusterIdSelector")
    ] = None
    """
    Selector for a Cluster in database to populate clusterId.
    """
    name: Optional[str] = None
    """
    The name for the database.
    """


class InitProviderModel1(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["InitProviderModel1"]:
            return InitProviderModel1

        def build(self) -> "InitProviderModel1":
            return InitProviderModel1(**self._attrs)

        def cluster_id(self, value: Optional[str], /) -> Self:
            """
            The ID of the original source database cluster.
            """
            return self._set("cluster_id", value)

        @overload
        def cluster_id_ref(
            self, value_or_callback: Optional[ClusterIdRef], /
        ) -> "InitProviderModel1.Builder": ...

        @overload
        def cluster_id_ref(
            self,
            value_or_callback: Callable[
                [ClusterIdRef.Builder], ClusterIdRef.Builder | ClusterIdRef
            ],
            /,
        ) -> "InitProviderModel1.Builder": ...

        @overload
        def cluster_id_ref(
            self, value_or_callback: Never = ...
        ) -> "ClusterIdRef.BuilderContext": ...

        def cluster_id_ref(self, value_or_callback=None, /):
            """
            Reference to a Cluster in database to populate clusterId.
            """
            if self._in_context and value_or_callback is None:
                context = ClusterIdRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "cluster_id_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ClusterIdRef.builder())
                if isinstance(output, ClusterIdRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("cluster_id_ref", value)

        @overload
        def cluster_id_selector(
            self, value_or_callback: Optional[ClusterIdSelector], /
        ) -> "InitProviderModel1.Builder": ...

        @overload
        def cluster_id_selector(
            self,
            value_or_callback: Callable[
                [ClusterIdSelector.Builder],
                ClusterIdSelector.Builder | ClusterIdSelector,
            ],
            /,
        ) -> "InitProviderModel1.Builder": ...

        @overload
        def cluster_id_selector(
            self, value_or_callback: Never = ...
        ) -> "ClusterIdSelector.BuilderContext": ...

        def cluster_id_selector(self, value_or_callback=None, /):
            """
            Selector for a Cluster in database to populate clusterId.
            """
            if self._in_context and value_or_callback is None:
                context = ClusterIdSelector.BuilderContext()
                context._parent_builder = self
                context._field_name = "cluster_id_selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ClusterIdSelector.builder())
                if isinstance(output, ClusterIdSelector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("cluster_id_selector", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            The name for the database.
            """
            return self._set("name", value)

    class BuilderContext(BuilderContextBase["InitProviderModel1.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = InitProviderModel1.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for InitProviderModel1."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["InitProviderModel1", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use InitProviderModel1.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    cluster_id: Annotated[Optional[str], Field(alias="clusterId")] = None
    """
    The ID of the original source database cluster.
    """
    cluster_id_ref: Annotated[Optional[ClusterIdRef], Field(alias="clusterIdRef")] = None
    """
    Reference to a Cluster in database to populate clusterId.
    """
    cluster_id_selector: Annotated[
        Optional[ClusterIdSelector], Field(alias="clusterIdSelector")
    ] = None
    """
    Selector for a Cluster in database to populate clusterId.
    """
    name: Optional[str] = None
    """
    The name for the database.
    """


class DBSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["DBSpec"]:
            return DBSpec

        def build(self) -> "DBSpec":
            return DBSpec(**self._attrs)

        def deletion_policy(self, value: Optional[Literal["Orphan", "Delete"]], /) -> Self:
            """
            DeletionPolicy specifies what will happen to the underlying external
            when this managed resource is deleted - either "Delete" or "Orphan" the
            external resource.
            This field is planned to be deprecated in favor of the ManagementPolicies
            field in a future release. Currently, both could be set independently and
            non-default values would be honored if the feature flag is enabled.
            See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
            """
            return self._set("deletion_policy", value)

        @overload
        def for_provider(self, value_or_callback: ForProviderModel1, /) -> "DBSpec.Builder": ...

        @overload
        def for_provider(
            self,
            value_or_callback: Callable[
                [ForProviderModel1.Builder],
                ForProviderModel1.Builder | ForProviderModel1,
            ],
            /,
        ) -> "DBSpec.Builder": ...

        @overload
        def for_provider(
            self, value_or_callback: Never = ...
        ) -> "ForProviderModel1.BuilderContext": ...

        def for_provider(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ForProviderModel1.BuilderContext()
                context._parent_builder = self
                context._field_name = "for_provider"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ForProviderModel1.builder())
                if isinstance(output, ForProviderModel1.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("for_provider", value)

        @overload
        def init_provider(
            self, value_or_callback: Optional[InitProviderModel1], /
        ) -> "DBSpec.Builder": ...

        @overload
        def init_provider(
            self,
            value_or_callback: Callable[
                [InitProviderModel1.Builder],
                InitProviderModel1.Builder | InitProviderModel1,
            ],
            /,
        ) -> "DBSpec.Builder": ...

        @overload
        def init_provider(
            self, value_or_callback: Never = ...
        ) -> "InitProviderModel1.BuilderContext": ...

        def init_provider(self, value_or_callback=None, /):
            """
            THIS IS A BETA FIELD. It will be honored
            unless the Management Policies feature flag is disabled.
            InitProvider holds the same fields as ForProvider, with the exception
            of Identifier and other resource reference fields. The fields that are
            in InitProvider are merged into ForProvider when the resource is created.
            The same fields are also added to the terraform ignore_changes hook, to
            avoid updating them after creation. This is useful for fields that are
            required on creation, but we do not desire to update them after creation,
            for example because of an external controller is managing them, like an
            autoscaler.
            """
            if self._in_context and value_or_callback is None:
                context = InitProviderModel1.BuilderContext()
                context._parent_builder = self
                context._field_name = "init_provider"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(InitProviderModel1.builder())
                if isinstance(output, InitProviderModel1.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("init_provider", value)

        def management_policies(
            self,
            value: Optional[
                List[Literal["Observe", "Create", "Update", "Delete", "LateInitialize", "*"]]
            ],
            /,
        ) -> Self:
            """
            THIS IS A BETA FIELD. It is on by default but can be opted out
            through a Crossplane feature flag.
            ManagementPolicies specify the array of actions Crossplane is allowed to
            take on the managed and external resources.
            This field is planned to replace the DeletionPolicy field in a future
            release. Currently, both could be set independently and non-default
            values would be honored if the feature flag is enabled. If both are
            custom, the DeletionPolicy field will be ignored.
            See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
            and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
            """
            return self._set("management_policies", value)

        @overload
        def provider_config_ref(
            self, value_or_callback: Optional[ProviderConfigRef], /
        ) -> "DBSpec.Builder": ...

        @overload
        def provider_config_ref(
            self,
            value_or_callback: Callable[
                [ProviderConfigRef.Builder],
                ProviderConfigRef.Builder | ProviderConfigRef,
            ],
            /,
        ) -> "DBSpec.Builder": ...

        @overload
        def provider_config_ref(
            self, value_or_callback: Never = ...
        ) -> "ProviderConfigRef.BuilderContext": ...

        def provider_config_ref(self, value_or_callback=None, /):
            """
            ProviderConfigReference specifies how the provider that will be used to
            create, observe, update, and delete this managed resource should be
            configured.
            """
            if self._in_context and value_or_callback is None:
                context = ProviderConfigRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "provider_config_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ProviderConfigRef.builder())
                if isinstance(output, ProviderConfigRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("provider_config_ref", value)

        @overload
        def publish_connection_details_to(
            self, value_or_callback: Optional[PublishConnectionDetailsTo], /
        ) -> "DBSpec.Builder": ...

        @overload
        def publish_connection_details_to(
            self,
            value_or_callback: Callable[
                [PublishConnectionDetailsTo.Builder],
                PublishConnectionDetailsTo.Builder | PublishConnectionDetailsTo,
            ],
            /,
        ) -> "DBSpec.Builder": ...

        @overload
        def publish_connection_details_to(
            self, value_or_callback: Never = ...
        ) -> "PublishConnectionDetailsTo.BuilderContext": ...

        def publish_connection_details_to(self, value_or_callback=None, /):
            """
            PublishConnectionDetailsTo specifies the connection secret config which
            contains a name, metadata and a reference to secret store config to
            which any connection details for this managed resource should be written.
            Connection details frequently include the endpoint, username,
            and password required to connect to the managed resource.
            """
            if self._in_context and value_or_callback is None:
                context = PublishConnectionDetailsTo.BuilderContext()
                context._parent_builder = self
                context._field_name = "publish_connection_details_to"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PublishConnectionDetailsTo.builder())
                if isinstance(output, PublishConnectionDetailsTo.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("publish_connection_details_to", value)

        @overload
        def write_connection_secret_to_ref(
            self, value_or_callback: Optional[WriteConnectionSecretToRef], /
        ) -> "DBSpec.Builder": ...

        @overload
        def write_connection_secret_to_ref(
            self,
            value_or_callback: Callable[
                [WriteConnectionSecretToRef.Builder],
                WriteConnectionSecretToRef.Builder | WriteConnectionSecretToRef,
            ],
            /,
        ) -> "DBSpec.Builder": ...

        @overload
        def write_connection_secret_to_ref(
            self, value_or_callback: Never = ...
        ) -> "WriteConnectionSecretToRef.BuilderContext": ...

        def write_connection_secret_to_ref(self, value_or_callback=None, /):
            """
            WriteConnectionSecretToReference specifies the namespace and name of a
            Secret to which any connection details for this managed resource should
            be written. Connection details frequently include the endpoint, username,
            and password required to connect to the managed resource.
            This field is planned to be replaced in a future release in favor of
            PublishConnectionDetailsTo. Currently, both could be set independently
            and connection details would be published to both without affecting
            each other.
            """
            if self._in_context and value_or_callback is None:
                context = WriteConnectionSecretToRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "write_connection_secret_to_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(WriteConnectionSecretToRef.builder())
                if isinstance(output, WriteConnectionSecretToRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("write_connection_secret_to_ref", value)

    class BuilderContext(BuilderContextBase["DBSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DBSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DBSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["DBSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use DBSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    deletion_policy: Annotated[
        Optional[Literal["Orphan", "Delete"]], Field(alias="deletionPolicy")
    ] = "Delete"
    """
    DeletionPolicy specifies what will happen to the underlying external
    when this managed resource is deleted - either "Delete" or "Orphan" the
    external resource.
    This field is planned to be deprecated in favor of the ManagementPolicies
    field in a future release. Currently, both could be set independently and
    non-default values would be honored if the feature flag is enabled.
    See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    """
    for_provider: Annotated[ForProviderModel1, Field(alias="forProvider")]
    init_provider: Annotated[Optional[InitProviderModel1], Field(alias="initProvider")] = None
    """
    THIS IS A BETA FIELD. It will be honored
    unless the Management Policies feature flag is disabled.
    InitProvider holds the same fields as ForProvider, with the exception
    of Identifier and other resource reference fields. The fields that are
    in InitProvider are merged into ForProvider when the resource is created.
    The same fields are also added to the terraform ignore_changes hook, to
    avoid updating them after creation. This is useful for fields that are
    required on creation, but we do not desire to update them after creation,
    for example because of an external controller is managing them, like an
    autoscaler.
    """
    management_policies: Annotated[
        Optional[List[Literal["Observe", "Create", "Update", "Delete", "LateInitialize", "*"]]],
        Field(alias="managementPolicies"),
    ] = ["*"]
    """
    THIS IS A BETA FIELD. It is on by default but can be opted out
    through a Crossplane feature flag.
    ManagementPolicies specify the array of actions Crossplane is allowed to
    take on the managed and external resources.
    This field is planned to replace the DeletionPolicy field in a future
    release. Currently, both could be set independently and non-default
    values would be honored if the feature flag is enabled. If both are
    custom, the DeletionPolicy field will be ignored.
    See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
    """
    provider_config_ref: Annotated[
        Optional[ProviderConfigRef],
        Field(
            default_factory=lambda: ProviderConfigRef.model_validate({"name": "default"}),
            alias="providerConfigRef",
        ),
    ] = {"name": "default"}
    """
    ProviderConfigReference specifies how the provider that will be used to
    create, observe, update, and delete this managed resource should be
    configured.
    """
    publish_connection_details_to: Annotated[
        Optional[PublishConnectionDetailsTo], Field(alias="publishConnectionDetailsTo")
    ] = None
    """
    PublishConnectionDetailsTo specifies the connection secret config which
    contains a name, metadata and a reference to secret store config to
    which any connection details for this managed resource should be written.
    Connection details frequently include the endpoint, username,
    and password required to connect to the managed resource.
    """
    write_connection_secret_to_ref: Annotated[
        Optional[WriteConnectionSecretToRef], Field(alias="writeConnectionSecretToRef")
    ] = None
    """
    WriteConnectionSecretToReference specifies the namespace and name of a
    Secret to which any connection details for this managed resource should
    be written. Connection details frequently include the endpoint, username,
    and password required to connect to the managed resource.
    This field is planned to be replaced in a future release in favor of
    PublishConnectionDetailsTo. Currently, both could be set independently
    and connection details would be published to both without affecting
    each other.
    """


class AtProviderModel1(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AtProviderModel1"]:
            return AtProviderModel1

        def build(self) -> "AtProviderModel1":
            return AtProviderModel1(**self._attrs)

        def cluster_id(self, value: Optional[str], /) -> Self:
            """
            The ID of the original source database cluster.
            """
            return self._set("cluster_id", value)

        def id(self, value: Optional[str], /) -> Self:
            return self._set("id", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            The name for the database.
            """
            return self._set("name", value)

    class BuilderContext(BuilderContextBase["AtProviderModel1.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AtProviderModel1.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AtProviderModel1."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AtProviderModel1", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AtProviderModel1.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    cluster_id: Annotated[Optional[str], Field(alias="clusterId")] = None
    """
    The ID of the original source database cluster.
    """
    id: Optional[str] = None
    name: Optional[str] = None
    """
    The name for the database.
    """


class DBStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["DBStatus"]:
            return DBStatus

        def build(self) -> "DBStatus":
            return DBStatus(**self._attrs)

        @overload
        def at_provider(
            self, value_or_callback: Optional[AtProviderModel1], /
        ) -> "DBStatus.Builder": ...

        @overload
        def at_provider(
            self,
            value_or_callback: Callable[
                [AtProviderModel1.Builder], AtProviderModel1.Builder | AtProviderModel1
            ],
            /,
        ) -> "DBStatus.Builder": ...

        @overload
        def at_provider(
            self, value_or_callback: Never = ...
        ) -> "AtProviderModel1.BuilderContext": ...

        def at_provider(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = AtProviderModel1.BuilderContext()
                context._parent_builder = self
                context._field_name = "at_provider"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AtProviderModel1.builder())
                if isinstance(output, AtProviderModel1.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("at_provider", value)

        @overload
        def conditions(self, value_or_callback: List[Condition], /) -> "DBStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Condition, Condition.Builder]],
                GenericListBuilder[Condition, Condition.Builder] | List[Condition],
            ],
            /,
        ) -> "DBStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            """
            Conditions of the resource.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        def observed_generation(self, value: Optional[int], /) -> Self:
            """
            ObservedGeneration is the latest metadata.generation
            which resulted in either a ready state, or stalled due to error
            it can not recover from without human intervention.
            """
            return self._set("observed_generation", value)

    class BuilderContext(BuilderContextBase["DBStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DBStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DBStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["DBStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use DBStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    at_provider: Annotated[Optional[AtProviderModel1], Field(alias="atProvider")] = None
    conditions: Optional[List[Condition]] = None
    """
    Conditions of the resource.
    """
    observed_generation: Annotated[Optional[int], Field(alias="observedGeneration")] = None
    """
    ObservedGeneration is the latest metadata.generation
    which resulted in either a ready state, or stalled due to error
    it can not recover from without human intervention.
    """


class Rule(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Rule"]:
            return Rule

        def build(self) -> "Rule":
            return Rule(**self._attrs)

        def type(self, value: Optional[str], /) -> Self:
            """
            The type of resource that the firewall rule allows to access the database cluster. The possible values are: droplet, k8s, ip_addr, tag, or app.
            """
            return self._set("type", value)

        def value(self, value: Optional[str], /) -> Self:
            """
            The ID of the specific resource, the name of a tag applied to a group of resources, or the IP address that the firewall rule allows to access the database cluster.
            """
            return self._set("value", value)

    class BuilderContext(BuilderContextBase["Rule.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Rule.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Rule."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Rule", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Rule.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    type: Optional[str] = None
    """
    The type of resource that the firewall rule allows to access the database cluster. The possible values are: droplet, k8s, ip_addr, tag, or app.
    """
    value: Optional[str] = None
    """
    The ID of the specific resource, the name of a tag applied to a group of resources, or the IP address that the firewall rule allows to access the database cluster.
    """


class ForProviderModel2(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ForProviderModel2"]:
            return ForProviderModel2

        def build(self) -> "ForProviderModel2":
            return ForProviderModel2(**self._attrs)

        def cluster_id(self, value: Optional[str], /) -> Self:
            """
            The ID of the target database cluster.
            """
            return self._set("cluster_id", value)

        @overload
        def cluster_id_ref(
            self, value_or_callback: Optional[ClusterIdRef], /
        ) -> "ForProviderModel2.Builder": ...

        @overload
        def cluster_id_ref(
            self,
            value_or_callback: Callable[
                [ClusterIdRef.Builder], ClusterIdRef.Builder | ClusterIdRef
            ],
            /,
        ) -> "ForProviderModel2.Builder": ...

        @overload
        def cluster_id_ref(
            self, value_or_callback: Never = ...
        ) -> "ClusterIdRef.BuilderContext": ...

        def cluster_id_ref(self, value_or_callback=None, /):
            """
            Reference to a Cluster in database to populate clusterId.
            """
            if self._in_context and value_or_callback is None:
                context = ClusterIdRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "cluster_id_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ClusterIdRef.builder())
                if isinstance(output, ClusterIdRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("cluster_id_ref", value)

        @overload
        def cluster_id_selector(
            self, value_or_callback: Optional[ClusterIdSelector], /
        ) -> "ForProviderModel2.Builder": ...

        @overload
        def cluster_id_selector(
            self,
            value_or_callback: Callable[
                [ClusterIdSelector.Builder],
                ClusterIdSelector.Builder | ClusterIdSelector,
            ],
            /,
        ) -> "ForProviderModel2.Builder": ...

        @overload
        def cluster_id_selector(
            self, value_or_callback: Never = ...
        ) -> "ClusterIdSelector.BuilderContext": ...

        def cluster_id_selector(self, value_or_callback=None, /):
            """
            Selector for a Cluster in database to populate clusterId.
            """
            if self._in_context and value_or_callback is None:
                context = ClusterIdSelector.BuilderContext()
                context._parent_builder = self
                context._field_name = "cluster_id_selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ClusterIdSelector.builder())
                if isinstance(output, ClusterIdSelector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("cluster_id_selector", value)

        @overload
        def rule(self, value_or_callback: List[Rule], /) -> "ForProviderModel2.Builder": ...

        @overload
        def rule(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Rule, Rule.Builder]],
                GenericListBuilder[Rule, Rule.Builder] | List[Rule],
            ],
            /,
        ) -> "ForProviderModel2.Builder": ...

        @overload
        def rule(self, value_or_callback: Never = ...) -> ListBuilderContext[Rule.Builder]: ...

        def rule(self, value_or_callback=None, /):
            """
            A rule specifying a resource allowed to access the database cluster. The following arguments must be specified:
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Rule.Builder]()
                context._parent_builder = self
                context._field_name = "rule"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Rule.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("rule", value)

    class BuilderContext(BuilderContextBase["ForProviderModel2.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ForProviderModel2.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ForProviderModel2."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ForProviderModel2", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ForProviderModel2.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    cluster_id: Annotated[Optional[str], Field(alias="clusterId")] = None
    """
    The ID of the target database cluster.
    """
    cluster_id_ref: Annotated[Optional[ClusterIdRef], Field(alias="clusterIdRef")] = None
    """
    Reference to a Cluster in database to populate clusterId.
    """
    cluster_id_selector: Annotated[
        Optional[ClusterIdSelector], Field(alias="clusterIdSelector")
    ] = None
    """
    Selector for a Cluster in database to populate clusterId.
    """
    rule: Optional[List[Rule]] = None
    """
    A rule specifying a resource allowed to access the database cluster. The following arguments must be specified:
    """


class InitProviderModel2(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["InitProviderModel2"]:
            return InitProviderModel2

        def build(self) -> "InitProviderModel2":
            return InitProviderModel2(**self._attrs)

        def cluster_id(self, value: Optional[str], /) -> Self:
            """
            The ID of the target database cluster.
            """
            return self._set("cluster_id", value)

        @overload
        def cluster_id_ref(
            self, value_or_callback: Optional[ClusterIdRef], /
        ) -> "InitProviderModel2.Builder": ...

        @overload
        def cluster_id_ref(
            self,
            value_or_callback: Callable[
                [ClusterIdRef.Builder], ClusterIdRef.Builder | ClusterIdRef
            ],
            /,
        ) -> "InitProviderModel2.Builder": ...

        @overload
        def cluster_id_ref(
            self, value_or_callback: Never = ...
        ) -> "ClusterIdRef.BuilderContext": ...

        def cluster_id_ref(self, value_or_callback=None, /):
            """
            Reference to a Cluster in database to populate clusterId.
            """
            if self._in_context and value_or_callback is None:
                context = ClusterIdRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "cluster_id_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ClusterIdRef.builder())
                if isinstance(output, ClusterIdRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("cluster_id_ref", value)

        @overload
        def cluster_id_selector(
            self, value_or_callback: Optional[ClusterIdSelector], /
        ) -> "InitProviderModel2.Builder": ...

        @overload
        def cluster_id_selector(
            self,
            value_or_callback: Callable[
                [ClusterIdSelector.Builder],
                ClusterIdSelector.Builder | ClusterIdSelector,
            ],
            /,
        ) -> "InitProviderModel2.Builder": ...

        @overload
        def cluster_id_selector(
            self, value_or_callback: Never = ...
        ) -> "ClusterIdSelector.BuilderContext": ...

        def cluster_id_selector(self, value_or_callback=None, /):
            """
            Selector for a Cluster in database to populate clusterId.
            """
            if self._in_context and value_or_callback is None:
                context = ClusterIdSelector.BuilderContext()
                context._parent_builder = self
                context._field_name = "cluster_id_selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ClusterIdSelector.builder())
                if isinstance(output, ClusterIdSelector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("cluster_id_selector", value)

        @overload
        def rule(self, value_or_callback: List[Rule], /) -> "InitProviderModel2.Builder": ...

        @overload
        def rule(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Rule, Rule.Builder]],
                GenericListBuilder[Rule, Rule.Builder] | List[Rule],
            ],
            /,
        ) -> "InitProviderModel2.Builder": ...

        @overload
        def rule(self, value_or_callback: Never = ...) -> ListBuilderContext[Rule.Builder]: ...

        def rule(self, value_or_callback=None, /):
            """
            A rule specifying a resource allowed to access the database cluster. The following arguments must be specified:
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Rule.Builder]()
                context._parent_builder = self
                context._field_name = "rule"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Rule.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("rule", value)

    class BuilderContext(BuilderContextBase["InitProviderModel2.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = InitProviderModel2.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for InitProviderModel2."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["InitProviderModel2", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use InitProviderModel2.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    cluster_id: Annotated[Optional[str], Field(alias="clusterId")] = None
    """
    The ID of the target database cluster.
    """
    cluster_id_ref: Annotated[Optional[ClusterIdRef], Field(alias="clusterIdRef")] = None
    """
    Reference to a Cluster in database to populate clusterId.
    """
    cluster_id_selector: Annotated[
        Optional[ClusterIdSelector], Field(alias="clusterIdSelector")
    ] = None
    """
    Selector for a Cluster in database to populate clusterId.
    """
    rule: Optional[List[Rule]] = None
    """
    A rule specifying a resource allowed to access the database cluster. The following arguments must be specified:
    """


class FirewallSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["FirewallSpec"]:
            return FirewallSpec

        def build(self) -> "FirewallSpec":
            return FirewallSpec(**self._attrs)

        def deletion_policy(self, value: Optional[Literal["Orphan", "Delete"]], /) -> Self:
            """
            DeletionPolicy specifies what will happen to the underlying external
            when this managed resource is deleted - either "Delete" or "Orphan" the
            external resource.
            This field is planned to be deprecated in favor of the ManagementPolicies
            field in a future release. Currently, both could be set independently and
            non-default values would be honored if the feature flag is enabled.
            See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
            """
            return self._set("deletion_policy", value)

        @overload
        def for_provider(
            self, value_or_callback: ForProviderModel2, /
        ) -> "FirewallSpec.Builder": ...

        @overload
        def for_provider(
            self,
            value_or_callback: Callable[
                [ForProviderModel2.Builder],
                ForProviderModel2.Builder | ForProviderModel2,
            ],
            /,
        ) -> "FirewallSpec.Builder": ...

        @overload
        def for_provider(
            self, value_or_callback: Never = ...
        ) -> "ForProviderModel2.BuilderContext": ...

        def for_provider(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ForProviderModel2.BuilderContext()
                context._parent_builder = self
                context._field_name = "for_provider"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ForProviderModel2.builder())
                if isinstance(output, ForProviderModel2.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("for_provider", value)

        @overload
        def init_provider(
            self, value_or_callback: Optional[InitProviderModel2], /
        ) -> "FirewallSpec.Builder": ...

        @overload
        def init_provider(
            self,
            value_or_callback: Callable[
                [InitProviderModel2.Builder],
                InitProviderModel2.Builder | InitProviderModel2,
            ],
            /,
        ) -> "FirewallSpec.Builder": ...

        @overload
        def init_provider(
            self, value_or_callback: Never = ...
        ) -> "InitProviderModel2.BuilderContext": ...

        def init_provider(self, value_or_callback=None, /):
            """
            THIS IS A BETA FIELD. It will be honored
            unless the Management Policies feature flag is disabled.
            InitProvider holds the same fields as ForProvider, with the exception
            of Identifier and other resource reference fields. The fields that are
            in InitProvider are merged into ForProvider when the resource is created.
            The same fields are also added to the terraform ignore_changes hook, to
            avoid updating them after creation. This is useful for fields that are
            required on creation, but we do not desire to update them after creation,
            for example because of an external controller is managing them, like an
            autoscaler.
            """
            if self._in_context and value_or_callback is None:
                context = InitProviderModel2.BuilderContext()
                context._parent_builder = self
                context._field_name = "init_provider"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(InitProviderModel2.builder())
                if isinstance(output, InitProviderModel2.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("init_provider", value)

        def management_policies(
            self,
            value: Optional[
                List[Literal["Observe", "Create", "Update", "Delete", "LateInitialize", "*"]]
            ],
            /,
        ) -> Self:
            """
            THIS IS A BETA FIELD. It is on by default but can be opted out
            through a Crossplane feature flag.
            ManagementPolicies specify the array of actions Crossplane is allowed to
            take on the managed and external resources.
            This field is planned to replace the DeletionPolicy field in a future
            release. Currently, both could be set independently and non-default
            values would be honored if the feature flag is enabled. If both are
            custom, the DeletionPolicy field will be ignored.
            See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
            and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
            """
            return self._set("management_policies", value)

        @overload
        def provider_config_ref(
            self, value_or_callback: Optional[ProviderConfigRef], /
        ) -> "FirewallSpec.Builder": ...

        @overload
        def provider_config_ref(
            self,
            value_or_callback: Callable[
                [ProviderConfigRef.Builder],
                ProviderConfigRef.Builder | ProviderConfigRef,
            ],
            /,
        ) -> "FirewallSpec.Builder": ...

        @overload
        def provider_config_ref(
            self, value_or_callback: Never = ...
        ) -> "ProviderConfigRef.BuilderContext": ...

        def provider_config_ref(self, value_or_callback=None, /):
            """
            ProviderConfigReference specifies how the provider that will be used to
            create, observe, update, and delete this managed resource should be
            configured.
            """
            if self._in_context and value_or_callback is None:
                context = ProviderConfigRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "provider_config_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ProviderConfigRef.builder())
                if isinstance(output, ProviderConfigRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("provider_config_ref", value)

        @overload
        def publish_connection_details_to(
            self, value_or_callback: Optional[PublishConnectionDetailsTo], /
        ) -> "FirewallSpec.Builder": ...

        @overload
        def publish_connection_details_to(
            self,
            value_or_callback: Callable[
                [PublishConnectionDetailsTo.Builder],
                PublishConnectionDetailsTo.Builder | PublishConnectionDetailsTo,
            ],
            /,
        ) -> "FirewallSpec.Builder": ...

        @overload
        def publish_connection_details_to(
            self, value_or_callback: Never = ...
        ) -> "PublishConnectionDetailsTo.BuilderContext": ...

        def publish_connection_details_to(self, value_or_callback=None, /):
            """
            PublishConnectionDetailsTo specifies the connection secret config which
            contains a name, metadata and a reference to secret store config to
            which any connection details for this managed resource should be written.
            Connection details frequently include the endpoint, username,
            and password required to connect to the managed resource.
            """
            if self._in_context and value_or_callback is None:
                context = PublishConnectionDetailsTo.BuilderContext()
                context._parent_builder = self
                context._field_name = "publish_connection_details_to"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PublishConnectionDetailsTo.builder())
                if isinstance(output, PublishConnectionDetailsTo.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("publish_connection_details_to", value)

        @overload
        def write_connection_secret_to_ref(
            self, value_or_callback: Optional[WriteConnectionSecretToRef], /
        ) -> "FirewallSpec.Builder": ...

        @overload
        def write_connection_secret_to_ref(
            self,
            value_or_callback: Callable[
                [WriteConnectionSecretToRef.Builder],
                WriteConnectionSecretToRef.Builder | WriteConnectionSecretToRef,
            ],
            /,
        ) -> "FirewallSpec.Builder": ...

        @overload
        def write_connection_secret_to_ref(
            self, value_or_callback: Never = ...
        ) -> "WriteConnectionSecretToRef.BuilderContext": ...

        def write_connection_secret_to_ref(self, value_or_callback=None, /):
            """
            WriteConnectionSecretToReference specifies the namespace and name of a
            Secret to which any connection details for this managed resource should
            be written. Connection details frequently include the endpoint, username,
            and password required to connect to the managed resource.
            This field is planned to be replaced in a future release in favor of
            PublishConnectionDetailsTo. Currently, both could be set independently
            and connection details would be published to both without affecting
            each other.
            """
            if self._in_context and value_or_callback is None:
                context = WriteConnectionSecretToRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "write_connection_secret_to_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(WriteConnectionSecretToRef.builder())
                if isinstance(output, WriteConnectionSecretToRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("write_connection_secret_to_ref", value)

    class BuilderContext(BuilderContextBase["FirewallSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = FirewallSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for FirewallSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["FirewallSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use FirewallSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    deletion_policy: Annotated[
        Optional[Literal["Orphan", "Delete"]], Field(alias="deletionPolicy")
    ] = "Delete"
    """
    DeletionPolicy specifies what will happen to the underlying external
    when this managed resource is deleted - either "Delete" or "Orphan" the
    external resource.
    This field is planned to be deprecated in favor of the ManagementPolicies
    field in a future release. Currently, both could be set independently and
    non-default values would be honored if the feature flag is enabled.
    See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    """
    for_provider: Annotated[ForProviderModel2, Field(alias="forProvider")]
    init_provider: Annotated[Optional[InitProviderModel2], Field(alias="initProvider")] = None
    """
    THIS IS A BETA FIELD. It will be honored
    unless the Management Policies feature flag is disabled.
    InitProvider holds the same fields as ForProvider, with the exception
    of Identifier and other resource reference fields. The fields that are
    in InitProvider are merged into ForProvider when the resource is created.
    The same fields are also added to the terraform ignore_changes hook, to
    avoid updating them after creation. This is useful for fields that are
    required on creation, but we do not desire to update them after creation,
    for example because of an external controller is managing them, like an
    autoscaler.
    """
    management_policies: Annotated[
        Optional[List[Literal["Observe", "Create", "Update", "Delete", "LateInitialize", "*"]]],
        Field(alias="managementPolicies"),
    ] = ["*"]
    """
    THIS IS A BETA FIELD. It is on by default but can be opted out
    through a Crossplane feature flag.
    ManagementPolicies specify the array of actions Crossplane is allowed to
    take on the managed and external resources.
    This field is planned to replace the DeletionPolicy field in a future
    release. Currently, both could be set independently and non-default
    values would be honored if the feature flag is enabled. If both are
    custom, the DeletionPolicy field will be ignored.
    See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
    """
    provider_config_ref: Annotated[
        Optional[ProviderConfigRef],
        Field(
            default_factory=lambda: ProviderConfigRef.model_validate({"name": "default"}),
            alias="providerConfigRef",
        ),
    ] = {"name": "default"}
    """
    ProviderConfigReference specifies how the provider that will be used to
    create, observe, update, and delete this managed resource should be
    configured.
    """
    publish_connection_details_to: Annotated[
        Optional[PublishConnectionDetailsTo], Field(alias="publishConnectionDetailsTo")
    ] = None
    """
    PublishConnectionDetailsTo specifies the connection secret config which
    contains a name, metadata and a reference to secret store config to
    which any connection details for this managed resource should be written.
    Connection details frequently include the endpoint, username,
    and password required to connect to the managed resource.
    """
    write_connection_secret_to_ref: Annotated[
        Optional[WriteConnectionSecretToRef], Field(alias="writeConnectionSecretToRef")
    ] = None
    """
    WriteConnectionSecretToReference specifies the namespace and name of a
    Secret to which any connection details for this managed resource should
    be written. Connection details frequently include the endpoint, username,
    and password required to connect to the managed resource.
    This field is planned to be replaced in a future release in favor of
    PublishConnectionDetailsTo. Currently, both could be set independently
    and connection details would be published to both without affecting
    each other.
    """


class RuleModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["RuleModel"]:
            return RuleModel

        def build(self) -> "RuleModel":
            return RuleModel(**self._attrs)

        def created_at(self, value: Optional[str], /) -> Self:
            """
            The date and time when the firewall rule was created.
            """
            return self._set("created_at", value)

        def type(self, value: Optional[str], /) -> Self:
            """
            The type of resource that the firewall rule allows to access the database cluster. The possible values are: droplet, k8s, ip_addr, tag, or app.
            """
            return self._set("type", value)

        def uuid(self, value: Optional[str], /) -> Self:
            """
            A unique identifier for the firewall rule.
            """
            return self._set("uuid", value)

        def value(self, value: Optional[str], /) -> Self:
            """
            The ID of the specific resource, the name of a tag applied to a group of resources, or the IP address that the firewall rule allows to access the database cluster.
            """
            return self._set("value", value)

    class BuilderContext(BuilderContextBase["RuleModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = RuleModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RuleModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["RuleModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use RuleModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    created_at: Annotated[Optional[str], Field(alias="createdAt")] = None
    """
    The date and time when the firewall rule was created.
    """
    type: Optional[str] = None
    """
    The type of resource that the firewall rule allows to access the database cluster. The possible values are: droplet, k8s, ip_addr, tag, or app.
    """
    uuid: Optional[str] = None
    """
    A unique identifier for the firewall rule.
    """
    value: Optional[str] = None
    """
    The ID of the specific resource, the name of a tag applied to a group of resources, or the IP address that the firewall rule allows to access the database cluster.
    """


class AtProviderModel2(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AtProviderModel2"]:
            return AtProviderModel2

        def build(self) -> "AtProviderModel2":
            return AtProviderModel2(**self._attrs)

        def cluster_id(self, value: Optional[str], /) -> Self:
            """
            The ID of the target database cluster.
            """
            return self._set("cluster_id", value)

        def id(self, value: Optional[str], /) -> Self:
            return self._set("id", value)

        @overload
        def rule(self, value_or_callback: List[RuleModel], /) -> "AtProviderModel2.Builder": ...

        @overload
        def rule(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[RuleModel, RuleModel.Builder]],
                GenericListBuilder[RuleModel, RuleModel.Builder] | List[RuleModel],
            ],
            /,
        ) -> "AtProviderModel2.Builder": ...

        @overload
        def rule(self, value_or_callback: Never = ...) -> ListBuilderContext[RuleModel.Builder]: ...

        def rule(self, value_or_callback=None, /):
            """
            A rule specifying a resource allowed to access the database cluster. The following arguments must be specified:
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[RuleModel.Builder]()
                context._parent_builder = self
                context._field_name = "rule"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(RuleModel.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("rule", value)

    class BuilderContext(BuilderContextBase["AtProviderModel2.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AtProviderModel2.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AtProviderModel2."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AtProviderModel2", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AtProviderModel2.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    cluster_id: Annotated[Optional[str], Field(alias="clusterId")] = None
    """
    The ID of the target database cluster.
    """
    id: Optional[str] = None
    rule: Optional[List[RuleModel]] = None
    """
    A rule specifying a resource allowed to access the database cluster. The following arguments must be specified:
    """


class FirewallStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["FirewallStatus"]:
            return FirewallStatus

        def build(self) -> "FirewallStatus":
            return FirewallStatus(**self._attrs)

        @overload
        def at_provider(
            self, value_or_callback: Optional[AtProviderModel2], /
        ) -> "FirewallStatus.Builder": ...

        @overload
        def at_provider(
            self,
            value_or_callback: Callable[
                [AtProviderModel2.Builder], AtProviderModel2.Builder | AtProviderModel2
            ],
            /,
        ) -> "FirewallStatus.Builder": ...

        @overload
        def at_provider(
            self, value_or_callback: Never = ...
        ) -> "AtProviderModel2.BuilderContext": ...

        def at_provider(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = AtProviderModel2.BuilderContext()
                context._parent_builder = self
                context._field_name = "at_provider"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AtProviderModel2.builder())
                if isinstance(output, AtProviderModel2.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("at_provider", value)

        @overload
        def conditions(self, value_or_callback: List[Condition], /) -> "FirewallStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Condition, Condition.Builder]],
                GenericListBuilder[Condition, Condition.Builder] | List[Condition],
            ],
            /,
        ) -> "FirewallStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            """
            Conditions of the resource.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        def observed_generation(self, value: Optional[int], /) -> Self:
            """
            ObservedGeneration is the latest metadata.generation
            which resulted in either a ready state, or stalled due to error
            it can not recover from without human intervention.
            """
            return self._set("observed_generation", value)

    class BuilderContext(BuilderContextBase["FirewallStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = FirewallStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for FirewallStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["FirewallStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use FirewallStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    at_provider: Annotated[Optional[AtProviderModel2], Field(alias="atProvider")] = None
    conditions: Optional[List[Condition]] = None
    """
    Conditions of the resource.
    """
    observed_generation: Annotated[Optional[int], Field(alias="observedGeneration")] = None
    """
    ObservedGeneration is the latest metadata.generation
    which resulted in either a ready state, or stalled due to error
    it can not recover from without human intervention.
    """


class Config(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Config"]:
            return Config

        def build(self) -> "Config":
            return Config(**self._attrs)

        def cleanup_policy(self, value: Optional[str], /) -> Self:
            """
            The topic cleanup policy that describes whether messages should be deleted, compacted, or both when retention policies are violated.
            This may be one of "delete", "compact", or "compact_delete".
            """
            return self._set("cleanup_policy", value)

        def compression_type(self, value: Optional[str], /) -> Self:
            """
            The topic compression codecs used for a given topic.
            This may be one of "uncompressed", "gzip", "snappy", "lz4", "producer", "zstd". "uncompressed" indicates that there is no compression and "producer" retains the original compression codec set by the producer.
            """
            return self._set("compression_type", value)

        def delete_retention_ms(self, value: Optional[str], /) -> Self:
            """
            The amount of time, in ms, that deleted records are retained.
            """
            return self._set("delete_retention_ms", value)

        def file_delete_delay_ms(self, value: Optional[str], /) -> Self:
            """
            The amount of time, in ms, to wait before deleting a topic log segment from the filesystem.
            """
            return self._set("file_delete_delay_ms", value)

        def flush_messages(self, value: Optional[str], /) -> Self:
            """
            The number of messages accumulated on a topic partition before they are flushed to disk.
            """
            return self._set("flush_messages", value)

        def flush_ms(self, value: Optional[str], /) -> Self:
            """
            The maximum time, in ms, that a topic is kept in memory before being flushed to disk.
            """
            return self._set("flush_ms", value)

        def index_interval_bytes(self, value: Optional[str], /) -> Self:
            """
            The interval, in bytes, in which entries are added to the offset index.
            """
            return self._set("index_interval_bytes", value)

        def max_compaction_lag_ms(self, value: Optional[str], /) -> Self:
            """
            The maximum time, in ms, that a particular message will remain uncompacted. This will not apply if the compression_type is set to "uncompressed" or it is set to producer and the producer is not using compression.
            """
            return self._set("max_compaction_lag_ms", value)

        def max_message_bytes(self, value: Optional[str], /) -> Self:
            """
            The maximum size, in bytes, of a message.
            """
            return self._set("max_message_bytes", value)

        def message_down_conversion_enable(self, value: Optional[bool], /) -> Self:
            """
            Determines whether down-conversion of message formats for consumers is enabled.
            """
            return self._set("message_down_conversion_enable", value)

        def message_format_version(self, value: Optional[str], /) -> Self:
            """
            The version of the inter-broker protocol that will be used. This may be one of "0.8.0", "0.8.1", "0.8.2", "0.9.0", "0.10.0", "0.10.0-IV0", "0.10.0-IV1", "0.10.1", "0.10.1-IV0", "0.10.1-IV1", "0.10.1-IV2", "0.10.2", "0.10.2-IV0", "0.11.0", "0.11.0-IV0", "0.11.0-IV1", "0.11.0-IV2", "1.0", "1.0-IV0", "1.1", "1.1-IV0", "2.0", "2.0-IV0", "2.0-IV1", "2.1", "2.1-IV0", "2.1-IV1", "2.1-IV2", "2.2", "2.2-IV0", "2.2-IV1", "2.3", "2.3-IV0", "2.3-IV1", "2.4", "2.4-IV0", "2.4-IV1", "2.5", "2.5-IV0", "2.6", "2.6-IV0", "2.7", "2.7-IV0", "2.7-IV1", "2.7-IV2", "2.8", "2.8-IV0", "2.8-IV1", "3.0", "3.0-IV0", "3.0-IV1", "3.1", "3.1-IV0", "3.2", "3.2-IV0", "3.3", "3.3-IV0", "3.3-IV1", "3.3-IV2", "3.3-IV3", "3.4", "3.4-IV0", "3.5", "3.5-IV0", "3.5-IV1", "3.5-IV2", "3.6", "3.6-IV0", "3.6-IV1", "3.6-IV2".
            """
            return self._set("message_format_version", value)

        def message_timestamp_difference_max_ms(self, value: Optional[str], /) -> Self:
            """
            The maximum difference, in ms, between the timestamp specific in a message and when the broker receives the message.
            """
            return self._set("message_timestamp_difference_max_ms", value)

        def message_timestamp_type(self, value: Optional[str], /) -> Self:
            """
            Specifies which timestamp to use for the message. This may be one of "create_time" or "log_append_time".
            """
            return self._set("message_timestamp_type", value)

        def min_cleanable_dirty_ratio(self, value: Optional[float], /) -> Self:
            """
            A scale between 0.0 and 1.0 which controls the frequency of the compactor. Larger values mean more frequent compactions. This is often paired with max_compaction_lag_ms to control the compactor frequency.
            """
            return self._set("min_cleanable_dirty_ratio", value)

        def min_compaction_lag_ms(self, value: Optional[str], /) -> Self:
            return self._set("min_compaction_lag_ms", value)

        def min_insync_replicas(self, value: Optional[float], /) -> Self:
            """
            The number of replicas that must acknowledge a write before it is considered successful. -1 is a special setting to indicate that all nodes must ack a message before a write is considered successful. Default is 1, indicating at least 1 replica must acknowledge a write to be considered successful.
            """
            return self._set("min_insync_replicas", value)

        def preallocate(self, value: Optional[bool], /) -> Self:
            """
            Determines whether to preallocate a file on disk when creating a new log segment within a topic.
            """
            return self._set("preallocate", value)

        def retention_bytes(self, value: Optional[str], /) -> Self:
            """
            The maximum size, in bytes, of a topic before messages are deleted. -1 is a special setting indicating that this setting has no limit.
            """
            return self._set("retention_bytes", value)

        def retention_ms(self, value: Optional[str], /) -> Self:
            """
            The maximum time, in ms, that a topic log file is retained before deleting it. -1 is a special setting indicating that this setting has no limit.
            """
            return self._set("retention_ms", value)

        def segment_bytes(self, value: Optional[str], /) -> Self:
            """
            The maximum size, in bytes, of a single topic log file.
            """
            return self._set("segment_bytes", value)

        def segment_index_bytes(self, value: Optional[str], /) -> Self:
            """
            The maximum size, in bytes, of the offset index.
            """
            return self._set("segment_index_bytes", value)

        def segment_jitter_ms(self, value: Optional[str], /) -> Self:
            """
            The maximum time, in ms, subtracted from the scheduled segment disk flush time to avoid the thundering herd problem for segment flushing.
            """
            return self._set("segment_jitter_ms", value)

        def segment_ms(self, value: Optional[str], /) -> Self:
            """
            The maximum time, in ms, before the topic log will flush to disk.
            """
            return self._set("segment_ms", value)

    class BuilderContext(BuilderContextBase["Config.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Config.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Config."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Config", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Config.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    cleanup_policy: Annotated[Optional[str], Field(alias="cleanupPolicy")] = None
    """
    The topic cleanup policy that describes whether messages should be deleted, compacted, or both when retention policies are violated.
    This may be one of "delete", "compact", or "compact_delete".
    """
    compression_type: Annotated[Optional[str], Field(alias="compressionType")] = None
    """
    The topic compression codecs used for a given topic.
    This may be one of "uncompressed", "gzip", "snappy", "lz4", "producer", "zstd". "uncompressed" indicates that there is no compression and "producer" retains the original compression codec set by the producer.
    """
    delete_retention_ms: Annotated[Optional[str], Field(alias="deleteRetentionMs")] = None
    """
    The amount of time, in ms, that deleted records are retained.
    """
    file_delete_delay_ms: Annotated[Optional[str], Field(alias="fileDeleteDelayMs")] = None
    """
    The amount of time, in ms, to wait before deleting a topic log segment from the filesystem.
    """
    flush_messages: Annotated[Optional[str], Field(alias="flushMessages")] = None
    """
    The number of messages accumulated on a topic partition before they are flushed to disk.
    """
    flush_ms: Annotated[Optional[str], Field(alias="flushMs")] = None
    """
    The maximum time, in ms, that a topic is kept in memory before being flushed to disk.
    """
    index_interval_bytes: Annotated[Optional[str], Field(alias="indexIntervalBytes")] = None
    """
    The interval, in bytes, in which entries are added to the offset index.
    """
    max_compaction_lag_ms: Annotated[Optional[str], Field(alias="maxCompactionLagMs")] = None
    """
    The maximum time, in ms, that a particular message will remain uncompacted. This will not apply if the compression_type is set to "uncompressed" or it is set to producer and the producer is not using compression.
    """
    max_message_bytes: Annotated[Optional[str], Field(alias="maxMessageBytes")] = None
    """
    The maximum size, in bytes, of a message.
    """
    message_down_conversion_enable: Annotated[
        Optional[bool], Field(alias="messageDownConversionEnable")
    ] = None
    """
    Determines whether down-conversion of message formats for consumers is enabled.
    """
    message_format_version: Annotated[Optional[str], Field(alias="messageFormatVersion")] = None
    """
    The version of the inter-broker protocol that will be used. This may be one of "0.8.0", "0.8.1", "0.8.2", "0.9.0", "0.10.0", "0.10.0-IV0", "0.10.0-IV1", "0.10.1", "0.10.1-IV0", "0.10.1-IV1", "0.10.1-IV2", "0.10.2", "0.10.2-IV0", "0.11.0", "0.11.0-IV0", "0.11.0-IV1", "0.11.0-IV2", "1.0", "1.0-IV0", "1.1", "1.1-IV0", "2.0", "2.0-IV0", "2.0-IV1", "2.1", "2.1-IV0", "2.1-IV1", "2.1-IV2", "2.2", "2.2-IV0", "2.2-IV1", "2.3", "2.3-IV0", "2.3-IV1", "2.4", "2.4-IV0", "2.4-IV1", "2.5", "2.5-IV0", "2.6", "2.6-IV0", "2.7", "2.7-IV0", "2.7-IV1", "2.7-IV2", "2.8", "2.8-IV0", "2.8-IV1", "3.0", "3.0-IV0", "3.0-IV1", "3.1", "3.1-IV0", "3.2", "3.2-IV0", "3.3", "3.3-IV0", "3.3-IV1", "3.3-IV2", "3.3-IV3", "3.4", "3.4-IV0", "3.5", "3.5-IV0", "3.5-IV1", "3.5-IV2", "3.6", "3.6-IV0", "3.6-IV1", "3.6-IV2".
    """
    message_timestamp_difference_max_ms: Annotated[
        Optional[str], Field(alias="messageTimestampDifferenceMaxMs")
    ] = None
    """
    The maximum difference, in ms, between the timestamp specific in a message and when the broker receives the message.
    """
    message_timestamp_type: Annotated[Optional[str], Field(alias="messageTimestampType")] = None
    """
    Specifies which timestamp to use for the message. This may be one of "create_time" or "log_append_time".
    """
    min_cleanable_dirty_ratio: Annotated[Optional[float], Field(alias="minCleanableDirtyRatio")] = (
        None
    )
    """
    A scale between 0.0 and 1.0 which controls the frequency of the compactor. Larger values mean more frequent compactions. This is often paired with max_compaction_lag_ms to control the compactor frequency.
    """
    min_compaction_lag_ms: Annotated[Optional[str], Field(alias="minCompactionLagMs")] = None
    min_insync_replicas: Annotated[Optional[float], Field(alias="minInsyncReplicas")] = None
    """
    The number of replicas that must acknowledge a write before it is considered successful. -1 is a special setting to indicate that all nodes must ack a message before a write is considered successful. Default is 1, indicating at least 1 replica must acknowledge a write to be considered successful.
    """
    preallocate: Optional[bool] = None
    """
    Determines whether to preallocate a file on disk when creating a new log segment within a topic.
    """
    retention_bytes: Annotated[Optional[str], Field(alias="retentionBytes")] = None
    """
    The maximum size, in bytes, of a topic before messages are deleted. -1 is a special setting indicating that this setting has no limit.
    """
    retention_ms: Annotated[Optional[str], Field(alias="retentionMs")] = None
    """
    The maximum time, in ms, that a topic log file is retained before deleting it. -1 is a special setting indicating that this setting has no limit.
    """
    segment_bytes: Annotated[Optional[str], Field(alias="segmentBytes")] = None
    """
    The maximum size, in bytes, of a single topic log file.
    """
    segment_index_bytes: Annotated[Optional[str], Field(alias="segmentIndexBytes")] = None
    """
    The maximum size, in bytes, of the offset index.
    """
    segment_jitter_ms: Annotated[Optional[str], Field(alias="segmentJitterMs")] = None
    """
    The maximum time, in ms, subtracted from the scheduled segment disk flush time to avoid the thundering herd problem for segment flushing.
    """
    segment_ms: Annotated[Optional[str], Field(alias="segmentMs")] = None
    """
    The maximum time, in ms, before the topic log will flush to disk.
    """


class ForProviderModel3(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ForProviderModel3"]:
            return ForProviderModel3

        def build(self) -> "ForProviderModel3":
            return ForProviderModel3(**self._attrs)

        def cluster_id(self, value: Optional[str], /) -> Self:
            """
            The ID of the source database cluster. Note: This must be a Kafka cluster.
            """
            return self._set("cluster_id", value)

        @overload
        def cluster_id_ref(
            self, value_or_callback: Optional[ClusterIdRef], /
        ) -> "ForProviderModel3.Builder": ...

        @overload
        def cluster_id_ref(
            self,
            value_or_callback: Callable[
                [ClusterIdRef.Builder], ClusterIdRef.Builder | ClusterIdRef
            ],
            /,
        ) -> "ForProviderModel3.Builder": ...

        @overload
        def cluster_id_ref(
            self, value_or_callback: Never = ...
        ) -> "ClusterIdRef.BuilderContext": ...

        def cluster_id_ref(self, value_or_callback=None, /):
            """
            Reference to a Cluster in database to populate clusterId.
            """
            if self._in_context and value_or_callback is None:
                context = ClusterIdRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "cluster_id_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ClusterIdRef.builder())
                if isinstance(output, ClusterIdRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("cluster_id_ref", value)

        @overload
        def cluster_id_selector(
            self, value_or_callback: Optional[ClusterIdSelector], /
        ) -> "ForProviderModel3.Builder": ...

        @overload
        def cluster_id_selector(
            self,
            value_or_callback: Callable[
                [ClusterIdSelector.Builder],
                ClusterIdSelector.Builder | ClusterIdSelector,
            ],
            /,
        ) -> "ForProviderModel3.Builder": ...

        @overload
        def cluster_id_selector(
            self, value_or_callback: Never = ...
        ) -> "ClusterIdSelector.BuilderContext": ...

        def cluster_id_selector(self, value_or_callback=None, /):
            """
            Selector for a Cluster in database to populate clusterId.
            """
            if self._in_context and value_or_callback is None:
                context = ClusterIdSelector.BuilderContext()
                context._parent_builder = self
                context._field_name = "cluster_id_selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ClusterIdSelector.builder())
                if isinstance(output, ClusterIdSelector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("cluster_id_selector", value)

        @overload
        def config(self, value_or_callback: List[Config], /) -> "ForProviderModel3.Builder": ...

        @overload
        def config(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Config, Config.Builder]],
                GenericListBuilder[Config, Config.Builder] | List[Config],
            ],
            /,
        ) -> "ForProviderModel3.Builder": ...

        @overload
        def config(self, value_or_callback: Never = ...) -> ListBuilderContext[Config.Builder]: ...

        def config(self, value_or_callback=None, /):
            """
            A set of advanced configuration parameters. Defaults will be set for any of the parameters that are not included.
            The config block is documented below.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Config.Builder]()
                context._parent_builder = self
                context._field_name = "config"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Config.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("config", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            The name for the topic.
            """
            return self._set("name", value)

        def partition_count(self, value: Optional[float], /) -> Self:
            """
            The number of partitions for the topic. Default and minimum set at 3, maximum is 2048.
            """
            return self._set("partition_count", value)

        def replication_factor(self, value: Optional[float], /) -> Self:
            """
            The number of nodes that topics are replicated across. Default and minimum set at 2, maximum is the number of nodes in the cluster.
            """
            return self._set("replication_factor", value)

    class BuilderContext(BuilderContextBase["ForProviderModel3.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ForProviderModel3.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ForProviderModel3."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ForProviderModel3", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ForProviderModel3.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    cluster_id: Annotated[Optional[str], Field(alias="clusterId")] = None
    """
    The ID of the source database cluster. Note: This must be a Kafka cluster.
    """
    cluster_id_ref: Annotated[Optional[ClusterIdRef], Field(alias="clusterIdRef")] = None
    """
    Reference to a Cluster in database to populate clusterId.
    """
    cluster_id_selector: Annotated[
        Optional[ClusterIdSelector], Field(alias="clusterIdSelector")
    ] = None
    """
    Selector for a Cluster in database to populate clusterId.
    """
    config: Optional[List[Config]] = None
    """
    A set of advanced configuration parameters. Defaults will be set for any of the parameters that are not included.
    The config block is documented below.
    """
    name: Optional[str] = None
    """
    The name for the topic.
    """
    partition_count: Annotated[Optional[float], Field(alias="partitionCount")] = None
    """
    The number of partitions for the topic. Default and minimum set at 3, maximum is 2048.
    """
    replication_factor: Annotated[Optional[float], Field(alias="replicationFactor")] = None
    """
    The number of nodes that topics are replicated across. Default and minimum set at 2, maximum is the number of nodes in the cluster.
    """


class InitProviderModel3(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["InitProviderModel3"]:
            return InitProviderModel3

        def build(self) -> "InitProviderModel3":
            return InitProviderModel3(**self._attrs)

        def cluster_id(self, value: Optional[str], /) -> Self:
            """
            The ID of the source database cluster. Note: This must be a Kafka cluster.
            """
            return self._set("cluster_id", value)

        @overload
        def cluster_id_ref(
            self, value_or_callback: Optional[ClusterIdRef], /
        ) -> "InitProviderModel3.Builder": ...

        @overload
        def cluster_id_ref(
            self,
            value_or_callback: Callable[
                [ClusterIdRef.Builder], ClusterIdRef.Builder | ClusterIdRef
            ],
            /,
        ) -> "InitProviderModel3.Builder": ...

        @overload
        def cluster_id_ref(
            self, value_or_callback: Never = ...
        ) -> "ClusterIdRef.BuilderContext": ...

        def cluster_id_ref(self, value_or_callback=None, /):
            """
            Reference to a Cluster in database to populate clusterId.
            """
            if self._in_context and value_or_callback is None:
                context = ClusterIdRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "cluster_id_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ClusterIdRef.builder())
                if isinstance(output, ClusterIdRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("cluster_id_ref", value)

        @overload
        def cluster_id_selector(
            self, value_or_callback: Optional[ClusterIdSelector], /
        ) -> "InitProviderModel3.Builder": ...

        @overload
        def cluster_id_selector(
            self,
            value_or_callback: Callable[
                [ClusterIdSelector.Builder],
                ClusterIdSelector.Builder | ClusterIdSelector,
            ],
            /,
        ) -> "InitProviderModel3.Builder": ...

        @overload
        def cluster_id_selector(
            self, value_or_callback: Never = ...
        ) -> "ClusterIdSelector.BuilderContext": ...

        def cluster_id_selector(self, value_or_callback=None, /):
            """
            Selector for a Cluster in database to populate clusterId.
            """
            if self._in_context and value_or_callback is None:
                context = ClusterIdSelector.BuilderContext()
                context._parent_builder = self
                context._field_name = "cluster_id_selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ClusterIdSelector.builder())
                if isinstance(output, ClusterIdSelector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("cluster_id_selector", value)

        @overload
        def config(self, value_or_callback: List[Config], /) -> "InitProviderModel3.Builder": ...

        @overload
        def config(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Config, Config.Builder]],
                GenericListBuilder[Config, Config.Builder] | List[Config],
            ],
            /,
        ) -> "InitProviderModel3.Builder": ...

        @overload
        def config(self, value_or_callback: Never = ...) -> ListBuilderContext[Config.Builder]: ...

        def config(self, value_or_callback=None, /):
            """
            A set of advanced configuration parameters. Defaults will be set for any of the parameters that are not included.
            The config block is documented below.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Config.Builder]()
                context._parent_builder = self
                context._field_name = "config"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Config.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("config", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            The name for the topic.
            """
            return self._set("name", value)

        def partition_count(self, value: Optional[float], /) -> Self:
            """
            The number of partitions for the topic. Default and minimum set at 3, maximum is 2048.
            """
            return self._set("partition_count", value)

        def replication_factor(self, value: Optional[float], /) -> Self:
            """
            The number of nodes that topics are replicated across. Default and minimum set at 2, maximum is the number of nodes in the cluster.
            """
            return self._set("replication_factor", value)

    class BuilderContext(BuilderContextBase["InitProviderModel3.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = InitProviderModel3.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for InitProviderModel3."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["InitProviderModel3", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use InitProviderModel3.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    cluster_id: Annotated[Optional[str], Field(alias="clusterId")] = None
    """
    The ID of the source database cluster. Note: This must be a Kafka cluster.
    """
    cluster_id_ref: Annotated[Optional[ClusterIdRef], Field(alias="clusterIdRef")] = None
    """
    Reference to a Cluster in database to populate clusterId.
    """
    cluster_id_selector: Annotated[
        Optional[ClusterIdSelector], Field(alias="clusterIdSelector")
    ] = None
    """
    Selector for a Cluster in database to populate clusterId.
    """
    config: Optional[List[Config]] = None
    """
    A set of advanced configuration parameters. Defaults will be set for any of the parameters that are not included.
    The config block is documented below.
    """
    name: Optional[str] = None
    """
    The name for the topic.
    """
    partition_count: Annotated[Optional[float], Field(alias="partitionCount")] = None
    """
    The number of partitions for the topic. Default and minimum set at 3, maximum is 2048.
    """
    replication_factor: Annotated[Optional[float], Field(alias="replicationFactor")] = None
    """
    The number of nodes that topics are replicated across. Default and minimum set at 2, maximum is the number of nodes in the cluster.
    """


class KafkaTopicSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["KafkaTopicSpec"]:
            return KafkaTopicSpec

        def build(self) -> "KafkaTopicSpec":
            return KafkaTopicSpec(**self._attrs)

        def deletion_policy(self, value: Optional[Literal["Orphan", "Delete"]], /) -> Self:
            """
            DeletionPolicy specifies what will happen to the underlying external
            when this managed resource is deleted - either "Delete" or "Orphan" the
            external resource.
            This field is planned to be deprecated in favor of the ManagementPolicies
            field in a future release. Currently, both could be set independently and
            non-default values would be honored if the feature flag is enabled.
            See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
            """
            return self._set("deletion_policy", value)

        @overload
        def for_provider(
            self, value_or_callback: ForProviderModel3, /
        ) -> "KafkaTopicSpec.Builder": ...

        @overload
        def for_provider(
            self,
            value_or_callback: Callable[
                [ForProviderModel3.Builder],
                ForProviderModel3.Builder | ForProviderModel3,
            ],
            /,
        ) -> "KafkaTopicSpec.Builder": ...

        @overload
        def for_provider(
            self, value_or_callback: Never = ...
        ) -> "ForProviderModel3.BuilderContext": ...

        def for_provider(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ForProviderModel3.BuilderContext()
                context._parent_builder = self
                context._field_name = "for_provider"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ForProviderModel3.builder())
                if isinstance(output, ForProviderModel3.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("for_provider", value)

        @overload
        def init_provider(
            self, value_or_callback: Optional[InitProviderModel3], /
        ) -> "KafkaTopicSpec.Builder": ...

        @overload
        def init_provider(
            self,
            value_or_callback: Callable[
                [InitProviderModel3.Builder],
                InitProviderModel3.Builder | InitProviderModel3,
            ],
            /,
        ) -> "KafkaTopicSpec.Builder": ...

        @overload
        def init_provider(
            self, value_or_callback: Never = ...
        ) -> "InitProviderModel3.BuilderContext": ...

        def init_provider(self, value_or_callback=None, /):
            """
            THIS IS A BETA FIELD. It will be honored
            unless the Management Policies feature flag is disabled.
            InitProvider holds the same fields as ForProvider, with the exception
            of Identifier and other resource reference fields. The fields that are
            in InitProvider are merged into ForProvider when the resource is created.
            The same fields are also added to the terraform ignore_changes hook, to
            avoid updating them after creation. This is useful for fields that are
            required on creation, but we do not desire to update them after creation,
            for example because of an external controller is managing them, like an
            autoscaler.
            """
            if self._in_context and value_or_callback is None:
                context = InitProviderModel3.BuilderContext()
                context._parent_builder = self
                context._field_name = "init_provider"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(InitProviderModel3.builder())
                if isinstance(output, InitProviderModel3.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("init_provider", value)

        def management_policies(
            self,
            value: Optional[
                List[Literal["Observe", "Create", "Update", "Delete", "LateInitialize", "*"]]
            ],
            /,
        ) -> Self:
            """
            THIS IS A BETA FIELD. It is on by default but can be opted out
            through a Crossplane feature flag.
            ManagementPolicies specify the array of actions Crossplane is allowed to
            take on the managed and external resources.
            This field is planned to replace the DeletionPolicy field in a future
            release. Currently, both could be set independently and non-default
            values would be honored if the feature flag is enabled. If both are
            custom, the DeletionPolicy field will be ignored.
            See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
            and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
            """
            return self._set("management_policies", value)

        @overload
        def provider_config_ref(
            self, value_or_callback: Optional[ProviderConfigRef], /
        ) -> "KafkaTopicSpec.Builder": ...

        @overload
        def provider_config_ref(
            self,
            value_or_callback: Callable[
                [ProviderConfigRef.Builder],
                ProviderConfigRef.Builder | ProviderConfigRef,
            ],
            /,
        ) -> "KafkaTopicSpec.Builder": ...

        @overload
        def provider_config_ref(
            self, value_or_callback: Never = ...
        ) -> "ProviderConfigRef.BuilderContext": ...

        def provider_config_ref(self, value_or_callback=None, /):
            """
            ProviderConfigReference specifies how the provider that will be used to
            create, observe, update, and delete this managed resource should be
            configured.
            """
            if self._in_context and value_or_callback is None:
                context = ProviderConfigRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "provider_config_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ProviderConfigRef.builder())
                if isinstance(output, ProviderConfigRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("provider_config_ref", value)

        @overload
        def publish_connection_details_to(
            self, value_or_callback: Optional[PublishConnectionDetailsTo], /
        ) -> "KafkaTopicSpec.Builder": ...

        @overload
        def publish_connection_details_to(
            self,
            value_or_callback: Callable[
                [PublishConnectionDetailsTo.Builder],
                PublishConnectionDetailsTo.Builder | PublishConnectionDetailsTo,
            ],
            /,
        ) -> "KafkaTopicSpec.Builder": ...

        @overload
        def publish_connection_details_to(
            self, value_or_callback: Never = ...
        ) -> "PublishConnectionDetailsTo.BuilderContext": ...

        def publish_connection_details_to(self, value_or_callback=None, /):
            """
            PublishConnectionDetailsTo specifies the connection secret config which
            contains a name, metadata and a reference to secret store config to
            which any connection details for this managed resource should be written.
            Connection details frequently include the endpoint, username,
            and password required to connect to the managed resource.
            """
            if self._in_context and value_or_callback is None:
                context = PublishConnectionDetailsTo.BuilderContext()
                context._parent_builder = self
                context._field_name = "publish_connection_details_to"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PublishConnectionDetailsTo.builder())
                if isinstance(output, PublishConnectionDetailsTo.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("publish_connection_details_to", value)

        @overload
        def write_connection_secret_to_ref(
            self, value_or_callback: Optional[WriteConnectionSecretToRef], /
        ) -> "KafkaTopicSpec.Builder": ...

        @overload
        def write_connection_secret_to_ref(
            self,
            value_or_callback: Callable[
                [WriteConnectionSecretToRef.Builder],
                WriteConnectionSecretToRef.Builder | WriteConnectionSecretToRef,
            ],
            /,
        ) -> "KafkaTopicSpec.Builder": ...

        @overload
        def write_connection_secret_to_ref(
            self, value_or_callback: Never = ...
        ) -> "WriteConnectionSecretToRef.BuilderContext": ...

        def write_connection_secret_to_ref(self, value_or_callback=None, /):
            """
            WriteConnectionSecretToReference specifies the namespace and name of a
            Secret to which any connection details for this managed resource should
            be written. Connection details frequently include the endpoint, username,
            and password required to connect to the managed resource.
            This field is planned to be replaced in a future release in favor of
            PublishConnectionDetailsTo. Currently, both could be set independently
            and connection details would be published to both without affecting
            each other.
            """
            if self._in_context and value_or_callback is None:
                context = WriteConnectionSecretToRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "write_connection_secret_to_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(WriteConnectionSecretToRef.builder())
                if isinstance(output, WriteConnectionSecretToRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("write_connection_secret_to_ref", value)

    class BuilderContext(BuilderContextBase["KafkaTopicSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = KafkaTopicSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for KafkaTopicSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["KafkaTopicSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use KafkaTopicSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    deletion_policy: Annotated[
        Optional[Literal["Orphan", "Delete"]], Field(alias="deletionPolicy")
    ] = "Delete"
    """
    DeletionPolicy specifies what will happen to the underlying external
    when this managed resource is deleted - either "Delete" or "Orphan" the
    external resource.
    This field is planned to be deprecated in favor of the ManagementPolicies
    field in a future release. Currently, both could be set independently and
    non-default values would be honored if the feature flag is enabled.
    See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    """
    for_provider: Annotated[ForProviderModel3, Field(alias="forProvider")]
    init_provider: Annotated[Optional[InitProviderModel3], Field(alias="initProvider")] = None
    """
    THIS IS A BETA FIELD. It will be honored
    unless the Management Policies feature flag is disabled.
    InitProvider holds the same fields as ForProvider, with the exception
    of Identifier and other resource reference fields. The fields that are
    in InitProvider are merged into ForProvider when the resource is created.
    The same fields are also added to the terraform ignore_changes hook, to
    avoid updating them after creation. This is useful for fields that are
    required on creation, but we do not desire to update them after creation,
    for example because of an external controller is managing them, like an
    autoscaler.
    """
    management_policies: Annotated[
        Optional[List[Literal["Observe", "Create", "Update", "Delete", "LateInitialize", "*"]]],
        Field(alias="managementPolicies"),
    ] = ["*"]
    """
    THIS IS A BETA FIELD. It is on by default but can be opted out
    through a Crossplane feature flag.
    ManagementPolicies specify the array of actions Crossplane is allowed to
    take on the managed and external resources.
    This field is planned to replace the DeletionPolicy field in a future
    release. Currently, both could be set independently and non-default
    values would be honored if the feature flag is enabled. If both are
    custom, the DeletionPolicy field will be ignored.
    See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
    """
    provider_config_ref: Annotated[
        Optional[ProviderConfigRef],
        Field(
            default_factory=lambda: ProviderConfigRef.model_validate({"name": "default"}),
            alias="providerConfigRef",
        ),
    ] = {"name": "default"}
    """
    ProviderConfigReference specifies how the provider that will be used to
    create, observe, update, and delete this managed resource should be
    configured.
    """
    publish_connection_details_to: Annotated[
        Optional[PublishConnectionDetailsTo], Field(alias="publishConnectionDetailsTo")
    ] = None
    """
    PublishConnectionDetailsTo specifies the connection secret config which
    contains a name, metadata and a reference to secret store config to
    which any connection details for this managed resource should be written.
    Connection details frequently include the endpoint, username,
    and password required to connect to the managed resource.
    """
    write_connection_secret_to_ref: Annotated[
        Optional[WriteConnectionSecretToRef], Field(alias="writeConnectionSecretToRef")
    ] = None
    """
    WriteConnectionSecretToReference specifies the namespace and name of a
    Secret to which any connection details for this managed resource should
    be written. Connection details frequently include the endpoint, username,
    and password required to connect to the managed resource.
    This field is planned to be replaced in a future release in favor of
    PublishConnectionDetailsTo. Currently, both could be set independently
    and connection details would be published to both without affecting
    each other.
    """


class AtProviderModel3(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AtProviderModel3"]:
            return AtProviderModel3

        def build(self) -> "AtProviderModel3":
            return AtProviderModel3(**self._attrs)

        def cluster_id(self, value: Optional[str], /) -> Self:
            """
            The ID of the source database cluster. Note: This must be a Kafka cluster.
            """
            return self._set("cluster_id", value)

        @overload
        def config(self, value_or_callback: List[Config], /) -> "AtProviderModel3.Builder": ...

        @overload
        def config(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Config, Config.Builder]],
                GenericListBuilder[Config, Config.Builder] | List[Config],
            ],
            /,
        ) -> "AtProviderModel3.Builder": ...

        @overload
        def config(self, value_or_callback: Never = ...) -> ListBuilderContext[Config.Builder]: ...

        def config(self, value_or_callback=None, /):
            """
            A set of advanced configuration parameters. Defaults will be set for any of the parameters that are not included.
            The config block is documented below.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Config.Builder]()
                context._parent_builder = self
                context._field_name = "config"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Config.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("config", value)

        def id(self, value: Optional[str], /) -> Self:
            return self._set("id", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            The name for the topic.
            """
            return self._set("name", value)

        def partition_count(self, value: Optional[float], /) -> Self:
            """
            The number of partitions for the topic. Default and minimum set at 3, maximum is 2048.
            """
            return self._set("partition_count", value)

        def replication_factor(self, value: Optional[float], /) -> Self:
            """
            The number of nodes that topics are replicated across. Default and minimum set at 2, maximum is the number of nodes in the cluster.
            """
            return self._set("replication_factor", value)

        def state(self, value: Optional[str], /) -> Self:
            """
            The current status of the topic. Possible values are 'active', 'configuring', and 'deleting'.
            """
            return self._set("state", value)

    class BuilderContext(BuilderContextBase["AtProviderModel3.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AtProviderModel3.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AtProviderModel3."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AtProviderModel3", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AtProviderModel3.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    cluster_id: Annotated[Optional[str], Field(alias="clusterId")] = None
    """
    The ID of the source database cluster. Note: This must be a Kafka cluster.
    """
    config: Optional[List[Config]] = None
    """
    A set of advanced configuration parameters. Defaults will be set for any of the parameters that are not included.
    The config block is documented below.
    """
    id: Optional[str] = None
    name: Optional[str] = None
    """
    The name for the topic.
    """
    partition_count: Annotated[Optional[float], Field(alias="partitionCount")] = None
    """
    The number of partitions for the topic. Default and minimum set at 3, maximum is 2048.
    """
    replication_factor: Annotated[Optional[float], Field(alias="replicationFactor")] = None
    """
    The number of nodes that topics are replicated across. Default and minimum set at 2, maximum is the number of nodes in the cluster.
    """
    state: Optional[str] = None
    """
    The current status of the topic. Possible values are 'active', 'configuring', and 'deleting'.
    """


class KafkaTopicStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["KafkaTopicStatus"]:
            return KafkaTopicStatus

        def build(self) -> "KafkaTopicStatus":
            return KafkaTopicStatus(**self._attrs)

        @overload
        def at_provider(
            self, value_or_callback: Optional[AtProviderModel3], /
        ) -> "KafkaTopicStatus.Builder": ...

        @overload
        def at_provider(
            self,
            value_or_callback: Callable[
                [AtProviderModel3.Builder], AtProviderModel3.Builder | AtProviderModel3
            ],
            /,
        ) -> "KafkaTopicStatus.Builder": ...

        @overload
        def at_provider(
            self, value_or_callback: Never = ...
        ) -> "AtProviderModel3.BuilderContext": ...

        def at_provider(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = AtProviderModel3.BuilderContext()
                context._parent_builder = self
                context._field_name = "at_provider"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AtProviderModel3.builder())
                if isinstance(output, AtProviderModel3.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("at_provider", value)

        @overload
        def conditions(
            self, value_or_callback: List[Condition], /
        ) -> "KafkaTopicStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Condition, Condition.Builder]],
                GenericListBuilder[Condition, Condition.Builder] | List[Condition],
            ],
            /,
        ) -> "KafkaTopicStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            """
            Conditions of the resource.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        def observed_generation(self, value: Optional[int], /) -> Self:
            """
            ObservedGeneration is the latest metadata.generation
            which resulted in either a ready state, or stalled due to error
            it can not recover from without human intervention.
            """
            return self._set("observed_generation", value)

    class BuilderContext(BuilderContextBase["KafkaTopicStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = KafkaTopicStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for KafkaTopicStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["KafkaTopicStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use KafkaTopicStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    at_provider: Annotated[Optional[AtProviderModel3], Field(alias="atProvider")] = None
    conditions: Optional[List[Condition]] = None
    """
    Conditions of the resource.
    """
    observed_generation: Annotated[Optional[int], Field(alias="observedGeneration")] = None
    """
    ObservedGeneration is the latest metadata.generation
    which resulted in either a ready state, or stalled due to error
    it can not recover from without human intervention.
    """


class ForProviderModel4(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ForProviderModel4"]:
            return ForProviderModel4

        def build(self) -> "ForProviderModel4":
            return ForProviderModel4(**self._attrs)

        def backup_hour(self, value: Optional[float], /) -> Self:
            """
            The hour of day (in UTC) when backup for the service starts. New backup only starts if previous backup has already completed.
            """
            return self._set("backup_hour", value)

        def backup_minute(self, value: Optional[float], /) -> Self:
            """
            The minute of the backup hour when backup for the service starts. New backup only starts if previous backup has already completed.
            """
            return self._set("backup_minute", value)

        def binlog_retention_period(self, value: Optional[float], /) -> Self:
            """
            The minimum amount of time, in seconds, to keep binlog entries before deletion. This may be extended for services that require binlog entries for longer than the default, for example if using the MySQL Debezium Kafka connector.
            """
            return self._set("binlog_retention_period", value)

        def cluster_id(self, value: Optional[str], /) -> Self:
            """
            The ID of the target MySQL cluster.
            """
            return self._set("cluster_id", value)

        @overload
        def cluster_id_ref(
            self, value_or_callback: Optional[ClusterIdRef], /
        ) -> "ForProviderModel4.Builder": ...

        @overload
        def cluster_id_ref(
            self,
            value_or_callback: Callable[
                [ClusterIdRef.Builder], ClusterIdRef.Builder | ClusterIdRef
            ],
            /,
        ) -> "ForProviderModel4.Builder": ...

        @overload
        def cluster_id_ref(
            self, value_or_callback: Never = ...
        ) -> "ClusterIdRef.BuilderContext": ...

        def cluster_id_ref(self, value_or_callback=None, /):
            """
            Reference to a Cluster in database to populate clusterId.
            """
            if self._in_context and value_or_callback is None:
                context = ClusterIdRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "cluster_id_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ClusterIdRef.builder())
                if isinstance(output, ClusterIdRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("cluster_id_ref", value)

        @overload
        def cluster_id_selector(
            self, value_or_callback: Optional[ClusterIdSelector], /
        ) -> "ForProviderModel4.Builder": ...

        @overload
        def cluster_id_selector(
            self,
            value_or_callback: Callable[
                [ClusterIdSelector.Builder],
                ClusterIdSelector.Builder | ClusterIdSelector,
            ],
            /,
        ) -> "ForProviderModel4.Builder": ...

        @overload
        def cluster_id_selector(
            self, value_or_callback: Never = ...
        ) -> "ClusterIdSelector.BuilderContext": ...

        def cluster_id_selector(self, value_or_callback=None, /):
            """
            Selector for a Cluster in database to populate clusterId.
            """
            if self._in_context and value_or_callback is None:
                context = ClusterIdSelector.BuilderContext()
                context._parent_builder = self
                context._field_name = "cluster_id_selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ClusterIdSelector.builder())
                if isinstance(output, ClusterIdSelector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("cluster_id_selector", value)

        def connect_timeout(self, value: Optional[float], /) -> Self:
            """
            The number of seconds that the mysqld server waits for a connect packet before responding with bad handshake.
            """
            return self._set("connect_timeout", value)

        def default_time_zone(self, value: Optional[str], /) -> Self:
            """
            Default server time zone, in the form of an offset from UTC (from -12:00 to +12:00), a time zone name (EST), or SYSTEM to use the MySQL server default.
            """
            return self._set("default_time_zone", value)

        def group_concat_max_len(self, value: Optional[float], /) -> Self:
            """
            The maximum permitted result length, in bytes, for the GROUP_CONCAT() function.
            """
            return self._set("group_concat_max_len", value)

        def information_schema_stats_expiry(self, value: Optional[float], /) -> Self:
            """
            The time, in seconds, before cached statistics expire.
            """
            return self._set("information_schema_stats_expiry", value)

        def innodb_ft_min_token_size(self, value: Optional[float], /) -> Self:
            """
            The minimum length of words that an InnoDB FULLTEXT index stores.
            """
            return self._set("innodb_ft_min_token_size", value)

        def innodb_ft_server_stopword_table(self, value: Optional[str], /) -> Self:
            """
            The InnoDB FULLTEXT index stopword list for all InnoDB tables.
            """
            return self._set("innodb_ft_server_stopword_table", value)

        def innodb_lock_wait_timeout(self, value: Optional[float], /) -> Self:
            """
            The time, in seconds, that an InnoDB transaction waits for a row lock. before giving up.
            """
            return self._set("innodb_lock_wait_timeout", value)

        def innodb_log_buffer_size(self, value: Optional[float], /) -> Self:
            """
            The size of the buffer, in bytes, that InnoDB uses to write to the log files. on disk.
            """
            return self._set("innodb_log_buffer_size", value)

        def innodb_online_alter_log_max_size(self, value: Optional[float], /) -> Self:
            """
            The upper limit, in bytes, of the size of the temporary log files used during online DDL operations for InnoDB tables.
            """
            return self._set("innodb_online_alter_log_max_size", value)

        def innodb_print_all_deadlocks(self, value: Optional[bool], /) -> Self:
            """
            When enabled, records information about all deadlocks in InnoDB user transactions in the error log. Disabled by default.
            """
            return self._set("innodb_print_all_deadlocks", value)

        def innodb_rollback_on_timeout(self, value: Optional[bool], /) -> Self:
            """
            When enabled, transaction timeouts cause InnoDB to abort and roll back the entire transaction.
            """
            return self._set("innodb_rollback_on_timeout", value)

        def interactive_timeout(self, value: Optional[float], /) -> Self:
            """
            The time, in seconds, the server waits for activity on an interactive. connection before closing it.
            """
            return self._set("interactive_timeout", value)

        def internal_tmp_mem_storage_engine(self, value: Optional[str], /) -> Self:
            """
            The storage engine for in-memory internal temporary tables. Supported values are: TempTable, MEMORY.
            """
            return self._set("internal_tmp_mem_storage_engine", value)

        def long_query_time(self, value: Optional[float], /) -> Self:
            """
            The time, in seconds, for a query to take to execute before being captured by slow_query_logs. Default is 10 seconds.
            """
            return self._set("long_query_time", value)

        def max_allowed_packet(self, value: Optional[float], /) -> Self:
            """
            The size of the largest message, in bytes, that can be received by the server. Default is 67108864 (64M).
            """
            return self._set("max_allowed_packet", value)

        def max_heap_table_size(self, value: Optional[float], /) -> Self:
            """
            The maximum size, in bytes, of internal in-memory tables. Also set tmp_table_size. Default is 16777216 (16M)
            """
            return self._set("max_heap_table_size", value)

        def net_read_timeout(self, value: Optional[float], /) -> Self:
            """
            The time, in seconds, to wait for more data from an existing connection. aborting the read.
            """
            return self._set("net_read_timeout", value)

        def net_write_timeout(self, value: Optional[float], /) -> Self:
            """
            The number of seconds to wait for a block to be written to a connection before aborting the write.
            """
            return self._set("net_write_timeout", value)

        def slow_query_log(self, value: Optional[bool], /) -> Self:
            """
            When enabled, captures slow queries. When disabled, also truncates the mysql.slow_log table. Default is false.
            """
            return self._set("slow_query_log", value)

        def sort_buffer_size(self, value: Optional[float], /) -> Self:
            """
            The sort buffer size, in bytes, for ORDER BY optimization. Default is 262144. (256K).
            """
            return self._set("sort_buffer_size", value)

        def sql_mode(self, value: Optional[str], /) -> Self:
            """
            Global SQL mode. If empty, uses MySQL server defaults. Must only include uppercase alphabetic characters, underscores, and commas.
            """
            return self._set("sql_mode", value)

        def sql_require_primary_key(self, value: Optional[bool], /) -> Self:
            """
            Require primary key to be defined for new tables or old tables modified with ALTER TABLE and fail if missing. It is recommended to always have primary keys because various functionality may break if any large table is missing them.
            """
            return self._set("sql_require_primary_key", value)

        def tmp_table_size(self, value: Optional[float], /) -> Self:
            """
            The maximum size, in bytes, of internal in-memory tables. Also set max_heap_table_size. Default is 16777216 (16M).
            """
            return self._set("tmp_table_size", value)

        def wait_timeout(self, value: Optional[float], /) -> Self:
            """
            The number of seconds the server waits for activity on a noninteractive connection before closing it.
            """
            return self._set("wait_timeout", value)

    class BuilderContext(BuilderContextBase["ForProviderModel4.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ForProviderModel4.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ForProviderModel4."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ForProviderModel4", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ForProviderModel4.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    backup_hour: Annotated[Optional[float], Field(alias="backupHour")] = None
    """
    The hour of day (in UTC) when backup for the service starts. New backup only starts if previous backup has already completed.
    """
    backup_minute: Annotated[Optional[float], Field(alias="backupMinute")] = None
    """
    The minute of the backup hour when backup for the service starts. New backup only starts if previous backup has already completed.
    """
    binlog_retention_period: Annotated[Optional[float], Field(alias="binlogRetentionPeriod")] = None
    """
    The minimum amount of time, in seconds, to keep binlog entries before deletion. This may be extended for services that require binlog entries for longer than the default, for example if using the MySQL Debezium Kafka connector.
    """
    cluster_id: Annotated[Optional[str], Field(alias="clusterId")] = None
    """
    The ID of the target MySQL cluster.
    """
    cluster_id_ref: Annotated[Optional[ClusterIdRef], Field(alias="clusterIdRef")] = None
    """
    Reference to a Cluster in database to populate clusterId.
    """
    cluster_id_selector: Annotated[
        Optional[ClusterIdSelector], Field(alias="clusterIdSelector")
    ] = None
    """
    Selector for a Cluster in database to populate clusterId.
    """
    connect_timeout: Annotated[Optional[float], Field(alias="connectTimeout")] = None
    """
    The number of seconds that the mysqld server waits for a connect packet before responding with bad handshake.
    """
    default_time_zone: Annotated[Optional[str], Field(alias="defaultTimeZone")] = None
    """
    Default server time zone, in the form of an offset from UTC (from -12:00 to +12:00), a time zone name (EST), or SYSTEM to use the MySQL server default.
    """
    group_concat_max_len: Annotated[Optional[float], Field(alias="groupConcatMaxLen")] = None
    """
    The maximum permitted result length, in bytes, for the GROUP_CONCAT() function.
    """
    information_schema_stats_expiry: Annotated[
        Optional[float], Field(alias="informationSchemaStatsExpiry")
    ] = None
    """
    The time, in seconds, before cached statistics expire.
    """
    innodb_ft_min_token_size: Annotated[Optional[float], Field(alias="innodbFtMinTokenSize")] = None
    """
    The minimum length of words that an InnoDB FULLTEXT index stores.
    """
    innodb_ft_server_stopword_table: Annotated[
        Optional[str], Field(alias="innodbFtServerStopwordTable")
    ] = None
    """
    The InnoDB FULLTEXT index stopword list for all InnoDB tables.
    """
    innodb_lock_wait_timeout: Annotated[Optional[float], Field(alias="innodbLockWaitTimeout")] = (
        None
    )
    """
    The time, in seconds, that an InnoDB transaction waits for a row lock. before giving up.
    """
    innodb_log_buffer_size: Annotated[Optional[float], Field(alias="innodbLogBufferSize")] = None
    """
    The size of the buffer, in bytes, that InnoDB uses to write to the log files. on disk.
    """
    innodb_online_alter_log_max_size: Annotated[
        Optional[float], Field(alias="innodbOnlineAlterLogMaxSize")
    ] = None
    """
    The upper limit, in bytes, of the size of the temporary log files used during online DDL operations for InnoDB tables.
    """
    innodb_print_all_deadlocks: Annotated[
        Optional[bool], Field(alias="innodbPrintAllDeadlocks")
    ] = None
    """
    When enabled, records information about all deadlocks in InnoDB user transactions in the error log. Disabled by default.
    """
    innodb_rollback_on_timeout: Annotated[
        Optional[bool], Field(alias="innodbRollbackOnTimeout")
    ] = None
    """
    When enabled, transaction timeouts cause InnoDB to abort and roll back the entire transaction.
    """
    interactive_timeout: Annotated[Optional[float], Field(alias="interactiveTimeout")] = None
    """
    The time, in seconds, the server waits for activity on an interactive. connection before closing it.
    """
    internal_tmp_mem_storage_engine: Annotated[
        Optional[str], Field(alias="internalTmpMemStorageEngine")
    ] = None
    """
    The storage engine for in-memory internal temporary tables. Supported values are: TempTable, MEMORY.
    """
    long_query_time: Annotated[Optional[float], Field(alias="longQueryTime")] = None
    """
    The time, in seconds, for a query to take to execute before being captured by slow_query_logs. Default is 10 seconds.
    """
    max_allowed_packet: Annotated[Optional[float], Field(alias="maxAllowedPacket")] = None
    """
    The size of the largest message, in bytes, that can be received by the server. Default is 67108864 (64M).
    """
    max_heap_table_size: Annotated[Optional[float], Field(alias="maxHeapTableSize")] = None
    """
    The maximum size, in bytes, of internal in-memory tables. Also set tmp_table_size. Default is 16777216 (16M)
    """
    net_read_timeout: Annotated[Optional[float], Field(alias="netReadTimeout")] = None
    """
    The time, in seconds, to wait for more data from an existing connection. aborting the read.
    """
    net_write_timeout: Annotated[Optional[float], Field(alias="netWriteTimeout")] = None
    """
    The number of seconds to wait for a block to be written to a connection before aborting the write.
    """
    slow_query_log: Annotated[Optional[bool], Field(alias="slowQueryLog")] = None
    """
    When enabled, captures slow queries. When disabled, also truncates the mysql.slow_log table. Default is false.
    """
    sort_buffer_size: Annotated[Optional[float], Field(alias="sortBufferSize")] = None
    """
    The sort buffer size, in bytes, for ORDER BY optimization. Default is 262144. (256K).
    """
    sql_mode: Annotated[Optional[str], Field(alias="sqlMode")] = None
    """
    Global SQL mode. If empty, uses MySQL server defaults. Must only include uppercase alphabetic characters, underscores, and commas.
    """
    sql_require_primary_key: Annotated[Optional[bool], Field(alias="sqlRequirePrimaryKey")] = None
    """
    Require primary key to be defined for new tables or old tables modified with ALTER TABLE and fail if missing. It is recommended to always have primary keys because various functionality may break if any large table is missing them.
    """
    tmp_table_size: Annotated[Optional[float], Field(alias="tmpTableSize")] = None
    """
    The maximum size, in bytes, of internal in-memory tables. Also set max_heap_table_size. Default is 16777216 (16M).
    """
    wait_timeout: Annotated[Optional[float], Field(alias="waitTimeout")] = None
    """
    The number of seconds the server waits for activity on a noninteractive connection before closing it.
    """


class InitProviderModel4(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["InitProviderModel4"]:
            return InitProviderModel4

        def build(self) -> "InitProviderModel4":
            return InitProviderModel4(**self._attrs)

        def backup_hour(self, value: Optional[float], /) -> Self:
            """
            The hour of day (in UTC) when backup for the service starts. New backup only starts if previous backup has already completed.
            """
            return self._set("backup_hour", value)

        def backup_minute(self, value: Optional[float], /) -> Self:
            """
            The minute of the backup hour when backup for the service starts. New backup only starts if previous backup has already completed.
            """
            return self._set("backup_minute", value)

        def binlog_retention_period(self, value: Optional[float], /) -> Self:
            """
            The minimum amount of time, in seconds, to keep binlog entries before deletion. This may be extended for services that require binlog entries for longer than the default, for example if using the MySQL Debezium Kafka connector.
            """
            return self._set("binlog_retention_period", value)

        def cluster_id(self, value: Optional[str], /) -> Self:
            """
            The ID of the target MySQL cluster.
            """
            return self._set("cluster_id", value)

        @overload
        def cluster_id_ref(
            self, value_or_callback: Optional[ClusterIdRef], /
        ) -> "InitProviderModel4.Builder": ...

        @overload
        def cluster_id_ref(
            self,
            value_or_callback: Callable[
                [ClusterIdRef.Builder], ClusterIdRef.Builder | ClusterIdRef
            ],
            /,
        ) -> "InitProviderModel4.Builder": ...

        @overload
        def cluster_id_ref(
            self, value_or_callback: Never = ...
        ) -> "ClusterIdRef.BuilderContext": ...

        def cluster_id_ref(self, value_or_callback=None, /):
            """
            Reference to a Cluster in database to populate clusterId.
            """
            if self._in_context and value_or_callback is None:
                context = ClusterIdRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "cluster_id_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ClusterIdRef.builder())
                if isinstance(output, ClusterIdRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("cluster_id_ref", value)

        @overload
        def cluster_id_selector(
            self, value_or_callback: Optional[ClusterIdSelector], /
        ) -> "InitProviderModel4.Builder": ...

        @overload
        def cluster_id_selector(
            self,
            value_or_callback: Callable[
                [ClusterIdSelector.Builder],
                ClusterIdSelector.Builder | ClusterIdSelector,
            ],
            /,
        ) -> "InitProviderModel4.Builder": ...

        @overload
        def cluster_id_selector(
            self, value_or_callback: Never = ...
        ) -> "ClusterIdSelector.BuilderContext": ...

        def cluster_id_selector(self, value_or_callback=None, /):
            """
            Selector for a Cluster in database to populate clusterId.
            """
            if self._in_context and value_or_callback is None:
                context = ClusterIdSelector.BuilderContext()
                context._parent_builder = self
                context._field_name = "cluster_id_selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ClusterIdSelector.builder())
                if isinstance(output, ClusterIdSelector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("cluster_id_selector", value)

        def connect_timeout(self, value: Optional[float], /) -> Self:
            """
            The number of seconds that the mysqld server waits for a connect packet before responding with bad handshake.
            """
            return self._set("connect_timeout", value)

        def default_time_zone(self, value: Optional[str], /) -> Self:
            """
            Default server time zone, in the form of an offset from UTC (from -12:00 to +12:00), a time zone name (EST), or SYSTEM to use the MySQL server default.
            """
            return self._set("default_time_zone", value)

        def group_concat_max_len(self, value: Optional[float], /) -> Self:
            """
            The maximum permitted result length, in bytes, for the GROUP_CONCAT() function.
            """
            return self._set("group_concat_max_len", value)

        def information_schema_stats_expiry(self, value: Optional[float], /) -> Self:
            """
            The time, in seconds, before cached statistics expire.
            """
            return self._set("information_schema_stats_expiry", value)

        def innodb_ft_min_token_size(self, value: Optional[float], /) -> Self:
            """
            The minimum length of words that an InnoDB FULLTEXT index stores.
            """
            return self._set("innodb_ft_min_token_size", value)

        def innodb_ft_server_stopword_table(self, value: Optional[str], /) -> Self:
            """
            The InnoDB FULLTEXT index stopword list for all InnoDB tables.
            """
            return self._set("innodb_ft_server_stopword_table", value)

        def innodb_lock_wait_timeout(self, value: Optional[float], /) -> Self:
            """
            The time, in seconds, that an InnoDB transaction waits for a row lock. before giving up.
            """
            return self._set("innodb_lock_wait_timeout", value)

        def innodb_log_buffer_size(self, value: Optional[float], /) -> Self:
            """
            The size of the buffer, in bytes, that InnoDB uses to write to the log files. on disk.
            """
            return self._set("innodb_log_buffer_size", value)

        def innodb_online_alter_log_max_size(self, value: Optional[float], /) -> Self:
            """
            The upper limit, in bytes, of the size of the temporary log files used during online DDL operations for InnoDB tables.
            """
            return self._set("innodb_online_alter_log_max_size", value)

        def innodb_print_all_deadlocks(self, value: Optional[bool], /) -> Self:
            """
            When enabled, records information about all deadlocks in InnoDB user transactions in the error log. Disabled by default.
            """
            return self._set("innodb_print_all_deadlocks", value)

        def innodb_rollback_on_timeout(self, value: Optional[bool], /) -> Self:
            """
            When enabled, transaction timeouts cause InnoDB to abort and roll back the entire transaction.
            """
            return self._set("innodb_rollback_on_timeout", value)

        def interactive_timeout(self, value: Optional[float], /) -> Self:
            """
            The time, in seconds, the server waits for activity on an interactive. connection before closing it.
            """
            return self._set("interactive_timeout", value)

        def internal_tmp_mem_storage_engine(self, value: Optional[str], /) -> Self:
            """
            The storage engine for in-memory internal temporary tables. Supported values are: TempTable, MEMORY.
            """
            return self._set("internal_tmp_mem_storage_engine", value)

        def long_query_time(self, value: Optional[float], /) -> Self:
            """
            The time, in seconds, for a query to take to execute before being captured by slow_query_logs. Default is 10 seconds.
            """
            return self._set("long_query_time", value)

        def max_allowed_packet(self, value: Optional[float], /) -> Self:
            """
            The size of the largest message, in bytes, that can be received by the server. Default is 67108864 (64M).
            """
            return self._set("max_allowed_packet", value)

        def max_heap_table_size(self, value: Optional[float], /) -> Self:
            """
            The maximum size, in bytes, of internal in-memory tables. Also set tmp_table_size. Default is 16777216 (16M)
            """
            return self._set("max_heap_table_size", value)

        def net_read_timeout(self, value: Optional[float], /) -> Self:
            """
            The time, in seconds, to wait for more data from an existing connection. aborting the read.
            """
            return self._set("net_read_timeout", value)

        def net_write_timeout(self, value: Optional[float], /) -> Self:
            """
            The number of seconds to wait for a block to be written to a connection before aborting the write.
            """
            return self._set("net_write_timeout", value)

        def slow_query_log(self, value: Optional[bool], /) -> Self:
            """
            When enabled, captures slow queries. When disabled, also truncates the mysql.slow_log table. Default is false.
            """
            return self._set("slow_query_log", value)

        def sort_buffer_size(self, value: Optional[float], /) -> Self:
            """
            The sort buffer size, in bytes, for ORDER BY optimization. Default is 262144. (256K).
            """
            return self._set("sort_buffer_size", value)

        def sql_mode(self, value: Optional[str], /) -> Self:
            """
            Global SQL mode. If empty, uses MySQL server defaults. Must only include uppercase alphabetic characters, underscores, and commas.
            """
            return self._set("sql_mode", value)

        def sql_require_primary_key(self, value: Optional[bool], /) -> Self:
            """
            Require primary key to be defined for new tables or old tables modified with ALTER TABLE and fail if missing. It is recommended to always have primary keys because various functionality may break if any large table is missing them.
            """
            return self._set("sql_require_primary_key", value)

        def tmp_table_size(self, value: Optional[float], /) -> Self:
            """
            The maximum size, in bytes, of internal in-memory tables. Also set max_heap_table_size. Default is 16777216 (16M).
            """
            return self._set("tmp_table_size", value)

        def wait_timeout(self, value: Optional[float], /) -> Self:
            """
            The number of seconds the server waits for activity on a noninteractive connection before closing it.
            """
            return self._set("wait_timeout", value)

    class BuilderContext(BuilderContextBase["InitProviderModel4.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = InitProviderModel4.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for InitProviderModel4."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["InitProviderModel4", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use InitProviderModel4.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    backup_hour: Annotated[Optional[float], Field(alias="backupHour")] = None
    """
    The hour of day (in UTC) when backup for the service starts. New backup only starts if previous backup has already completed.
    """
    backup_minute: Annotated[Optional[float], Field(alias="backupMinute")] = None
    """
    The minute of the backup hour when backup for the service starts. New backup only starts if previous backup has already completed.
    """
    binlog_retention_period: Annotated[Optional[float], Field(alias="binlogRetentionPeriod")] = None
    """
    The minimum amount of time, in seconds, to keep binlog entries before deletion. This may be extended for services that require binlog entries for longer than the default, for example if using the MySQL Debezium Kafka connector.
    """
    cluster_id: Annotated[Optional[str], Field(alias="clusterId")] = None
    """
    The ID of the target MySQL cluster.
    """
    cluster_id_ref: Annotated[Optional[ClusterIdRef], Field(alias="clusterIdRef")] = None
    """
    Reference to a Cluster in database to populate clusterId.
    """
    cluster_id_selector: Annotated[
        Optional[ClusterIdSelector], Field(alias="clusterIdSelector")
    ] = None
    """
    Selector for a Cluster in database to populate clusterId.
    """
    connect_timeout: Annotated[Optional[float], Field(alias="connectTimeout")] = None
    """
    The number of seconds that the mysqld server waits for a connect packet before responding with bad handshake.
    """
    default_time_zone: Annotated[Optional[str], Field(alias="defaultTimeZone")] = None
    """
    Default server time zone, in the form of an offset from UTC (from -12:00 to +12:00), a time zone name (EST), or SYSTEM to use the MySQL server default.
    """
    group_concat_max_len: Annotated[Optional[float], Field(alias="groupConcatMaxLen")] = None
    """
    The maximum permitted result length, in bytes, for the GROUP_CONCAT() function.
    """
    information_schema_stats_expiry: Annotated[
        Optional[float], Field(alias="informationSchemaStatsExpiry")
    ] = None
    """
    The time, in seconds, before cached statistics expire.
    """
    innodb_ft_min_token_size: Annotated[Optional[float], Field(alias="innodbFtMinTokenSize")] = None
    """
    The minimum length of words that an InnoDB FULLTEXT index stores.
    """
    innodb_ft_server_stopword_table: Annotated[
        Optional[str], Field(alias="innodbFtServerStopwordTable")
    ] = None
    """
    The InnoDB FULLTEXT index stopword list for all InnoDB tables.
    """
    innodb_lock_wait_timeout: Annotated[Optional[float], Field(alias="innodbLockWaitTimeout")] = (
        None
    )
    """
    The time, in seconds, that an InnoDB transaction waits for a row lock. before giving up.
    """
    innodb_log_buffer_size: Annotated[Optional[float], Field(alias="innodbLogBufferSize")] = None
    """
    The size of the buffer, in bytes, that InnoDB uses to write to the log files. on disk.
    """
    innodb_online_alter_log_max_size: Annotated[
        Optional[float], Field(alias="innodbOnlineAlterLogMaxSize")
    ] = None
    """
    The upper limit, in bytes, of the size of the temporary log files used during online DDL operations for InnoDB tables.
    """
    innodb_print_all_deadlocks: Annotated[
        Optional[bool], Field(alias="innodbPrintAllDeadlocks")
    ] = None
    """
    When enabled, records information about all deadlocks in InnoDB user transactions in the error log. Disabled by default.
    """
    innodb_rollback_on_timeout: Annotated[
        Optional[bool], Field(alias="innodbRollbackOnTimeout")
    ] = None
    """
    When enabled, transaction timeouts cause InnoDB to abort and roll back the entire transaction.
    """
    interactive_timeout: Annotated[Optional[float], Field(alias="interactiveTimeout")] = None
    """
    The time, in seconds, the server waits for activity on an interactive. connection before closing it.
    """
    internal_tmp_mem_storage_engine: Annotated[
        Optional[str], Field(alias="internalTmpMemStorageEngine")
    ] = None
    """
    The storage engine for in-memory internal temporary tables. Supported values are: TempTable, MEMORY.
    """
    long_query_time: Annotated[Optional[float], Field(alias="longQueryTime")] = None
    """
    The time, in seconds, for a query to take to execute before being captured by slow_query_logs. Default is 10 seconds.
    """
    max_allowed_packet: Annotated[Optional[float], Field(alias="maxAllowedPacket")] = None
    """
    The size of the largest message, in bytes, that can be received by the server. Default is 67108864 (64M).
    """
    max_heap_table_size: Annotated[Optional[float], Field(alias="maxHeapTableSize")] = None
    """
    The maximum size, in bytes, of internal in-memory tables. Also set tmp_table_size. Default is 16777216 (16M)
    """
    net_read_timeout: Annotated[Optional[float], Field(alias="netReadTimeout")] = None
    """
    The time, in seconds, to wait for more data from an existing connection. aborting the read.
    """
    net_write_timeout: Annotated[Optional[float], Field(alias="netWriteTimeout")] = None
    """
    The number of seconds to wait for a block to be written to a connection before aborting the write.
    """
    slow_query_log: Annotated[Optional[bool], Field(alias="slowQueryLog")] = None
    """
    When enabled, captures slow queries. When disabled, also truncates the mysql.slow_log table. Default is false.
    """
    sort_buffer_size: Annotated[Optional[float], Field(alias="sortBufferSize")] = None
    """
    The sort buffer size, in bytes, for ORDER BY optimization. Default is 262144. (256K).
    """
    sql_mode: Annotated[Optional[str], Field(alias="sqlMode")] = None
    """
    Global SQL mode. If empty, uses MySQL server defaults. Must only include uppercase alphabetic characters, underscores, and commas.
    """
    sql_require_primary_key: Annotated[Optional[bool], Field(alias="sqlRequirePrimaryKey")] = None
    """
    Require primary key to be defined for new tables or old tables modified with ALTER TABLE and fail if missing. It is recommended to always have primary keys because various functionality may break if any large table is missing them.
    """
    tmp_table_size: Annotated[Optional[float], Field(alias="tmpTableSize")] = None
    """
    The maximum size, in bytes, of internal in-memory tables. Also set max_heap_table_size. Default is 16777216 (16M).
    """
    wait_timeout: Annotated[Optional[float], Field(alias="waitTimeout")] = None
    """
    The number of seconds the server waits for activity on a noninteractive connection before closing it.
    """


class MySQLConfigSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["MySQLConfigSpec"]:
            return MySQLConfigSpec

        def build(self) -> "MySQLConfigSpec":
            return MySQLConfigSpec(**self._attrs)

        def deletion_policy(self, value: Optional[Literal["Orphan", "Delete"]], /) -> Self:
            """
            DeletionPolicy specifies what will happen to the underlying external
            when this managed resource is deleted - either "Delete" or "Orphan" the
            external resource.
            This field is planned to be deprecated in favor of the ManagementPolicies
            field in a future release. Currently, both could be set independently and
            non-default values would be honored if the feature flag is enabled.
            See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
            """
            return self._set("deletion_policy", value)

        @overload
        def for_provider(
            self, value_or_callback: ForProviderModel4, /
        ) -> "MySQLConfigSpec.Builder": ...

        @overload
        def for_provider(
            self,
            value_or_callback: Callable[
                [ForProviderModel4.Builder],
                ForProviderModel4.Builder | ForProviderModel4,
            ],
            /,
        ) -> "MySQLConfigSpec.Builder": ...

        @overload
        def for_provider(
            self, value_or_callback: Never = ...
        ) -> "ForProviderModel4.BuilderContext": ...

        def for_provider(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ForProviderModel4.BuilderContext()
                context._parent_builder = self
                context._field_name = "for_provider"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ForProviderModel4.builder())
                if isinstance(output, ForProviderModel4.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("for_provider", value)

        @overload
        def init_provider(
            self, value_or_callback: Optional[InitProviderModel4], /
        ) -> "MySQLConfigSpec.Builder": ...

        @overload
        def init_provider(
            self,
            value_or_callback: Callable[
                [InitProviderModel4.Builder],
                InitProviderModel4.Builder | InitProviderModel4,
            ],
            /,
        ) -> "MySQLConfigSpec.Builder": ...

        @overload
        def init_provider(
            self, value_or_callback: Never = ...
        ) -> "InitProviderModel4.BuilderContext": ...

        def init_provider(self, value_or_callback=None, /):
            """
            THIS IS A BETA FIELD. It will be honored
            unless the Management Policies feature flag is disabled.
            InitProvider holds the same fields as ForProvider, with the exception
            of Identifier and other resource reference fields. The fields that are
            in InitProvider are merged into ForProvider when the resource is created.
            The same fields are also added to the terraform ignore_changes hook, to
            avoid updating them after creation. This is useful for fields that are
            required on creation, but we do not desire to update them after creation,
            for example because of an external controller is managing them, like an
            autoscaler.
            """
            if self._in_context and value_or_callback is None:
                context = InitProviderModel4.BuilderContext()
                context._parent_builder = self
                context._field_name = "init_provider"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(InitProviderModel4.builder())
                if isinstance(output, InitProviderModel4.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("init_provider", value)

        def management_policies(
            self,
            value: Optional[
                List[Literal["Observe", "Create", "Update", "Delete", "LateInitialize", "*"]]
            ],
            /,
        ) -> Self:
            """
            THIS IS A BETA FIELD. It is on by default but can be opted out
            through a Crossplane feature flag.
            ManagementPolicies specify the array of actions Crossplane is allowed to
            take on the managed and external resources.
            This field is planned to replace the DeletionPolicy field in a future
            release. Currently, both could be set independently and non-default
            values would be honored if the feature flag is enabled. If both are
            custom, the DeletionPolicy field will be ignored.
            See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
            and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
            """
            return self._set("management_policies", value)

        @overload
        def provider_config_ref(
            self, value_or_callback: Optional[ProviderConfigRef], /
        ) -> "MySQLConfigSpec.Builder": ...

        @overload
        def provider_config_ref(
            self,
            value_or_callback: Callable[
                [ProviderConfigRef.Builder],
                ProviderConfigRef.Builder | ProviderConfigRef,
            ],
            /,
        ) -> "MySQLConfigSpec.Builder": ...

        @overload
        def provider_config_ref(
            self, value_or_callback: Never = ...
        ) -> "ProviderConfigRef.BuilderContext": ...

        def provider_config_ref(self, value_or_callback=None, /):
            """
            ProviderConfigReference specifies how the provider that will be used to
            create, observe, update, and delete this managed resource should be
            configured.
            """
            if self._in_context and value_or_callback is None:
                context = ProviderConfigRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "provider_config_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ProviderConfigRef.builder())
                if isinstance(output, ProviderConfigRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("provider_config_ref", value)

        @overload
        def publish_connection_details_to(
            self, value_or_callback: Optional[PublishConnectionDetailsTo], /
        ) -> "MySQLConfigSpec.Builder": ...

        @overload
        def publish_connection_details_to(
            self,
            value_or_callback: Callable[
                [PublishConnectionDetailsTo.Builder],
                PublishConnectionDetailsTo.Builder | PublishConnectionDetailsTo,
            ],
            /,
        ) -> "MySQLConfigSpec.Builder": ...

        @overload
        def publish_connection_details_to(
            self, value_or_callback: Never = ...
        ) -> "PublishConnectionDetailsTo.BuilderContext": ...

        def publish_connection_details_to(self, value_or_callback=None, /):
            """
            PublishConnectionDetailsTo specifies the connection secret config which
            contains a name, metadata and a reference to secret store config to
            which any connection details for this managed resource should be written.
            Connection details frequently include the endpoint, username,
            and password required to connect to the managed resource.
            """
            if self._in_context and value_or_callback is None:
                context = PublishConnectionDetailsTo.BuilderContext()
                context._parent_builder = self
                context._field_name = "publish_connection_details_to"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PublishConnectionDetailsTo.builder())
                if isinstance(output, PublishConnectionDetailsTo.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("publish_connection_details_to", value)

        @overload
        def write_connection_secret_to_ref(
            self, value_or_callback: Optional[WriteConnectionSecretToRef], /
        ) -> "MySQLConfigSpec.Builder": ...

        @overload
        def write_connection_secret_to_ref(
            self,
            value_or_callback: Callable[
                [WriteConnectionSecretToRef.Builder],
                WriteConnectionSecretToRef.Builder | WriteConnectionSecretToRef,
            ],
            /,
        ) -> "MySQLConfigSpec.Builder": ...

        @overload
        def write_connection_secret_to_ref(
            self, value_or_callback: Never = ...
        ) -> "WriteConnectionSecretToRef.BuilderContext": ...

        def write_connection_secret_to_ref(self, value_or_callback=None, /):
            """
            WriteConnectionSecretToReference specifies the namespace and name of a
            Secret to which any connection details for this managed resource should
            be written. Connection details frequently include the endpoint, username,
            and password required to connect to the managed resource.
            This field is planned to be replaced in a future release in favor of
            PublishConnectionDetailsTo. Currently, both could be set independently
            and connection details would be published to both without affecting
            each other.
            """
            if self._in_context and value_or_callback is None:
                context = WriteConnectionSecretToRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "write_connection_secret_to_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(WriteConnectionSecretToRef.builder())
                if isinstance(output, WriteConnectionSecretToRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("write_connection_secret_to_ref", value)

    class BuilderContext(BuilderContextBase["MySQLConfigSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = MySQLConfigSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for MySQLConfigSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["MySQLConfigSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use MySQLConfigSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    deletion_policy: Annotated[
        Optional[Literal["Orphan", "Delete"]], Field(alias="deletionPolicy")
    ] = "Delete"
    """
    DeletionPolicy specifies what will happen to the underlying external
    when this managed resource is deleted - either "Delete" or "Orphan" the
    external resource.
    This field is planned to be deprecated in favor of the ManagementPolicies
    field in a future release. Currently, both could be set independently and
    non-default values would be honored if the feature flag is enabled.
    See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    """
    for_provider: Annotated[ForProviderModel4, Field(alias="forProvider")]
    init_provider: Annotated[Optional[InitProviderModel4], Field(alias="initProvider")] = None
    """
    THIS IS A BETA FIELD. It will be honored
    unless the Management Policies feature flag is disabled.
    InitProvider holds the same fields as ForProvider, with the exception
    of Identifier and other resource reference fields. The fields that are
    in InitProvider are merged into ForProvider when the resource is created.
    The same fields are also added to the terraform ignore_changes hook, to
    avoid updating them after creation. This is useful for fields that are
    required on creation, but we do not desire to update them after creation,
    for example because of an external controller is managing them, like an
    autoscaler.
    """
    management_policies: Annotated[
        Optional[List[Literal["Observe", "Create", "Update", "Delete", "LateInitialize", "*"]]],
        Field(alias="managementPolicies"),
    ] = ["*"]
    """
    THIS IS A BETA FIELD. It is on by default but can be opted out
    through a Crossplane feature flag.
    ManagementPolicies specify the array of actions Crossplane is allowed to
    take on the managed and external resources.
    This field is planned to replace the DeletionPolicy field in a future
    release. Currently, both could be set independently and non-default
    values would be honored if the feature flag is enabled. If both are
    custom, the DeletionPolicy field will be ignored.
    See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
    """
    provider_config_ref: Annotated[
        Optional[ProviderConfigRef],
        Field(
            default_factory=lambda: ProviderConfigRef.model_validate({"name": "default"}),
            alias="providerConfigRef",
        ),
    ] = {"name": "default"}
    """
    ProviderConfigReference specifies how the provider that will be used to
    create, observe, update, and delete this managed resource should be
    configured.
    """
    publish_connection_details_to: Annotated[
        Optional[PublishConnectionDetailsTo], Field(alias="publishConnectionDetailsTo")
    ] = None
    """
    PublishConnectionDetailsTo specifies the connection secret config which
    contains a name, metadata and a reference to secret store config to
    which any connection details for this managed resource should be written.
    Connection details frequently include the endpoint, username,
    and password required to connect to the managed resource.
    """
    write_connection_secret_to_ref: Annotated[
        Optional[WriteConnectionSecretToRef], Field(alias="writeConnectionSecretToRef")
    ] = None
    """
    WriteConnectionSecretToReference specifies the namespace and name of a
    Secret to which any connection details for this managed resource should
    be written. Connection details frequently include the endpoint, username,
    and password required to connect to the managed resource.
    This field is planned to be replaced in a future release in favor of
    PublishConnectionDetailsTo. Currently, both could be set independently
    and connection details would be published to both without affecting
    each other.
    """


class AtProviderModel4(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AtProviderModel4"]:
            return AtProviderModel4

        def build(self) -> "AtProviderModel4":
            return AtProviderModel4(**self._attrs)

        def backup_hour(self, value: Optional[float], /) -> Self:
            """
            The hour of day (in UTC) when backup for the service starts. New backup only starts if previous backup has already completed.
            """
            return self._set("backup_hour", value)

        def backup_minute(self, value: Optional[float], /) -> Self:
            """
            The minute of the backup hour when backup for the service starts. New backup only starts if previous backup has already completed.
            """
            return self._set("backup_minute", value)

        def binlog_retention_period(self, value: Optional[float], /) -> Self:
            """
            The minimum amount of time, in seconds, to keep binlog entries before deletion. This may be extended for services that require binlog entries for longer than the default, for example if using the MySQL Debezium Kafka connector.
            """
            return self._set("binlog_retention_period", value)

        def cluster_id(self, value: Optional[str], /) -> Self:
            """
            The ID of the target MySQL cluster.
            """
            return self._set("cluster_id", value)

        def connect_timeout(self, value: Optional[float], /) -> Self:
            """
            The number of seconds that the mysqld server waits for a connect packet before responding with bad handshake.
            """
            return self._set("connect_timeout", value)

        def default_time_zone(self, value: Optional[str], /) -> Self:
            """
            Default server time zone, in the form of an offset from UTC (from -12:00 to +12:00), a time zone name (EST), or SYSTEM to use the MySQL server default.
            """
            return self._set("default_time_zone", value)

        def group_concat_max_len(self, value: Optional[float], /) -> Self:
            """
            The maximum permitted result length, in bytes, for the GROUP_CONCAT() function.
            """
            return self._set("group_concat_max_len", value)

        def id(self, value: Optional[str], /) -> Self:
            return self._set("id", value)

        def information_schema_stats_expiry(self, value: Optional[float], /) -> Self:
            """
            The time, in seconds, before cached statistics expire.
            """
            return self._set("information_schema_stats_expiry", value)

        def innodb_ft_min_token_size(self, value: Optional[float], /) -> Self:
            """
            The minimum length of words that an InnoDB FULLTEXT index stores.
            """
            return self._set("innodb_ft_min_token_size", value)

        def innodb_ft_server_stopword_table(self, value: Optional[str], /) -> Self:
            """
            The InnoDB FULLTEXT index stopword list for all InnoDB tables.
            """
            return self._set("innodb_ft_server_stopword_table", value)

        def innodb_lock_wait_timeout(self, value: Optional[float], /) -> Self:
            """
            The time, in seconds, that an InnoDB transaction waits for a row lock. before giving up.
            """
            return self._set("innodb_lock_wait_timeout", value)

        def innodb_log_buffer_size(self, value: Optional[float], /) -> Self:
            """
            The size of the buffer, in bytes, that InnoDB uses to write to the log files. on disk.
            """
            return self._set("innodb_log_buffer_size", value)

        def innodb_online_alter_log_max_size(self, value: Optional[float], /) -> Self:
            """
            The upper limit, in bytes, of the size of the temporary log files used during online DDL operations for InnoDB tables.
            """
            return self._set("innodb_online_alter_log_max_size", value)

        def innodb_print_all_deadlocks(self, value: Optional[bool], /) -> Self:
            """
            When enabled, records information about all deadlocks in InnoDB user transactions in the error log. Disabled by default.
            """
            return self._set("innodb_print_all_deadlocks", value)

        def innodb_rollback_on_timeout(self, value: Optional[bool], /) -> Self:
            """
            When enabled, transaction timeouts cause InnoDB to abort and roll back the entire transaction.
            """
            return self._set("innodb_rollback_on_timeout", value)

        def interactive_timeout(self, value: Optional[float], /) -> Self:
            """
            The time, in seconds, the server waits for activity on an interactive. connection before closing it.
            """
            return self._set("interactive_timeout", value)

        def internal_tmp_mem_storage_engine(self, value: Optional[str], /) -> Self:
            """
            The storage engine for in-memory internal temporary tables. Supported values are: TempTable, MEMORY.
            """
            return self._set("internal_tmp_mem_storage_engine", value)

        def long_query_time(self, value: Optional[float], /) -> Self:
            """
            The time, in seconds, for a query to take to execute before being captured by slow_query_logs. Default is 10 seconds.
            """
            return self._set("long_query_time", value)

        def max_allowed_packet(self, value: Optional[float], /) -> Self:
            """
            The size of the largest message, in bytes, that can be received by the server. Default is 67108864 (64M).
            """
            return self._set("max_allowed_packet", value)

        def max_heap_table_size(self, value: Optional[float], /) -> Self:
            """
            The maximum size, in bytes, of internal in-memory tables. Also set tmp_table_size. Default is 16777216 (16M)
            """
            return self._set("max_heap_table_size", value)

        def net_read_timeout(self, value: Optional[float], /) -> Self:
            """
            The time, in seconds, to wait for more data from an existing connection. aborting the read.
            """
            return self._set("net_read_timeout", value)

        def net_write_timeout(self, value: Optional[float], /) -> Self:
            """
            The number of seconds to wait for a block to be written to a connection before aborting the write.
            """
            return self._set("net_write_timeout", value)

        def slow_query_log(self, value: Optional[bool], /) -> Self:
            """
            When enabled, captures slow queries. When disabled, also truncates the mysql.slow_log table. Default is false.
            """
            return self._set("slow_query_log", value)

        def sort_buffer_size(self, value: Optional[float], /) -> Self:
            """
            The sort buffer size, in bytes, for ORDER BY optimization. Default is 262144. (256K).
            """
            return self._set("sort_buffer_size", value)

        def sql_mode(self, value: Optional[str], /) -> Self:
            """
            Global SQL mode. If empty, uses MySQL server defaults. Must only include uppercase alphabetic characters, underscores, and commas.
            """
            return self._set("sql_mode", value)

        def sql_require_primary_key(self, value: Optional[bool], /) -> Self:
            """
            Require primary key to be defined for new tables or old tables modified with ALTER TABLE and fail if missing. It is recommended to always have primary keys because various functionality may break if any large table is missing them.
            """
            return self._set("sql_require_primary_key", value)

        def tmp_table_size(self, value: Optional[float], /) -> Self:
            """
            The maximum size, in bytes, of internal in-memory tables. Also set max_heap_table_size. Default is 16777216 (16M).
            """
            return self._set("tmp_table_size", value)

        def wait_timeout(self, value: Optional[float], /) -> Self:
            """
            The number of seconds the server waits for activity on a noninteractive connection before closing it.
            """
            return self._set("wait_timeout", value)

    class BuilderContext(BuilderContextBase["AtProviderModel4.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AtProviderModel4.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AtProviderModel4."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AtProviderModel4", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AtProviderModel4.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    backup_hour: Annotated[Optional[float], Field(alias="backupHour")] = None
    """
    The hour of day (in UTC) when backup for the service starts. New backup only starts if previous backup has already completed.
    """
    backup_minute: Annotated[Optional[float], Field(alias="backupMinute")] = None
    """
    The minute of the backup hour when backup for the service starts. New backup only starts if previous backup has already completed.
    """
    binlog_retention_period: Annotated[Optional[float], Field(alias="binlogRetentionPeriod")] = None
    """
    The minimum amount of time, in seconds, to keep binlog entries before deletion. This may be extended for services that require binlog entries for longer than the default, for example if using the MySQL Debezium Kafka connector.
    """
    cluster_id: Annotated[Optional[str], Field(alias="clusterId")] = None
    """
    The ID of the target MySQL cluster.
    """
    connect_timeout: Annotated[Optional[float], Field(alias="connectTimeout")] = None
    """
    The number of seconds that the mysqld server waits for a connect packet before responding with bad handshake.
    """
    default_time_zone: Annotated[Optional[str], Field(alias="defaultTimeZone")] = None
    """
    Default server time zone, in the form of an offset from UTC (from -12:00 to +12:00), a time zone name (EST), or SYSTEM to use the MySQL server default.
    """
    group_concat_max_len: Annotated[Optional[float], Field(alias="groupConcatMaxLen")] = None
    """
    The maximum permitted result length, in bytes, for the GROUP_CONCAT() function.
    """
    id: Optional[str] = None
    information_schema_stats_expiry: Annotated[
        Optional[float], Field(alias="informationSchemaStatsExpiry")
    ] = None
    """
    The time, in seconds, before cached statistics expire.
    """
    innodb_ft_min_token_size: Annotated[Optional[float], Field(alias="innodbFtMinTokenSize")] = None
    """
    The minimum length of words that an InnoDB FULLTEXT index stores.
    """
    innodb_ft_server_stopword_table: Annotated[
        Optional[str], Field(alias="innodbFtServerStopwordTable")
    ] = None
    """
    The InnoDB FULLTEXT index stopword list for all InnoDB tables.
    """
    innodb_lock_wait_timeout: Annotated[Optional[float], Field(alias="innodbLockWaitTimeout")] = (
        None
    )
    """
    The time, in seconds, that an InnoDB transaction waits for a row lock. before giving up.
    """
    innodb_log_buffer_size: Annotated[Optional[float], Field(alias="innodbLogBufferSize")] = None
    """
    The size of the buffer, in bytes, that InnoDB uses to write to the log files. on disk.
    """
    innodb_online_alter_log_max_size: Annotated[
        Optional[float], Field(alias="innodbOnlineAlterLogMaxSize")
    ] = None
    """
    The upper limit, in bytes, of the size of the temporary log files used during online DDL operations for InnoDB tables.
    """
    innodb_print_all_deadlocks: Annotated[
        Optional[bool], Field(alias="innodbPrintAllDeadlocks")
    ] = None
    """
    When enabled, records information about all deadlocks in InnoDB user transactions in the error log. Disabled by default.
    """
    innodb_rollback_on_timeout: Annotated[
        Optional[bool], Field(alias="innodbRollbackOnTimeout")
    ] = None
    """
    When enabled, transaction timeouts cause InnoDB to abort and roll back the entire transaction.
    """
    interactive_timeout: Annotated[Optional[float], Field(alias="interactiveTimeout")] = None
    """
    The time, in seconds, the server waits for activity on an interactive. connection before closing it.
    """
    internal_tmp_mem_storage_engine: Annotated[
        Optional[str], Field(alias="internalTmpMemStorageEngine")
    ] = None
    """
    The storage engine for in-memory internal temporary tables. Supported values are: TempTable, MEMORY.
    """
    long_query_time: Annotated[Optional[float], Field(alias="longQueryTime")] = None
    """
    The time, in seconds, for a query to take to execute before being captured by slow_query_logs. Default is 10 seconds.
    """
    max_allowed_packet: Annotated[Optional[float], Field(alias="maxAllowedPacket")] = None
    """
    The size of the largest message, in bytes, that can be received by the server. Default is 67108864 (64M).
    """
    max_heap_table_size: Annotated[Optional[float], Field(alias="maxHeapTableSize")] = None
    """
    The maximum size, in bytes, of internal in-memory tables. Also set tmp_table_size. Default is 16777216 (16M)
    """
    net_read_timeout: Annotated[Optional[float], Field(alias="netReadTimeout")] = None
    """
    The time, in seconds, to wait for more data from an existing connection. aborting the read.
    """
    net_write_timeout: Annotated[Optional[float], Field(alias="netWriteTimeout")] = None
    """
    The number of seconds to wait for a block to be written to a connection before aborting the write.
    """
    slow_query_log: Annotated[Optional[bool], Field(alias="slowQueryLog")] = None
    """
    When enabled, captures slow queries. When disabled, also truncates the mysql.slow_log table. Default is false.
    """
    sort_buffer_size: Annotated[Optional[float], Field(alias="sortBufferSize")] = None
    """
    The sort buffer size, in bytes, for ORDER BY optimization. Default is 262144. (256K).
    """
    sql_mode: Annotated[Optional[str], Field(alias="sqlMode")] = None
    """
    Global SQL mode. If empty, uses MySQL server defaults. Must only include uppercase alphabetic characters, underscores, and commas.
    """
    sql_require_primary_key: Annotated[Optional[bool], Field(alias="sqlRequirePrimaryKey")] = None
    """
    Require primary key to be defined for new tables or old tables modified with ALTER TABLE and fail if missing. It is recommended to always have primary keys because various functionality may break if any large table is missing them.
    """
    tmp_table_size: Annotated[Optional[float], Field(alias="tmpTableSize")] = None
    """
    The maximum size, in bytes, of internal in-memory tables. Also set max_heap_table_size. Default is 16777216 (16M).
    """
    wait_timeout: Annotated[Optional[float], Field(alias="waitTimeout")] = None
    """
    The number of seconds the server waits for activity on a noninteractive connection before closing it.
    """


class MySQLConfigStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["MySQLConfigStatus"]:
            return MySQLConfigStatus

        def build(self) -> "MySQLConfigStatus":
            return MySQLConfigStatus(**self._attrs)

        @overload
        def at_provider(
            self, value_or_callback: Optional[AtProviderModel4], /
        ) -> "MySQLConfigStatus.Builder": ...

        @overload
        def at_provider(
            self,
            value_or_callback: Callable[
                [AtProviderModel4.Builder], AtProviderModel4.Builder | AtProviderModel4
            ],
            /,
        ) -> "MySQLConfigStatus.Builder": ...

        @overload
        def at_provider(
            self, value_or_callback: Never = ...
        ) -> "AtProviderModel4.BuilderContext": ...

        def at_provider(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = AtProviderModel4.BuilderContext()
                context._parent_builder = self
                context._field_name = "at_provider"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AtProviderModel4.builder())
                if isinstance(output, AtProviderModel4.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("at_provider", value)

        @overload
        def conditions(
            self, value_or_callback: List[Condition], /
        ) -> "MySQLConfigStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Condition, Condition.Builder]],
                GenericListBuilder[Condition, Condition.Builder] | List[Condition],
            ],
            /,
        ) -> "MySQLConfigStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            """
            Conditions of the resource.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        def observed_generation(self, value: Optional[int], /) -> Self:
            """
            ObservedGeneration is the latest metadata.generation
            which resulted in either a ready state, or stalled due to error
            it can not recover from without human intervention.
            """
            return self._set("observed_generation", value)

    class BuilderContext(BuilderContextBase["MySQLConfigStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = MySQLConfigStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for MySQLConfigStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["MySQLConfigStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use MySQLConfigStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    at_provider: Annotated[Optional[AtProviderModel4], Field(alias="atProvider")] = None
    conditions: Optional[List[Condition]] = None
    """
    Conditions of the resource.
    """
    observed_generation: Annotated[Optional[int], Field(alias="observedGeneration")] = None
    """
    ObservedGeneration is the latest metadata.generation
    which resulted in either a ready state, or stalled due to error
    it can not recover from without human intervention.
    """


class ForProviderModel5(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ForProviderModel5"]:
            return ForProviderModel5

        def build(self) -> "ForProviderModel5":
            return ForProviderModel5(**self._attrs)

        def acl_channels_default(self, value: Optional[str], /) -> Self:
            """
            Determines default pub/sub channels' ACL for new users if an ACL is not supplied. When this option is not defined, allchannels is assumed to keep backward compatibility. This option doesn't affect Redis' acl-pubsub-default configuration. Supported values are: allchannels and resetchannels
            """
            return self._set("acl_channels_default", value)

        def cluster_id(self, value: Optional[str], /) -> Self:
            """
            The ID of the target Redis cluster.
            """
            return self._set("cluster_id", value)

        @overload
        def cluster_id_ref(
            self, value_or_callback: Optional[ClusterIdRef], /
        ) -> "ForProviderModel5.Builder": ...

        @overload
        def cluster_id_ref(
            self,
            value_or_callback: Callable[
                [ClusterIdRef.Builder], ClusterIdRef.Builder | ClusterIdRef
            ],
            /,
        ) -> "ForProviderModel5.Builder": ...

        @overload
        def cluster_id_ref(
            self, value_or_callback: Never = ...
        ) -> "ClusterIdRef.BuilderContext": ...

        def cluster_id_ref(self, value_or_callback=None, /):
            """
            Reference to a Cluster in database to populate clusterId.
            """
            if self._in_context and value_or_callback is None:
                context = ClusterIdRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "cluster_id_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ClusterIdRef.builder())
                if isinstance(output, ClusterIdRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("cluster_id_ref", value)

        @overload
        def cluster_id_selector(
            self, value_or_callback: Optional[ClusterIdSelector], /
        ) -> "ForProviderModel5.Builder": ...

        @overload
        def cluster_id_selector(
            self,
            value_or_callback: Callable[
                [ClusterIdSelector.Builder],
                ClusterIdSelector.Builder | ClusterIdSelector,
            ],
            /,
        ) -> "ForProviderModel5.Builder": ...

        @overload
        def cluster_id_selector(
            self, value_or_callback: Never = ...
        ) -> "ClusterIdSelector.BuilderContext": ...

        def cluster_id_selector(self, value_or_callback=None, /):
            """
            Selector for a Cluster in database to populate clusterId.
            """
            if self._in_context and value_or_callback is None:
                context = ClusterIdSelector.BuilderContext()
                context._parent_builder = self
                context._field_name = "cluster_id_selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ClusterIdSelector.builder())
                if isinstance(output, ClusterIdSelector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("cluster_id_selector", value)

        def io_threads(self, value: Optional[float], /) -> Self:
            """
            The Redis IO thread count.
            """
            return self._set("io_threads", value)

        def lfu_decay_time(self, value: Optional[float], /) -> Self:
            """
            The LFU maxmemory policy counter decay time in minutes.
            """
            return self._set("lfu_decay_time", value)

        def lfu_log_factor(self, value: Optional[float], /) -> Self:
            """
            The counter logarithm factor for volatile-lfu and allkeys-lfu maxmemory policies.
            """
            return self._set("lfu_log_factor", value)

        def maxmemory_policy(self, value: Optional[str], /) -> Self:
            """
            A string specifying the desired eviction policy for the Redis cluster.Supported values are: noeviction, allkeys-lru, allkeys-random, volatile-lru, volatile-random, volatile-ttl
            """
            return self._set("maxmemory_policy", value)

        def notify_keyspace_events(self, value: Optional[str], /) -> Self:
            """
            The notify-keyspace-events option. Requires at least K or E.
            """
            return self._set("notify_keyspace_events", value)

        def number_of_databases(self, value: Optional[float], /) -> Self:
            """
            The number of Redis databases. Changing this will cause a restart of Redis service.
            """
            return self._set("number_of_databases", value)

        def persistence(self, value: Optional[str], /) -> Self:
            """
            When persistence is rdb, Redis does RDB dumps each 10 minutes if any key is changed. Also RDB dumps are done according to backup schedule for backup purposes. When persistence is off, no RDB dumps and backups are done, so data can be lost at any moment if service is restarted for any reason, or if service is powered off. Also service can't be forked.
            """
            return self._set("persistence", value)

        def pubsub_client_output_buffer_limit(self, value: Optional[float], /) -> Self:
            """
            The output buffer limit for pub/sub clients in MB. The value is the hard limit, the soft limit is 1/4 of the hard limit. When setting the limit, be mindful of the available memory in the selected service plan.
            """
            return self._set("pubsub_client_output_buffer_limit", value)

        def ssl(self, value: Optional[bool], /) -> Self:
            """
            A boolean indicating whether to require SSL to access Redis.
            """
            return self._set("ssl", value)

        def timeout(self, value: Optional[float], /) -> Self:
            """
            The Redis idle connection timeout in seconds.
            """
            return self._set("timeout", value)

    class BuilderContext(BuilderContextBase["ForProviderModel5.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ForProviderModel5.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ForProviderModel5."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ForProviderModel5", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ForProviderModel5.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    acl_channels_default: Annotated[Optional[str], Field(alias="aclChannelsDefault")] = None
    """
    Determines default pub/sub channels' ACL for new users if an ACL is not supplied. When this option is not defined, allchannels is assumed to keep backward compatibility. This option doesn't affect Redis' acl-pubsub-default configuration. Supported values are: allchannels and resetchannels
    """
    cluster_id: Annotated[Optional[str], Field(alias="clusterId")] = None
    """
    The ID of the target Redis cluster.
    """
    cluster_id_ref: Annotated[Optional[ClusterIdRef], Field(alias="clusterIdRef")] = None
    """
    Reference to a Cluster in database to populate clusterId.
    """
    cluster_id_selector: Annotated[
        Optional[ClusterIdSelector], Field(alias="clusterIdSelector")
    ] = None
    """
    Selector for a Cluster in database to populate clusterId.
    """
    io_threads: Annotated[Optional[float], Field(alias="ioThreads")] = None
    """
    The Redis IO thread count.
    """
    lfu_decay_time: Annotated[Optional[float], Field(alias="lfuDecayTime")] = None
    """
    The LFU maxmemory policy counter decay time in minutes.
    """
    lfu_log_factor: Annotated[Optional[float], Field(alias="lfuLogFactor")] = None
    """
    The counter logarithm factor for volatile-lfu and allkeys-lfu maxmemory policies.
    """
    maxmemory_policy: Annotated[Optional[str], Field(alias="maxmemoryPolicy")] = None
    """
    A string specifying the desired eviction policy for the Redis cluster.Supported values are: noeviction, allkeys-lru, allkeys-random, volatile-lru, volatile-random, volatile-ttl
    """
    notify_keyspace_events: Annotated[Optional[str], Field(alias="notifyKeyspaceEvents")] = None
    """
    The notify-keyspace-events option. Requires at least K or E.
    """
    number_of_databases: Annotated[Optional[float], Field(alias="numberOfDatabases")] = None
    """
    The number of Redis databases. Changing this will cause a restart of Redis service.
    """
    persistence: Optional[str] = None
    """
    When persistence is rdb, Redis does RDB dumps each 10 minutes if any key is changed. Also RDB dumps are done according to backup schedule for backup purposes. When persistence is off, no RDB dumps and backups are done, so data can be lost at any moment if service is restarted for any reason, or if service is powered off. Also service can't be forked.
    """
    pubsub_client_output_buffer_limit: Annotated[
        Optional[float], Field(alias="pubsubClientOutputBufferLimit")
    ] = None
    """
    The output buffer limit for pub/sub clients in MB. The value is the hard limit, the soft limit is 1/4 of the hard limit. When setting the limit, be mindful of the available memory in the selected service plan.
    """
    ssl: Optional[bool] = None
    """
    A boolean indicating whether to require SSL to access Redis.
    """
    timeout: Optional[float] = None
    """
    The Redis idle connection timeout in seconds.
    """


class InitProviderModel5(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["InitProviderModel5"]:
            return InitProviderModel5

        def build(self) -> "InitProviderModel5":
            return InitProviderModel5(**self._attrs)

        def acl_channels_default(self, value: Optional[str], /) -> Self:
            """
            Determines default pub/sub channels' ACL for new users if an ACL is not supplied. When this option is not defined, allchannels is assumed to keep backward compatibility. This option doesn't affect Redis' acl-pubsub-default configuration. Supported values are: allchannels and resetchannels
            """
            return self._set("acl_channels_default", value)

        def cluster_id(self, value: Optional[str], /) -> Self:
            """
            The ID of the target Redis cluster.
            """
            return self._set("cluster_id", value)

        @overload
        def cluster_id_ref(
            self, value_or_callback: Optional[ClusterIdRef], /
        ) -> "InitProviderModel5.Builder": ...

        @overload
        def cluster_id_ref(
            self,
            value_or_callback: Callable[
                [ClusterIdRef.Builder], ClusterIdRef.Builder | ClusterIdRef
            ],
            /,
        ) -> "InitProviderModel5.Builder": ...

        @overload
        def cluster_id_ref(
            self, value_or_callback: Never = ...
        ) -> "ClusterIdRef.BuilderContext": ...

        def cluster_id_ref(self, value_or_callback=None, /):
            """
            Reference to a Cluster in database to populate clusterId.
            """
            if self._in_context and value_or_callback is None:
                context = ClusterIdRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "cluster_id_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ClusterIdRef.builder())
                if isinstance(output, ClusterIdRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("cluster_id_ref", value)

        @overload
        def cluster_id_selector(
            self, value_or_callback: Optional[ClusterIdSelector], /
        ) -> "InitProviderModel5.Builder": ...

        @overload
        def cluster_id_selector(
            self,
            value_or_callback: Callable[
                [ClusterIdSelector.Builder],
                ClusterIdSelector.Builder | ClusterIdSelector,
            ],
            /,
        ) -> "InitProviderModel5.Builder": ...

        @overload
        def cluster_id_selector(
            self, value_or_callback: Never = ...
        ) -> "ClusterIdSelector.BuilderContext": ...

        def cluster_id_selector(self, value_or_callback=None, /):
            """
            Selector for a Cluster in database to populate clusterId.
            """
            if self._in_context and value_or_callback is None:
                context = ClusterIdSelector.BuilderContext()
                context._parent_builder = self
                context._field_name = "cluster_id_selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ClusterIdSelector.builder())
                if isinstance(output, ClusterIdSelector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("cluster_id_selector", value)

        def io_threads(self, value: Optional[float], /) -> Self:
            """
            The Redis IO thread count.
            """
            return self._set("io_threads", value)

        def lfu_decay_time(self, value: Optional[float], /) -> Self:
            """
            The LFU maxmemory policy counter decay time in minutes.
            """
            return self._set("lfu_decay_time", value)

        def lfu_log_factor(self, value: Optional[float], /) -> Self:
            """
            The counter logarithm factor for volatile-lfu and allkeys-lfu maxmemory policies.
            """
            return self._set("lfu_log_factor", value)

        def maxmemory_policy(self, value: Optional[str], /) -> Self:
            """
            A string specifying the desired eviction policy for the Redis cluster.Supported values are: noeviction, allkeys-lru, allkeys-random, volatile-lru, volatile-random, volatile-ttl
            """
            return self._set("maxmemory_policy", value)

        def notify_keyspace_events(self, value: Optional[str], /) -> Self:
            """
            The notify-keyspace-events option. Requires at least K or E.
            """
            return self._set("notify_keyspace_events", value)

        def number_of_databases(self, value: Optional[float], /) -> Self:
            """
            The number of Redis databases. Changing this will cause a restart of Redis service.
            """
            return self._set("number_of_databases", value)

        def persistence(self, value: Optional[str], /) -> Self:
            """
            When persistence is rdb, Redis does RDB dumps each 10 minutes if any key is changed. Also RDB dumps are done according to backup schedule for backup purposes. When persistence is off, no RDB dumps and backups are done, so data can be lost at any moment if service is restarted for any reason, or if service is powered off. Also service can't be forked.
            """
            return self._set("persistence", value)

        def pubsub_client_output_buffer_limit(self, value: Optional[float], /) -> Self:
            """
            The output buffer limit for pub/sub clients in MB. The value is the hard limit, the soft limit is 1/4 of the hard limit. When setting the limit, be mindful of the available memory in the selected service plan.
            """
            return self._set("pubsub_client_output_buffer_limit", value)

        def ssl(self, value: Optional[bool], /) -> Self:
            """
            A boolean indicating whether to require SSL to access Redis.
            """
            return self._set("ssl", value)

        def timeout(self, value: Optional[float], /) -> Self:
            """
            The Redis idle connection timeout in seconds.
            """
            return self._set("timeout", value)

    class BuilderContext(BuilderContextBase["InitProviderModel5.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = InitProviderModel5.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for InitProviderModel5."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["InitProviderModel5", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use InitProviderModel5.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    acl_channels_default: Annotated[Optional[str], Field(alias="aclChannelsDefault")] = None
    """
    Determines default pub/sub channels' ACL for new users if an ACL is not supplied. When this option is not defined, allchannels is assumed to keep backward compatibility. This option doesn't affect Redis' acl-pubsub-default configuration. Supported values are: allchannels and resetchannels
    """
    cluster_id: Annotated[Optional[str], Field(alias="clusterId")] = None
    """
    The ID of the target Redis cluster.
    """
    cluster_id_ref: Annotated[Optional[ClusterIdRef], Field(alias="clusterIdRef")] = None
    """
    Reference to a Cluster in database to populate clusterId.
    """
    cluster_id_selector: Annotated[
        Optional[ClusterIdSelector], Field(alias="clusterIdSelector")
    ] = None
    """
    Selector for a Cluster in database to populate clusterId.
    """
    io_threads: Annotated[Optional[float], Field(alias="ioThreads")] = None
    """
    The Redis IO thread count.
    """
    lfu_decay_time: Annotated[Optional[float], Field(alias="lfuDecayTime")] = None
    """
    The LFU maxmemory policy counter decay time in minutes.
    """
    lfu_log_factor: Annotated[Optional[float], Field(alias="lfuLogFactor")] = None
    """
    The counter logarithm factor for volatile-lfu and allkeys-lfu maxmemory policies.
    """
    maxmemory_policy: Annotated[Optional[str], Field(alias="maxmemoryPolicy")] = None
    """
    A string specifying the desired eviction policy for the Redis cluster.Supported values are: noeviction, allkeys-lru, allkeys-random, volatile-lru, volatile-random, volatile-ttl
    """
    notify_keyspace_events: Annotated[Optional[str], Field(alias="notifyKeyspaceEvents")] = None
    """
    The notify-keyspace-events option. Requires at least K or E.
    """
    number_of_databases: Annotated[Optional[float], Field(alias="numberOfDatabases")] = None
    """
    The number of Redis databases. Changing this will cause a restart of Redis service.
    """
    persistence: Optional[str] = None
    """
    When persistence is rdb, Redis does RDB dumps each 10 minutes if any key is changed. Also RDB dumps are done according to backup schedule for backup purposes. When persistence is off, no RDB dumps and backups are done, so data can be lost at any moment if service is restarted for any reason, or if service is powered off. Also service can't be forked.
    """
    pubsub_client_output_buffer_limit: Annotated[
        Optional[float], Field(alias="pubsubClientOutputBufferLimit")
    ] = None
    """
    The output buffer limit for pub/sub clients in MB. The value is the hard limit, the soft limit is 1/4 of the hard limit. When setting the limit, be mindful of the available memory in the selected service plan.
    """
    ssl: Optional[bool] = None
    """
    A boolean indicating whether to require SSL to access Redis.
    """
    timeout: Optional[float] = None
    """
    The Redis idle connection timeout in seconds.
    """


class RedisConfigSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["RedisConfigSpec"]:
            return RedisConfigSpec

        def build(self) -> "RedisConfigSpec":
            return RedisConfigSpec(**self._attrs)

        def deletion_policy(self, value: Optional[Literal["Orphan", "Delete"]], /) -> Self:
            """
            DeletionPolicy specifies what will happen to the underlying external
            when this managed resource is deleted - either "Delete" or "Orphan" the
            external resource.
            This field is planned to be deprecated in favor of the ManagementPolicies
            field in a future release. Currently, both could be set independently and
            non-default values would be honored if the feature flag is enabled.
            See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
            """
            return self._set("deletion_policy", value)

        @overload
        def for_provider(
            self, value_or_callback: ForProviderModel5, /
        ) -> "RedisConfigSpec.Builder": ...

        @overload
        def for_provider(
            self,
            value_or_callback: Callable[
                [ForProviderModel5.Builder],
                ForProviderModel5.Builder | ForProviderModel5,
            ],
            /,
        ) -> "RedisConfigSpec.Builder": ...

        @overload
        def for_provider(
            self, value_or_callback: Never = ...
        ) -> "ForProviderModel5.BuilderContext": ...

        def for_provider(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ForProviderModel5.BuilderContext()
                context._parent_builder = self
                context._field_name = "for_provider"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ForProviderModel5.builder())
                if isinstance(output, ForProviderModel5.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("for_provider", value)

        @overload
        def init_provider(
            self, value_or_callback: Optional[InitProviderModel5], /
        ) -> "RedisConfigSpec.Builder": ...

        @overload
        def init_provider(
            self,
            value_or_callback: Callable[
                [InitProviderModel5.Builder],
                InitProviderModel5.Builder | InitProviderModel5,
            ],
            /,
        ) -> "RedisConfigSpec.Builder": ...

        @overload
        def init_provider(
            self, value_or_callback: Never = ...
        ) -> "InitProviderModel5.BuilderContext": ...

        def init_provider(self, value_or_callback=None, /):
            """
            THIS IS A BETA FIELD. It will be honored
            unless the Management Policies feature flag is disabled.
            InitProvider holds the same fields as ForProvider, with the exception
            of Identifier and other resource reference fields. The fields that are
            in InitProvider are merged into ForProvider when the resource is created.
            The same fields are also added to the terraform ignore_changes hook, to
            avoid updating them after creation. This is useful for fields that are
            required on creation, but we do not desire to update them after creation,
            for example because of an external controller is managing them, like an
            autoscaler.
            """
            if self._in_context and value_or_callback is None:
                context = InitProviderModel5.BuilderContext()
                context._parent_builder = self
                context._field_name = "init_provider"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(InitProviderModel5.builder())
                if isinstance(output, InitProviderModel5.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("init_provider", value)

        def management_policies(
            self,
            value: Optional[
                List[Literal["Observe", "Create", "Update", "Delete", "LateInitialize", "*"]]
            ],
            /,
        ) -> Self:
            """
            THIS IS A BETA FIELD. It is on by default but can be opted out
            through a Crossplane feature flag.
            ManagementPolicies specify the array of actions Crossplane is allowed to
            take on the managed and external resources.
            This field is planned to replace the DeletionPolicy field in a future
            release. Currently, both could be set independently and non-default
            values would be honored if the feature flag is enabled. If both are
            custom, the DeletionPolicy field will be ignored.
            See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
            and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
            """
            return self._set("management_policies", value)

        @overload
        def provider_config_ref(
            self, value_or_callback: Optional[ProviderConfigRef], /
        ) -> "RedisConfigSpec.Builder": ...

        @overload
        def provider_config_ref(
            self,
            value_or_callback: Callable[
                [ProviderConfigRef.Builder],
                ProviderConfigRef.Builder | ProviderConfigRef,
            ],
            /,
        ) -> "RedisConfigSpec.Builder": ...

        @overload
        def provider_config_ref(
            self, value_or_callback: Never = ...
        ) -> "ProviderConfigRef.BuilderContext": ...

        def provider_config_ref(self, value_or_callback=None, /):
            """
            ProviderConfigReference specifies how the provider that will be used to
            create, observe, update, and delete this managed resource should be
            configured.
            """
            if self._in_context and value_or_callback is None:
                context = ProviderConfigRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "provider_config_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ProviderConfigRef.builder())
                if isinstance(output, ProviderConfigRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("provider_config_ref", value)

        @overload
        def publish_connection_details_to(
            self, value_or_callback: Optional[PublishConnectionDetailsTo], /
        ) -> "RedisConfigSpec.Builder": ...

        @overload
        def publish_connection_details_to(
            self,
            value_or_callback: Callable[
                [PublishConnectionDetailsTo.Builder],
                PublishConnectionDetailsTo.Builder | PublishConnectionDetailsTo,
            ],
            /,
        ) -> "RedisConfigSpec.Builder": ...

        @overload
        def publish_connection_details_to(
            self, value_or_callback: Never = ...
        ) -> "PublishConnectionDetailsTo.BuilderContext": ...

        def publish_connection_details_to(self, value_or_callback=None, /):
            """
            PublishConnectionDetailsTo specifies the connection secret config which
            contains a name, metadata and a reference to secret store config to
            which any connection details for this managed resource should be written.
            Connection details frequently include the endpoint, username,
            and password required to connect to the managed resource.
            """
            if self._in_context and value_or_callback is None:
                context = PublishConnectionDetailsTo.BuilderContext()
                context._parent_builder = self
                context._field_name = "publish_connection_details_to"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PublishConnectionDetailsTo.builder())
                if isinstance(output, PublishConnectionDetailsTo.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("publish_connection_details_to", value)

        @overload
        def write_connection_secret_to_ref(
            self, value_or_callback: Optional[WriteConnectionSecretToRef], /
        ) -> "RedisConfigSpec.Builder": ...

        @overload
        def write_connection_secret_to_ref(
            self,
            value_or_callback: Callable[
                [WriteConnectionSecretToRef.Builder],
                WriteConnectionSecretToRef.Builder | WriteConnectionSecretToRef,
            ],
            /,
        ) -> "RedisConfigSpec.Builder": ...

        @overload
        def write_connection_secret_to_ref(
            self, value_or_callback: Never = ...
        ) -> "WriteConnectionSecretToRef.BuilderContext": ...

        def write_connection_secret_to_ref(self, value_or_callback=None, /):
            """
            WriteConnectionSecretToReference specifies the namespace and name of a
            Secret to which any connection details for this managed resource should
            be written. Connection details frequently include the endpoint, username,
            and password required to connect to the managed resource.
            This field is planned to be replaced in a future release in favor of
            PublishConnectionDetailsTo. Currently, both could be set independently
            and connection details would be published to both without affecting
            each other.
            """
            if self._in_context and value_or_callback is None:
                context = WriteConnectionSecretToRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "write_connection_secret_to_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(WriteConnectionSecretToRef.builder())
                if isinstance(output, WriteConnectionSecretToRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("write_connection_secret_to_ref", value)

    class BuilderContext(BuilderContextBase["RedisConfigSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = RedisConfigSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RedisConfigSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["RedisConfigSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use RedisConfigSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    deletion_policy: Annotated[
        Optional[Literal["Orphan", "Delete"]], Field(alias="deletionPolicy")
    ] = "Delete"
    """
    DeletionPolicy specifies what will happen to the underlying external
    when this managed resource is deleted - either "Delete" or "Orphan" the
    external resource.
    This field is planned to be deprecated in favor of the ManagementPolicies
    field in a future release. Currently, both could be set independently and
    non-default values would be honored if the feature flag is enabled.
    See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    """
    for_provider: Annotated[ForProviderModel5, Field(alias="forProvider")]
    init_provider: Annotated[Optional[InitProviderModel5], Field(alias="initProvider")] = None
    """
    THIS IS A BETA FIELD. It will be honored
    unless the Management Policies feature flag is disabled.
    InitProvider holds the same fields as ForProvider, with the exception
    of Identifier and other resource reference fields. The fields that are
    in InitProvider are merged into ForProvider when the resource is created.
    The same fields are also added to the terraform ignore_changes hook, to
    avoid updating them after creation. This is useful for fields that are
    required on creation, but we do not desire to update them after creation,
    for example because of an external controller is managing them, like an
    autoscaler.
    """
    management_policies: Annotated[
        Optional[List[Literal["Observe", "Create", "Update", "Delete", "LateInitialize", "*"]]],
        Field(alias="managementPolicies"),
    ] = ["*"]
    """
    THIS IS A BETA FIELD. It is on by default but can be opted out
    through a Crossplane feature flag.
    ManagementPolicies specify the array of actions Crossplane is allowed to
    take on the managed and external resources.
    This field is planned to replace the DeletionPolicy field in a future
    release. Currently, both could be set independently and non-default
    values would be honored if the feature flag is enabled. If both are
    custom, the DeletionPolicy field will be ignored.
    See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
    """
    provider_config_ref: Annotated[
        Optional[ProviderConfigRef],
        Field(
            default_factory=lambda: ProviderConfigRef.model_validate({"name": "default"}),
            alias="providerConfigRef",
        ),
    ] = {"name": "default"}
    """
    ProviderConfigReference specifies how the provider that will be used to
    create, observe, update, and delete this managed resource should be
    configured.
    """
    publish_connection_details_to: Annotated[
        Optional[PublishConnectionDetailsTo], Field(alias="publishConnectionDetailsTo")
    ] = None
    """
    PublishConnectionDetailsTo specifies the connection secret config which
    contains a name, metadata and a reference to secret store config to
    which any connection details for this managed resource should be written.
    Connection details frequently include the endpoint, username,
    and password required to connect to the managed resource.
    """
    write_connection_secret_to_ref: Annotated[
        Optional[WriteConnectionSecretToRef], Field(alias="writeConnectionSecretToRef")
    ] = None
    """
    WriteConnectionSecretToReference specifies the namespace and name of a
    Secret to which any connection details for this managed resource should
    be written. Connection details frequently include the endpoint, username,
    and password required to connect to the managed resource.
    This field is planned to be replaced in a future release in favor of
    PublishConnectionDetailsTo. Currently, both could be set independently
    and connection details would be published to both without affecting
    each other.
    """


class AtProviderModel5(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AtProviderModel5"]:
            return AtProviderModel5

        def build(self) -> "AtProviderModel5":
            return AtProviderModel5(**self._attrs)

        def acl_channels_default(self, value: Optional[str], /) -> Self:
            """
            Determines default pub/sub channels' ACL for new users if an ACL is not supplied. When this option is not defined, allchannels is assumed to keep backward compatibility. This option doesn't affect Redis' acl-pubsub-default configuration. Supported values are: allchannels and resetchannels
            """
            return self._set("acl_channels_default", value)

        def cluster_id(self, value: Optional[str], /) -> Self:
            """
            The ID of the target Redis cluster.
            """
            return self._set("cluster_id", value)

        def id(self, value: Optional[str], /) -> Self:
            return self._set("id", value)

        def io_threads(self, value: Optional[float], /) -> Self:
            """
            The Redis IO thread count.
            """
            return self._set("io_threads", value)

        def lfu_decay_time(self, value: Optional[float], /) -> Self:
            """
            The LFU maxmemory policy counter decay time in minutes.
            """
            return self._set("lfu_decay_time", value)

        def lfu_log_factor(self, value: Optional[float], /) -> Self:
            """
            The counter logarithm factor for volatile-lfu and allkeys-lfu maxmemory policies.
            """
            return self._set("lfu_log_factor", value)

        def maxmemory_policy(self, value: Optional[str], /) -> Self:
            """
            A string specifying the desired eviction policy for the Redis cluster.Supported values are: noeviction, allkeys-lru, allkeys-random, volatile-lru, volatile-random, volatile-ttl
            """
            return self._set("maxmemory_policy", value)

        def notify_keyspace_events(self, value: Optional[str], /) -> Self:
            """
            The notify-keyspace-events option. Requires at least K or E.
            """
            return self._set("notify_keyspace_events", value)

        def number_of_databases(self, value: Optional[float], /) -> Self:
            """
            The number of Redis databases. Changing this will cause a restart of Redis service.
            """
            return self._set("number_of_databases", value)

        def persistence(self, value: Optional[str], /) -> Self:
            """
            When persistence is rdb, Redis does RDB dumps each 10 minutes if any key is changed. Also RDB dumps are done according to backup schedule for backup purposes. When persistence is off, no RDB dumps and backups are done, so data can be lost at any moment if service is restarted for any reason, or if service is powered off. Also service can't be forked.
            """
            return self._set("persistence", value)

        def pubsub_client_output_buffer_limit(self, value: Optional[float], /) -> Self:
            """
            The output buffer limit for pub/sub clients in MB. The value is the hard limit, the soft limit is 1/4 of the hard limit. When setting the limit, be mindful of the available memory in the selected service plan.
            """
            return self._set("pubsub_client_output_buffer_limit", value)

        def ssl(self, value: Optional[bool], /) -> Self:
            """
            A boolean indicating whether to require SSL to access Redis.
            """
            return self._set("ssl", value)

        def timeout(self, value: Optional[float], /) -> Self:
            """
            The Redis idle connection timeout in seconds.
            """
            return self._set("timeout", value)

    class BuilderContext(BuilderContextBase["AtProviderModel5.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AtProviderModel5.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AtProviderModel5."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AtProviderModel5", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AtProviderModel5.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    acl_channels_default: Annotated[Optional[str], Field(alias="aclChannelsDefault")] = None
    """
    Determines default pub/sub channels' ACL for new users if an ACL is not supplied. When this option is not defined, allchannels is assumed to keep backward compatibility. This option doesn't affect Redis' acl-pubsub-default configuration. Supported values are: allchannels and resetchannels
    """
    cluster_id: Annotated[Optional[str], Field(alias="clusterId")] = None
    """
    The ID of the target Redis cluster.
    """
    id: Optional[str] = None
    io_threads: Annotated[Optional[float], Field(alias="ioThreads")] = None
    """
    The Redis IO thread count.
    """
    lfu_decay_time: Annotated[Optional[float], Field(alias="lfuDecayTime")] = None
    """
    The LFU maxmemory policy counter decay time in minutes.
    """
    lfu_log_factor: Annotated[Optional[float], Field(alias="lfuLogFactor")] = None
    """
    The counter logarithm factor for volatile-lfu and allkeys-lfu maxmemory policies.
    """
    maxmemory_policy: Annotated[Optional[str], Field(alias="maxmemoryPolicy")] = None
    """
    A string specifying the desired eviction policy for the Redis cluster.Supported values are: noeviction, allkeys-lru, allkeys-random, volatile-lru, volatile-random, volatile-ttl
    """
    notify_keyspace_events: Annotated[Optional[str], Field(alias="notifyKeyspaceEvents")] = None
    """
    The notify-keyspace-events option. Requires at least K or E.
    """
    number_of_databases: Annotated[Optional[float], Field(alias="numberOfDatabases")] = None
    """
    The number of Redis databases. Changing this will cause a restart of Redis service.
    """
    persistence: Optional[str] = None
    """
    When persistence is rdb, Redis does RDB dumps each 10 minutes if any key is changed. Also RDB dumps are done according to backup schedule for backup purposes. When persistence is off, no RDB dumps and backups are done, so data can be lost at any moment if service is restarted for any reason, or if service is powered off. Also service can't be forked.
    """
    pubsub_client_output_buffer_limit: Annotated[
        Optional[float], Field(alias="pubsubClientOutputBufferLimit")
    ] = None
    """
    The output buffer limit for pub/sub clients in MB. The value is the hard limit, the soft limit is 1/4 of the hard limit. When setting the limit, be mindful of the available memory in the selected service plan.
    """
    ssl: Optional[bool] = None
    """
    A boolean indicating whether to require SSL to access Redis.
    """
    timeout: Optional[float] = None
    """
    The Redis idle connection timeout in seconds.
    """


class RedisConfigStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["RedisConfigStatus"]:
            return RedisConfigStatus

        def build(self) -> "RedisConfigStatus":
            return RedisConfigStatus(**self._attrs)

        @overload
        def at_provider(
            self, value_or_callback: Optional[AtProviderModel5], /
        ) -> "RedisConfigStatus.Builder": ...

        @overload
        def at_provider(
            self,
            value_or_callback: Callable[
                [AtProviderModel5.Builder], AtProviderModel5.Builder | AtProviderModel5
            ],
            /,
        ) -> "RedisConfigStatus.Builder": ...

        @overload
        def at_provider(
            self, value_or_callback: Never = ...
        ) -> "AtProviderModel5.BuilderContext": ...

        def at_provider(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = AtProviderModel5.BuilderContext()
                context._parent_builder = self
                context._field_name = "at_provider"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AtProviderModel5.builder())
                if isinstance(output, AtProviderModel5.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("at_provider", value)

        @overload
        def conditions(
            self, value_or_callback: List[Condition], /
        ) -> "RedisConfigStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Condition, Condition.Builder]],
                GenericListBuilder[Condition, Condition.Builder] | List[Condition],
            ],
            /,
        ) -> "RedisConfigStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            """
            Conditions of the resource.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        def observed_generation(self, value: Optional[int], /) -> Self:
            """
            ObservedGeneration is the latest metadata.generation
            which resulted in either a ready state, or stalled due to error
            it can not recover from without human intervention.
            """
            return self._set("observed_generation", value)

    class BuilderContext(BuilderContextBase["RedisConfigStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = RedisConfigStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RedisConfigStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["RedisConfigStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use RedisConfigStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    at_provider: Annotated[Optional[AtProviderModel5], Field(alias="atProvider")] = None
    conditions: Optional[List[Condition]] = None
    """
    Conditions of the resource.
    """
    observed_generation: Annotated[Optional[int], Field(alias="observedGeneration")] = None
    """
    ObservedGeneration is the latest metadata.generation
    which resulted in either a ready state, or stalled due to error
    it can not recover from without human intervention.
    """


class ForProviderModel6(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ForProviderModel6"]:
            return ForProviderModel6

        def build(self) -> "ForProviderModel6":
            return ForProviderModel6(**self._attrs)

        def cluster_id(self, value: Optional[str], /) -> Self:
            """
            The ID of the original source database cluster.
            """
            return self._set("cluster_id", value)

        @overload
        def cluster_id_ref(
            self, value_or_callback: Optional[ClusterIdRef], /
        ) -> "ForProviderModel6.Builder": ...

        @overload
        def cluster_id_ref(
            self,
            value_or_callback: Callable[
                [ClusterIdRef.Builder], ClusterIdRef.Builder | ClusterIdRef
            ],
            /,
        ) -> "ForProviderModel6.Builder": ...

        @overload
        def cluster_id_ref(
            self, value_or_callback: Never = ...
        ) -> "ClusterIdRef.BuilderContext": ...

        def cluster_id_ref(self, value_or_callback=None, /):
            """
            Reference to a Cluster in database to populate clusterId.
            """
            if self._in_context and value_or_callback is None:
                context = ClusterIdRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "cluster_id_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ClusterIdRef.builder())
                if isinstance(output, ClusterIdRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("cluster_id_ref", value)

        @overload
        def cluster_id_selector(
            self, value_or_callback: Optional[ClusterIdSelector], /
        ) -> "ForProviderModel6.Builder": ...

        @overload
        def cluster_id_selector(
            self,
            value_or_callback: Callable[
                [ClusterIdSelector.Builder],
                ClusterIdSelector.Builder | ClusterIdSelector,
            ],
            /,
        ) -> "ForProviderModel6.Builder": ...

        @overload
        def cluster_id_selector(
            self, value_or_callback: Never = ...
        ) -> "ClusterIdSelector.BuilderContext": ...

        def cluster_id_selector(self, value_or_callback=None, /):
            """
            Selector for a Cluster in database to populate clusterId.
            """
            if self._in_context and value_or_callback is None:
                context = ClusterIdSelector.BuilderContext()
                context._parent_builder = self
                context._field_name = "cluster_id_selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ClusterIdSelector.builder())
                if isinstance(output, ClusterIdSelector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("cluster_id_selector", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            The name for the database replica.
            """
            return self._set("name", value)

        def private_network_uuid(self, value: Optional[str], /) -> Self:
            """
            The ID of the VPC where the database replica will be located.
            """
            return self._set("private_network_uuid", value)

        @overload
        def private_network_uuid_ref(
            self, value_or_callback: Optional[PrivateNetworkUuidRef], /
        ) -> "ForProviderModel6.Builder": ...

        @overload
        def private_network_uuid_ref(
            self,
            value_or_callback: Callable[
                [PrivateNetworkUuidRef.Builder],
                PrivateNetworkUuidRef.Builder | PrivateNetworkUuidRef,
            ],
            /,
        ) -> "ForProviderModel6.Builder": ...

        @overload
        def private_network_uuid_ref(
            self, value_or_callback: Never = ...
        ) -> "PrivateNetworkUuidRef.BuilderContext": ...

        def private_network_uuid_ref(self, value_or_callback=None, /):
            """
            Reference to a VPC in vpc to populate privateNetworkUuid.
            """
            if self._in_context and value_or_callback is None:
                context = PrivateNetworkUuidRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "private_network_uuid_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PrivateNetworkUuidRef.builder())
                if isinstance(output, PrivateNetworkUuidRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("private_network_uuid_ref", value)

        @overload
        def private_network_uuid_selector(
            self, value_or_callback: Optional[PrivateNetworkUuidSelector], /
        ) -> "ForProviderModel6.Builder": ...

        @overload
        def private_network_uuid_selector(
            self,
            value_or_callback: Callable[
                [PrivateNetworkUuidSelector.Builder],
                PrivateNetworkUuidSelector.Builder | PrivateNetworkUuidSelector,
            ],
            /,
        ) -> "ForProviderModel6.Builder": ...

        @overload
        def private_network_uuid_selector(
            self, value_or_callback: Never = ...
        ) -> "PrivateNetworkUuidSelector.BuilderContext": ...

        def private_network_uuid_selector(self, value_or_callback=None, /):
            """
            Selector for a VPC in vpc to populate privateNetworkUuid.
            """
            if self._in_context and value_or_callback is None:
                context = PrivateNetworkUuidSelector.BuilderContext()
                context._parent_builder = self
                context._field_name = "private_network_uuid_selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PrivateNetworkUuidSelector.builder())
                if isinstance(output, PrivateNetworkUuidSelector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("private_network_uuid_selector", value)

        def region(self, value: Optional[str], /) -> Self:
            """
            DigitalOcean region where the replica will reside.
            """
            return self._set("region", value)

        def size(self, value: Optional[str], /) -> Self:
            """
            Database Droplet size associated with the replica (ex. db-s-1vcpu-1gb). Note that when resizing an existing replica, its size can only be increased. Decreasing its size is not supported.
            """
            return self._set("size", value)

        def storage_size_mib(self, value: Optional[str], /) -> Self:
            return self._set("storage_size_mib", value)

        def tags(self, value: Optional[List[str]], /) -> Self:
            """
            A list of tag names to be applied to the database replica.
            """
            return self._set("tags", value)

    class BuilderContext(BuilderContextBase["ForProviderModel6.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ForProviderModel6.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ForProviderModel6."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ForProviderModel6", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ForProviderModel6.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    cluster_id: Annotated[Optional[str], Field(alias="clusterId")] = None
    """
    The ID of the original source database cluster.
    """
    cluster_id_ref: Annotated[Optional[ClusterIdRef], Field(alias="clusterIdRef")] = None
    """
    Reference to a Cluster in database to populate clusterId.
    """
    cluster_id_selector: Annotated[
        Optional[ClusterIdSelector], Field(alias="clusterIdSelector")
    ] = None
    """
    Selector for a Cluster in database to populate clusterId.
    """
    name: Optional[str] = None
    """
    The name for the database replica.
    """
    private_network_uuid: Annotated[Optional[str], Field(alias="privateNetworkUuid")] = None
    """
    The ID of the VPC where the database replica will be located.
    """
    private_network_uuid_ref: Annotated[
        Optional[PrivateNetworkUuidRef], Field(alias="privateNetworkUuidRef")
    ] = None
    """
    Reference to a VPC in vpc to populate privateNetworkUuid.
    """
    private_network_uuid_selector: Annotated[
        Optional[PrivateNetworkUuidSelector], Field(alias="privateNetworkUuidSelector")
    ] = None
    """
    Selector for a VPC in vpc to populate privateNetworkUuid.
    """
    region: Optional[str] = None
    """
    DigitalOcean region where the replica will reside.
    """
    size: Optional[str] = None
    """
    Database Droplet size associated with the replica (ex. db-s-1vcpu-1gb). Note that when resizing an existing replica, its size can only be increased. Decreasing its size is not supported.
    """
    storage_size_mib: Annotated[Optional[str], Field(alias="storageSizeMib")] = None
    tags: Optional[List[str]] = None
    """
    A list of tag names to be applied to the database replica.
    """


class InitProviderModel6(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["InitProviderModel6"]:
            return InitProviderModel6

        def build(self) -> "InitProviderModel6":
            return InitProviderModel6(**self._attrs)

        def cluster_id(self, value: Optional[str], /) -> Self:
            """
            The ID of the original source database cluster.
            """
            return self._set("cluster_id", value)

        @overload
        def cluster_id_ref(
            self, value_or_callback: Optional[ClusterIdRef], /
        ) -> "InitProviderModel6.Builder": ...

        @overload
        def cluster_id_ref(
            self,
            value_or_callback: Callable[
                [ClusterIdRef.Builder], ClusterIdRef.Builder | ClusterIdRef
            ],
            /,
        ) -> "InitProviderModel6.Builder": ...

        @overload
        def cluster_id_ref(
            self, value_or_callback: Never = ...
        ) -> "ClusterIdRef.BuilderContext": ...

        def cluster_id_ref(self, value_or_callback=None, /):
            """
            Reference to a Cluster in database to populate clusterId.
            """
            if self._in_context and value_or_callback is None:
                context = ClusterIdRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "cluster_id_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ClusterIdRef.builder())
                if isinstance(output, ClusterIdRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("cluster_id_ref", value)

        @overload
        def cluster_id_selector(
            self, value_or_callback: Optional[ClusterIdSelector], /
        ) -> "InitProviderModel6.Builder": ...

        @overload
        def cluster_id_selector(
            self,
            value_or_callback: Callable[
                [ClusterIdSelector.Builder],
                ClusterIdSelector.Builder | ClusterIdSelector,
            ],
            /,
        ) -> "InitProviderModel6.Builder": ...

        @overload
        def cluster_id_selector(
            self, value_or_callback: Never = ...
        ) -> "ClusterIdSelector.BuilderContext": ...

        def cluster_id_selector(self, value_or_callback=None, /):
            """
            Selector for a Cluster in database to populate clusterId.
            """
            if self._in_context and value_or_callback is None:
                context = ClusterIdSelector.BuilderContext()
                context._parent_builder = self
                context._field_name = "cluster_id_selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ClusterIdSelector.builder())
                if isinstance(output, ClusterIdSelector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("cluster_id_selector", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            The name for the database replica.
            """
            return self._set("name", value)

        def private_network_uuid(self, value: Optional[str], /) -> Self:
            """
            The ID of the VPC where the database replica will be located.
            """
            return self._set("private_network_uuid", value)

        @overload
        def private_network_uuid_ref(
            self, value_or_callback: Optional[PrivateNetworkUuidRef], /
        ) -> "InitProviderModel6.Builder": ...

        @overload
        def private_network_uuid_ref(
            self,
            value_or_callback: Callable[
                [PrivateNetworkUuidRef.Builder],
                PrivateNetworkUuidRef.Builder | PrivateNetworkUuidRef,
            ],
            /,
        ) -> "InitProviderModel6.Builder": ...

        @overload
        def private_network_uuid_ref(
            self, value_or_callback: Never = ...
        ) -> "PrivateNetworkUuidRef.BuilderContext": ...

        def private_network_uuid_ref(self, value_or_callback=None, /):
            """
            Reference to a VPC in vpc to populate privateNetworkUuid.
            """
            if self._in_context and value_or_callback is None:
                context = PrivateNetworkUuidRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "private_network_uuid_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PrivateNetworkUuidRef.builder())
                if isinstance(output, PrivateNetworkUuidRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("private_network_uuid_ref", value)

        @overload
        def private_network_uuid_selector(
            self, value_or_callback: Optional[PrivateNetworkUuidSelector], /
        ) -> "InitProviderModel6.Builder": ...

        @overload
        def private_network_uuid_selector(
            self,
            value_or_callback: Callable[
                [PrivateNetworkUuidSelector.Builder],
                PrivateNetworkUuidSelector.Builder | PrivateNetworkUuidSelector,
            ],
            /,
        ) -> "InitProviderModel6.Builder": ...

        @overload
        def private_network_uuid_selector(
            self, value_or_callback: Never = ...
        ) -> "PrivateNetworkUuidSelector.BuilderContext": ...

        def private_network_uuid_selector(self, value_or_callback=None, /):
            """
            Selector for a VPC in vpc to populate privateNetworkUuid.
            """
            if self._in_context and value_or_callback is None:
                context = PrivateNetworkUuidSelector.BuilderContext()
                context._parent_builder = self
                context._field_name = "private_network_uuid_selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PrivateNetworkUuidSelector.builder())
                if isinstance(output, PrivateNetworkUuidSelector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("private_network_uuid_selector", value)

        def region(self, value: Optional[str], /) -> Self:
            """
            DigitalOcean region where the replica will reside.
            """
            return self._set("region", value)

        def size(self, value: Optional[str], /) -> Self:
            """
            Database Droplet size associated with the replica (ex. db-s-1vcpu-1gb). Note that when resizing an existing replica, its size can only be increased. Decreasing its size is not supported.
            """
            return self._set("size", value)

        def storage_size_mib(self, value: Optional[str], /) -> Self:
            return self._set("storage_size_mib", value)

        def tags(self, value: Optional[List[str]], /) -> Self:
            """
            A list of tag names to be applied to the database replica.
            """
            return self._set("tags", value)

    class BuilderContext(BuilderContextBase["InitProviderModel6.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = InitProviderModel6.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for InitProviderModel6."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["InitProviderModel6", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use InitProviderModel6.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    cluster_id: Annotated[Optional[str], Field(alias="clusterId")] = None
    """
    The ID of the original source database cluster.
    """
    cluster_id_ref: Annotated[Optional[ClusterIdRef], Field(alias="clusterIdRef")] = None
    """
    Reference to a Cluster in database to populate clusterId.
    """
    cluster_id_selector: Annotated[
        Optional[ClusterIdSelector], Field(alias="clusterIdSelector")
    ] = None
    """
    Selector for a Cluster in database to populate clusterId.
    """
    name: Optional[str] = None
    """
    The name for the database replica.
    """
    private_network_uuid: Annotated[Optional[str], Field(alias="privateNetworkUuid")] = None
    """
    The ID of the VPC where the database replica will be located.
    """
    private_network_uuid_ref: Annotated[
        Optional[PrivateNetworkUuidRef], Field(alias="privateNetworkUuidRef")
    ] = None
    """
    Reference to a VPC in vpc to populate privateNetworkUuid.
    """
    private_network_uuid_selector: Annotated[
        Optional[PrivateNetworkUuidSelector], Field(alias="privateNetworkUuidSelector")
    ] = None
    """
    Selector for a VPC in vpc to populate privateNetworkUuid.
    """
    region: Optional[str] = None
    """
    DigitalOcean region where the replica will reside.
    """
    size: Optional[str] = None
    """
    Database Droplet size associated with the replica (ex. db-s-1vcpu-1gb). Note that when resizing an existing replica, its size can only be increased. Decreasing its size is not supported.
    """
    storage_size_mib: Annotated[Optional[str], Field(alias="storageSizeMib")] = None
    tags: Optional[List[str]] = None
    """
    A list of tag names to be applied to the database replica.
    """


class ReplicaSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ReplicaSpec"]:
            return ReplicaSpec

        def build(self) -> "ReplicaSpec":
            return ReplicaSpec(**self._attrs)

        def deletion_policy(self, value: Optional[Literal["Orphan", "Delete"]], /) -> Self:
            """
            DeletionPolicy specifies what will happen to the underlying external
            when this managed resource is deleted - either "Delete" or "Orphan" the
            external resource.
            This field is planned to be deprecated in favor of the ManagementPolicies
            field in a future release. Currently, both could be set independently and
            non-default values would be honored if the feature flag is enabled.
            See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
            """
            return self._set("deletion_policy", value)

        @overload
        def for_provider(
            self, value_or_callback: ForProviderModel6, /
        ) -> "ReplicaSpec.Builder": ...

        @overload
        def for_provider(
            self,
            value_or_callback: Callable[
                [ForProviderModel6.Builder],
                ForProviderModel6.Builder | ForProviderModel6,
            ],
            /,
        ) -> "ReplicaSpec.Builder": ...

        @overload
        def for_provider(
            self, value_or_callback: Never = ...
        ) -> "ForProviderModel6.BuilderContext": ...

        def for_provider(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ForProviderModel6.BuilderContext()
                context._parent_builder = self
                context._field_name = "for_provider"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ForProviderModel6.builder())
                if isinstance(output, ForProviderModel6.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("for_provider", value)

        @overload
        def init_provider(
            self, value_or_callback: Optional[InitProviderModel6], /
        ) -> "ReplicaSpec.Builder": ...

        @overload
        def init_provider(
            self,
            value_or_callback: Callable[
                [InitProviderModel6.Builder],
                InitProviderModel6.Builder | InitProviderModel6,
            ],
            /,
        ) -> "ReplicaSpec.Builder": ...

        @overload
        def init_provider(
            self, value_or_callback: Never = ...
        ) -> "InitProviderModel6.BuilderContext": ...

        def init_provider(self, value_or_callback=None, /):
            """
            THIS IS A BETA FIELD. It will be honored
            unless the Management Policies feature flag is disabled.
            InitProvider holds the same fields as ForProvider, with the exception
            of Identifier and other resource reference fields. The fields that are
            in InitProvider are merged into ForProvider when the resource is created.
            The same fields are also added to the terraform ignore_changes hook, to
            avoid updating them after creation. This is useful for fields that are
            required on creation, but we do not desire to update them after creation,
            for example because of an external controller is managing them, like an
            autoscaler.
            """
            if self._in_context and value_or_callback is None:
                context = InitProviderModel6.BuilderContext()
                context._parent_builder = self
                context._field_name = "init_provider"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(InitProviderModel6.builder())
                if isinstance(output, InitProviderModel6.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("init_provider", value)

        def management_policies(
            self,
            value: Optional[
                List[Literal["Observe", "Create", "Update", "Delete", "LateInitialize", "*"]]
            ],
            /,
        ) -> Self:
            """
            THIS IS A BETA FIELD. It is on by default but can be opted out
            through a Crossplane feature flag.
            ManagementPolicies specify the array of actions Crossplane is allowed to
            take on the managed and external resources.
            This field is planned to replace the DeletionPolicy field in a future
            release. Currently, both could be set independently and non-default
            values would be honored if the feature flag is enabled. If both are
            custom, the DeletionPolicy field will be ignored.
            See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
            and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
            """
            return self._set("management_policies", value)

        @overload
        def provider_config_ref(
            self, value_or_callback: Optional[ProviderConfigRef], /
        ) -> "ReplicaSpec.Builder": ...

        @overload
        def provider_config_ref(
            self,
            value_or_callback: Callable[
                [ProviderConfigRef.Builder],
                ProviderConfigRef.Builder | ProviderConfigRef,
            ],
            /,
        ) -> "ReplicaSpec.Builder": ...

        @overload
        def provider_config_ref(
            self, value_or_callback: Never = ...
        ) -> "ProviderConfigRef.BuilderContext": ...

        def provider_config_ref(self, value_or_callback=None, /):
            """
            ProviderConfigReference specifies how the provider that will be used to
            create, observe, update, and delete this managed resource should be
            configured.
            """
            if self._in_context and value_or_callback is None:
                context = ProviderConfigRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "provider_config_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ProviderConfigRef.builder())
                if isinstance(output, ProviderConfigRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("provider_config_ref", value)

        @overload
        def publish_connection_details_to(
            self, value_or_callback: Optional[PublishConnectionDetailsTo], /
        ) -> "ReplicaSpec.Builder": ...

        @overload
        def publish_connection_details_to(
            self,
            value_or_callback: Callable[
                [PublishConnectionDetailsTo.Builder],
                PublishConnectionDetailsTo.Builder | PublishConnectionDetailsTo,
            ],
            /,
        ) -> "ReplicaSpec.Builder": ...

        @overload
        def publish_connection_details_to(
            self, value_or_callback: Never = ...
        ) -> "PublishConnectionDetailsTo.BuilderContext": ...

        def publish_connection_details_to(self, value_or_callback=None, /):
            """
            PublishConnectionDetailsTo specifies the connection secret config which
            contains a name, metadata and a reference to secret store config to
            which any connection details for this managed resource should be written.
            Connection details frequently include the endpoint, username,
            and password required to connect to the managed resource.
            """
            if self._in_context and value_or_callback is None:
                context = PublishConnectionDetailsTo.BuilderContext()
                context._parent_builder = self
                context._field_name = "publish_connection_details_to"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PublishConnectionDetailsTo.builder())
                if isinstance(output, PublishConnectionDetailsTo.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("publish_connection_details_to", value)

        @overload
        def write_connection_secret_to_ref(
            self, value_or_callback: Optional[WriteConnectionSecretToRef], /
        ) -> "ReplicaSpec.Builder": ...

        @overload
        def write_connection_secret_to_ref(
            self,
            value_or_callback: Callable[
                [WriteConnectionSecretToRef.Builder],
                WriteConnectionSecretToRef.Builder | WriteConnectionSecretToRef,
            ],
            /,
        ) -> "ReplicaSpec.Builder": ...

        @overload
        def write_connection_secret_to_ref(
            self, value_or_callback: Never = ...
        ) -> "WriteConnectionSecretToRef.BuilderContext": ...

        def write_connection_secret_to_ref(self, value_or_callback=None, /):
            """
            WriteConnectionSecretToReference specifies the namespace and name of a
            Secret to which any connection details for this managed resource should
            be written. Connection details frequently include the endpoint, username,
            and password required to connect to the managed resource.
            This field is planned to be replaced in a future release in favor of
            PublishConnectionDetailsTo. Currently, both could be set independently
            and connection details would be published to both without affecting
            each other.
            """
            if self._in_context and value_or_callback is None:
                context = WriteConnectionSecretToRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "write_connection_secret_to_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(WriteConnectionSecretToRef.builder())
                if isinstance(output, WriteConnectionSecretToRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("write_connection_secret_to_ref", value)

    class BuilderContext(BuilderContextBase["ReplicaSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ReplicaSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ReplicaSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ReplicaSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ReplicaSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    deletion_policy: Annotated[
        Optional[Literal["Orphan", "Delete"]], Field(alias="deletionPolicy")
    ] = "Delete"
    """
    DeletionPolicy specifies what will happen to the underlying external
    when this managed resource is deleted - either "Delete" or "Orphan" the
    external resource.
    This field is planned to be deprecated in favor of the ManagementPolicies
    field in a future release. Currently, both could be set independently and
    non-default values would be honored if the feature flag is enabled.
    See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    """
    for_provider: Annotated[ForProviderModel6, Field(alias="forProvider")]
    init_provider: Annotated[Optional[InitProviderModel6], Field(alias="initProvider")] = None
    """
    THIS IS A BETA FIELD. It will be honored
    unless the Management Policies feature flag is disabled.
    InitProvider holds the same fields as ForProvider, with the exception
    of Identifier and other resource reference fields. The fields that are
    in InitProvider are merged into ForProvider when the resource is created.
    The same fields are also added to the terraform ignore_changes hook, to
    avoid updating them after creation. This is useful for fields that are
    required on creation, but we do not desire to update them after creation,
    for example because of an external controller is managing them, like an
    autoscaler.
    """
    management_policies: Annotated[
        Optional[List[Literal["Observe", "Create", "Update", "Delete", "LateInitialize", "*"]]],
        Field(alias="managementPolicies"),
    ] = ["*"]
    """
    THIS IS A BETA FIELD. It is on by default but can be opted out
    through a Crossplane feature flag.
    ManagementPolicies specify the array of actions Crossplane is allowed to
    take on the managed and external resources.
    This field is planned to replace the DeletionPolicy field in a future
    release. Currently, both could be set independently and non-default
    values would be honored if the feature flag is enabled. If both are
    custom, the DeletionPolicy field will be ignored.
    See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
    """
    provider_config_ref: Annotated[
        Optional[ProviderConfigRef],
        Field(
            default_factory=lambda: ProviderConfigRef.model_validate({"name": "default"}),
            alias="providerConfigRef",
        ),
    ] = {"name": "default"}
    """
    ProviderConfigReference specifies how the provider that will be used to
    create, observe, update, and delete this managed resource should be
    configured.
    """
    publish_connection_details_to: Annotated[
        Optional[PublishConnectionDetailsTo], Field(alias="publishConnectionDetailsTo")
    ] = None
    """
    PublishConnectionDetailsTo specifies the connection secret config which
    contains a name, metadata and a reference to secret store config to
    which any connection details for this managed resource should be written.
    Connection details frequently include the endpoint, username,
    and password required to connect to the managed resource.
    """
    write_connection_secret_to_ref: Annotated[
        Optional[WriteConnectionSecretToRef], Field(alias="writeConnectionSecretToRef")
    ] = None
    """
    WriteConnectionSecretToReference specifies the namespace and name of a
    Secret to which any connection details for this managed resource should
    be written. Connection details frequently include the endpoint, username,
    and password required to connect to the managed resource.
    This field is planned to be replaced in a future release in favor of
    PublishConnectionDetailsTo. Currently, both could be set independently
    and connection details would be published to both without affecting
    each other.
    """


class AtProviderModel6(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AtProviderModel6"]:
            return AtProviderModel6

        def build(self) -> "AtProviderModel6":
            return AtProviderModel6(**self._attrs)

        def cluster_id(self, value: Optional[str], /) -> Self:
            """
            The ID of the original source database cluster.
            """
            return self._set("cluster_id", value)

        def database(self, value: Optional[str], /) -> Self:
            """
            Name of the replica's default database.
            """
            return self._set("database", value)

        def host(self, value: Optional[str], /) -> Self:
            """
            Database replica's hostname.
            """
            return self._set("host", value)

        def id(self, value: Optional[str], /) -> Self:
            return self._set("id", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            The name for the database replica.
            """
            return self._set("name", value)

        def port(self, value: Optional[float], /) -> Self:
            """
            Network port that the database replica is listening on.
            """
            return self._set("port", value)

        def private_host(self, value: Optional[str], /) -> Self:
            """
            Same as host, but only accessible from resources within the account and in the same region.
            """
            return self._set("private_host", value)

        def private_network_uuid(self, value: Optional[str], /) -> Self:
            """
            The ID of the VPC where the database replica will be located.
            """
            return self._set("private_network_uuid", value)

        def region(self, value: Optional[str], /) -> Self:
            """
            DigitalOcean region where the replica will reside.
            """
            return self._set("region", value)

        def size(self, value: Optional[str], /) -> Self:
            """
            Database Droplet size associated with the replica (ex. db-s-1vcpu-1gb). Note that when resizing an existing replica, its size can only be increased. Decreasing its size is not supported.
            """
            return self._set("size", value)

        def storage_size_mib(self, value: Optional[str], /) -> Self:
            return self._set("storage_size_mib", value)

        def tags(self, value: Optional[List[str]], /) -> Self:
            """
            A list of tag names to be applied to the database replica.
            """
            return self._set("tags", value)

        def user(self, value: Optional[str], /) -> Self:
            """
            Username for the replica's default user.
            """
            return self._set("user", value)

        def uuid(self, value: Optional[str], /) -> Self:
            """
            The UUID of the database replica. The uuid can be used to reference the database replica as the target database cluster in other resources. See example  "Create firewall rule for database replica" above.
            The unique universal identifier for the database replica.
            """
            return self._set("uuid", value)

    class BuilderContext(BuilderContextBase["AtProviderModel6.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AtProviderModel6.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AtProviderModel6."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AtProviderModel6", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AtProviderModel6.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    cluster_id: Annotated[Optional[str], Field(alias="clusterId")] = None
    """
    The ID of the original source database cluster.
    """
    database: Optional[str] = None
    """
    Name of the replica's default database.
    """
    host: Optional[str] = None
    """
    Database replica's hostname.
    """
    id: Optional[str] = None
    name: Optional[str] = None
    """
    The name for the database replica.
    """
    port: Optional[float] = None
    """
    Network port that the database replica is listening on.
    """
    private_host: Annotated[Optional[str], Field(alias="privateHost")] = None
    """
    Same as host, but only accessible from resources within the account and in the same region.
    """
    private_network_uuid: Annotated[Optional[str], Field(alias="privateNetworkUuid")] = None
    """
    The ID of the VPC where the database replica will be located.
    """
    region: Optional[str] = None
    """
    DigitalOcean region where the replica will reside.
    """
    size: Optional[str] = None
    """
    Database Droplet size associated with the replica (ex. db-s-1vcpu-1gb). Note that when resizing an existing replica, its size can only be increased. Decreasing its size is not supported.
    """
    storage_size_mib: Annotated[Optional[str], Field(alias="storageSizeMib")] = None
    tags: Optional[List[str]] = None
    """
    A list of tag names to be applied to the database replica.
    """
    user: Optional[str] = None
    """
    Username for the replica's default user.
    """
    uuid: Optional[str] = None
    """
    The UUID of the database replica. The uuid can be used to reference the database replica as the target database cluster in other resources. See example  "Create firewall rule for database replica" above.
    The unique universal identifier for the database replica.
    """


class ReplicaStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ReplicaStatus"]:
            return ReplicaStatus

        def build(self) -> "ReplicaStatus":
            return ReplicaStatus(**self._attrs)

        @overload
        def at_provider(
            self, value_or_callback: Optional[AtProviderModel6], /
        ) -> "ReplicaStatus.Builder": ...

        @overload
        def at_provider(
            self,
            value_or_callback: Callable[
                [AtProviderModel6.Builder], AtProviderModel6.Builder | AtProviderModel6
            ],
            /,
        ) -> "ReplicaStatus.Builder": ...

        @overload
        def at_provider(
            self, value_or_callback: Never = ...
        ) -> "AtProviderModel6.BuilderContext": ...

        def at_provider(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = AtProviderModel6.BuilderContext()
                context._parent_builder = self
                context._field_name = "at_provider"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AtProviderModel6.builder())
                if isinstance(output, AtProviderModel6.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("at_provider", value)

        @overload
        def conditions(self, value_or_callback: List[Condition], /) -> "ReplicaStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Condition, Condition.Builder]],
                GenericListBuilder[Condition, Condition.Builder] | List[Condition],
            ],
            /,
        ) -> "ReplicaStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            """
            Conditions of the resource.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        def observed_generation(self, value: Optional[int], /) -> Self:
            """
            ObservedGeneration is the latest metadata.generation
            which resulted in either a ready state, or stalled due to error
            it can not recover from without human intervention.
            """
            return self._set("observed_generation", value)

    class BuilderContext(BuilderContextBase["ReplicaStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ReplicaStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ReplicaStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ReplicaStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ReplicaStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    at_provider: Annotated[Optional[AtProviderModel6], Field(alias="atProvider")] = None
    conditions: Optional[List[Condition]] = None
    """
    Conditions of the resource.
    """
    observed_generation: Annotated[Optional[int], Field(alias="observedGeneration")] = None
    """
    ObservedGeneration is the latest metadata.generation
    which resulted in either a ready state, or stalled due to error
    it can not recover from without human intervention.
    """


class Acl(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Acl"]:
            return Acl

        def build(self) -> "Acl":
            return Acl(**self._attrs)

        def permission(self, value: Optional[str], /) -> Self:
            """
            The permission level applied to the ACL. This includes "admin", "consume", "produce", and "produceconsume". "admin" allows for producing and consuming as well as add/delete/update permission for topics. "consume" allows only for reading topic messages. "produce" allows only for writing topic messages. "produceconsume" allows for both reading and writing topic messages.
            """
            return self._set("permission", value)

        def topic(self, value: Optional[str], /) -> Self:
            """
            A regex for matching the topic(s) that this ACL should apply to. The regex can assume one of 3 patterns: "", "", or "". "" is a special value indicating a wildcard that matches on all topics. "" defines a regex that matches all topics with the prefix. "" performs an exact match on a topic name and only applies to that topic.
            """
            return self._set("topic", value)

    class BuilderContext(BuilderContextBase["Acl.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Acl.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Acl."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Acl", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Acl.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    permission: Optional[str] = None
    """
    The permission level applied to the ACL. This includes "admin", "consume", "produce", and "produceconsume". "admin" allows for producing and consuming as well as add/delete/update permission for topics. "consume" allows only for reading topic messages. "produce" allows only for writing topic messages. "produceconsume" allows for both reading and writing topic messages.
    """
    topic: Optional[str] = None
    """
    A regex for matching the topic(s) that this ACL should apply to. The regex can assume one of 3 patterns: "", "", or "". "" is a special value indicating a wildcard that matches on all topics. "" defines a regex that matches all topics with the prefix. "" performs an exact match on a topic name and only applies to that topic.
    """


class OpensearchAcl(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["OpensearchAcl"]:
            return OpensearchAcl

        def build(self) -> "OpensearchAcl":
            return OpensearchAcl(**self._attrs)

        def index(self, value: Optional[str], /) -> Self:
            return self._set("index", value)

        def permission(self, value: Optional[str], /) -> Self:
            """
            The permission level applied to the ACL. This includes "admin", "consume", "produce", and "produceconsume". "admin" allows for producing and consuming as well as add/delete/update permission for topics. "consume" allows only for reading topic messages. "produce" allows only for writing topic messages. "produceconsume" allows for both reading and writing topic messages.
            """
            return self._set("permission", value)

    class BuilderContext(BuilderContextBase["OpensearchAcl.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = OpensearchAcl.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for OpensearchAcl."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["OpensearchAcl", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use OpensearchAcl.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    index: Optional[str] = None
    permission: Optional[str] = None
    """
    The permission level applied to the ACL. This includes "admin", "consume", "produce", and "produceconsume". "admin" allows for producing and consuming as well as add/delete/update permission for topics. "consume" allows only for reading topic messages. "produce" allows only for writing topic messages. "produceconsume" allows for both reading and writing topic messages.
    """


class Setting(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Setting"]:
            return Setting

        def build(self) -> "Setting":
            return Setting(**self._attrs)

        @overload
        def acl(self, value_or_callback: List[Acl], /) -> "Setting.Builder": ...

        @overload
        def acl(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Acl, Acl.Builder]],
                GenericListBuilder[Acl, Acl.Builder] | List[Acl],
            ],
            /,
        ) -> "Setting.Builder": ...

        @overload
        def acl(self, value_or_callback: Never = ...) -> ListBuilderContext[Acl.Builder]: ...

        def acl(self, value_or_callback=None, /):
            """
            A set of ACLs (Access Control Lists) specifying permission on topics with a Kafka cluster. The properties of an individual ACL are described below:
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Acl.Builder]()
                context._parent_builder = self
                context._field_name = "acl"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Acl.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("acl", value)

        @overload
        def opensearch_acl(
            self, value_or_callback: List[OpensearchAcl], /
        ) -> "Setting.Builder": ...

        @overload
        def opensearch_acl(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[OpensearchAcl, OpensearchAcl.Builder]],
                GenericListBuilder[OpensearchAcl, OpensearchAcl.Builder] | List[OpensearchAcl],
            ],
            /,
        ) -> "Setting.Builder": ...

        @overload
        def opensearch_acl(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[OpensearchAcl.Builder]: ...

        def opensearch_acl(self, value_or_callback=None, /):
            """
            A set of ACLs (Access Control Lists) specifying permission on topics with a Kafka cluster. The properties of an individual ACL are described below:
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[OpensearchAcl.Builder]()
                context._parent_builder = self
                context._field_name = "opensearch_acl"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(OpensearchAcl.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("opensearch_acl", value)

    class BuilderContext(BuilderContextBase["Setting.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Setting.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Setting."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Setting", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Setting.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    acl: Optional[List[Acl]] = None
    """
    A set of ACLs (Access Control Lists) specifying permission on topics with a Kafka cluster. The properties of an individual ACL are described below:
    """
    opensearch_acl: Annotated[Optional[List[OpensearchAcl]], Field(alias="opensearchAcl")] = None
    """
    A set of ACLs (Access Control Lists) specifying permission on topics with a Kafka cluster. The properties of an individual ACL are described below:
    """


class ForProviderModel7(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ForProviderModel7"]:
            return ForProviderModel7

        def build(self) -> "ForProviderModel7":
            return ForProviderModel7(**self._attrs)

        def cluster_id(self, value: Optional[str], /) -> Self:
            """
            The ID of the original source database cluster.
            """
            return self._set("cluster_id", value)

        @overload
        def cluster_id_ref(
            self, value_or_callback: Optional[ClusterIdRef], /
        ) -> "ForProviderModel7.Builder": ...

        @overload
        def cluster_id_ref(
            self,
            value_or_callback: Callable[
                [ClusterIdRef.Builder], ClusterIdRef.Builder | ClusterIdRef
            ],
            /,
        ) -> "ForProviderModel7.Builder": ...

        @overload
        def cluster_id_ref(
            self, value_or_callback: Never = ...
        ) -> "ClusterIdRef.BuilderContext": ...

        def cluster_id_ref(self, value_or_callback=None, /):
            """
            Reference to a Cluster in database to populate clusterId.
            """
            if self._in_context and value_or_callback is None:
                context = ClusterIdRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "cluster_id_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ClusterIdRef.builder())
                if isinstance(output, ClusterIdRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("cluster_id_ref", value)

        @overload
        def cluster_id_selector(
            self, value_or_callback: Optional[ClusterIdSelector], /
        ) -> "ForProviderModel7.Builder": ...

        @overload
        def cluster_id_selector(
            self,
            value_or_callback: Callable[
                [ClusterIdSelector.Builder],
                ClusterIdSelector.Builder | ClusterIdSelector,
            ],
            /,
        ) -> "ForProviderModel7.Builder": ...

        @overload
        def cluster_id_selector(
            self, value_or_callback: Never = ...
        ) -> "ClusterIdSelector.BuilderContext": ...

        def cluster_id_selector(self, value_or_callback=None, /):
            """
            Selector for a Cluster in database to populate clusterId.
            """
            if self._in_context and value_or_callback is None:
                context = ClusterIdSelector.BuilderContext()
                context._parent_builder = self
                context._field_name = "cluster_id_selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ClusterIdSelector.builder())
                if isinstance(output, ClusterIdSelector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("cluster_id_selector", value)

        def mysql_auth_plugin(self, value: Optional[str], /) -> Self:
            """
            The authentication method to use for connections to the MySQL user account. The valid values are mysql_native_password or caching_sha2_password (this is the default).
            """
            return self._set("mysql_auth_plugin", value)

        @overload
        def settings(self, value_or_callback: List[Setting], /) -> "ForProviderModel7.Builder": ...

        @overload
        def settings(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Setting, Setting.Builder]],
                GenericListBuilder[Setting, Setting.Builder] | List[Setting],
            ],
            /,
        ) -> "ForProviderModel7.Builder": ...

        @overload
        def settings(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Setting.Builder]: ...

        def settings(self, value_or_callback=None, /):
            """
            Contains optional settings for the user.
            The settings block is documented below.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Setting.Builder]()
                context._parent_builder = self
                context._field_name = "settings"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Setting.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("settings", value)

    class BuilderContext(BuilderContextBase["ForProviderModel7.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ForProviderModel7.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ForProviderModel7."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ForProviderModel7", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ForProviderModel7.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    cluster_id: Annotated[Optional[str], Field(alias="clusterId")] = None
    """
    The ID of the original source database cluster.
    """
    cluster_id_ref: Annotated[Optional[ClusterIdRef], Field(alias="clusterIdRef")] = None
    """
    Reference to a Cluster in database to populate clusterId.
    """
    cluster_id_selector: Annotated[
        Optional[ClusterIdSelector], Field(alias="clusterIdSelector")
    ] = None
    """
    Selector for a Cluster in database to populate clusterId.
    """
    mysql_auth_plugin: Annotated[Optional[str], Field(alias="mysqlAuthPlugin")] = None
    """
    The authentication method to use for connections to the MySQL user account. The valid values are mysql_native_password or caching_sha2_password (this is the default).
    """
    settings: Optional[List[Setting]] = None
    """
    Contains optional settings for the user.
    The settings block is documented below.
    """


class InitProviderModel7(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["InitProviderModel7"]:
            return InitProviderModel7

        def build(self) -> "InitProviderModel7":
            return InitProviderModel7(**self._attrs)

        def cluster_id(self, value: Optional[str], /) -> Self:
            """
            The ID of the original source database cluster.
            """
            return self._set("cluster_id", value)

        @overload
        def cluster_id_ref(
            self, value_or_callback: Optional[ClusterIdRef], /
        ) -> "InitProviderModel7.Builder": ...

        @overload
        def cluster_id_ref(
            self,
            value_or_callback: Callable[
                [ClusterIdRef.Builder], ClusterIdRef.Builder | ClusterIdRef
            ],
            /,
        ) -> "InitProviderModel7.Builder": ...

        @overload
        def cluster_id_ref(
            self, value_or_callback: Never = ...
        ) -> "ClusterIdRef.BuilderContext": ...

        def cluster_id_ref(self, value_or_callback=None, /):
            """
            Reference to a Cluster in database to populate clusterId.
            """
            if self._in_context and value_or_callback is None:
                context = ClusterIdRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "cluster_id_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ClusterIdRef.builder())
                if isinstance(output, ClusterIdRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("cluster_id_ref", value)

        @overload
        def cluster_id_selector(
            self, value_or_callback: Optional[ClusterIdSelector], /
        ) -> "InitProviderModel7.Builder": ...

        @overload
        def cluster_id_selector(
            self,
            value_or_callback: Callable[
                [ClusterIdSelector.Builder],
                ClusterIdSelector.Builder | ClusterIdSelector,
            ],
            /,
        ) -> "InitProviderModel7.Builder": ...

        @overload
        def cluster_id_selector(
            self, value_or_callback: Never = ...
        ) -> "ClusterIdSelector.BuilderContext": ...

        def cluster_id_selector(self, value_or_callback=None, /):
            """
            Selector for a Cluster in database to populate clusterId.
            """
            if self._in_context and value_or_callback is None:
                context = ClusterIdSelector.BuilderContext()
                context._parent_builder = self
                context._field_name = "cluster_id_selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ClusterIdSelector.builder())
                if isinstance(output, ClusterIdSelector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("cluster_id_selector", value)

        def mysql_auth_plugin(self, value: Optional[str], /) -> Self:
            """
            The authentication method to use for connections to the MySQL user account. The valid values are mysql_native_password or caching_sha2_password (this is the default).
            """
            return self._set("mysql_auth_plugin", value)

        @overload
        def settings(self, value_or_callback: List[Setting], /) -> "InitProviderModel7.Builder": ...

        @overload
        def settings(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Setting, Setting.Builder]],
                GenericListBuilder[Setting, Setting.Builder] | List[Setting],
            ],
            /,
        ) -> "InitProviderModel7.Builder": ...

        @overload
        def settings(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Setting.Builder]: ...

        def settings(self, value_or_callback=None, /):
            """
            Contains optional settings for the user.
            The settings block is documented below.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Setting.Builder]()
                context._parent_builder = self
                context._field_name = "settings"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Setting.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("settings", value)

    class BuilderContext(BuilderContextBase["InitProviderModel7.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = InitProviderModel7.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for InitProviderModel7."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["InitProviderModel7", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use InitProviderModel7.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    cluster_id: Annotated[Optional[str], Field(alias="clusterId")] = None
    """
    The ID of the original source database cluster.
    """
    cluster_id_ref: Annotated[Optional[ClusterIdRef], Field(alias="clusterIdRef")] = None
    """
    Reference to a Cluster in database to populate clusterId.
    """
    cluster_id_selector: Annotated[
        Optional[ClusterIdSelector], Field(alias="clusterIdSelector")
    ] = None
    """
    Selector for a Cluster in database to populate clusterId.
    """
    mysql_auth_plugin: Annotated[Optional[str], Field(alias="mysqlAuthPlugin")] = None
    """
    The authentication method to use for connections to the MySQL user account. The valid values are mysql_native_password or caching_sha2_password (this is the default).
    """
    settings: Optional[List[Setting]] = None
    """
    Contains optional settings for the user.
    The settings block is documented below.
    """


class UserSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["UserSpec"]:
            return UserSpec

        def build(self) -> "UserSpec":
            return UserSpec(**self._attrs)

        def deletion_policy(self, value: Optional[Literal["Orphan", "Delete"]], /) -> Self:
            """
            DeletionPolicy specifies what will happen to the underlying external
            when this managed resource is deleted - either "Delete" or "Orphan" the
            external resource.
            This field is planned to be deprecated in favor of the ManagementPolicies
            field in a future release. Currently, both could be set independently and
            non-default values would be honored if the feature flag is enabled.
            See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
            """
            return self._set("deletion_policy", value)

        @overload
        def for_provider(self, value_or_callback: ForProviderModel7, /) -> "UserSpec.Builder": ...

        @overload
        def for_provider(
            self,
            value_or_callback: Callable[
                [ForProviderModel7.Builder],
                ForProviderModel7.Builder | ForProviderModel7,
            ],
            /,
        ) -> "UserSpec.Builder": ...

        @overload
        def for_provider(
            self, value_or_callback: Never = ...
        ) -> "ForProviderModel7.BuilderContext": ...

        def for_provider(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ForProviderModel7.BuilderContext()
                context._parent_builder = self
                context._field_name = "for_provider"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ForProviderModel7.builder())
                if isinstance(output, ForProviderModel7.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("for_provider", value)

        @overload
        def init_provider(
            self, value_or_callback: Optional[InitProviderModel7], /
        ) -> "UserSpec.Builder": ...

        @overload
        def init_provider(
            self,
            value_or_callback: Callable[
                [InitProviderModel7.Builder],
                InitProviderModel7.Builder | InitProviderModel7,
            ],
            /,
        ) -> "UserSpec.Builder": ...

        @overload
        def init_provider(
            self, value_or_callback: Never = ...
        ) -> "InitProviderModel7.BuilderContext": ...

        def init_provider(self, value_or_callback=None, /):
            """
            THIS IS A BETA FIELD. It will be honored
            unless the Management Policies feature flag is disabled.
            InitProvider holds the same fields as ForProvider, with the exception
            of Identifier and other resource reference fields. The fields that are
            in InitProvider are merged into ForProvider when the resource is created.
            The same fields are also added to the terraform ignore_changes hook, to
            avoid updating them after creation. This is useful for fields that are
            required on creation, but we do not desire to update them after creation,
            for example because of an external controller is managing them, like an
            autoscaler.
            """
            if self._in_context and value_or_callback is None:
                context = InitProviderModel7.BuilderContext()
                context._parent_builder = self
                context._field_name = "init_provider"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(InitProviderModel7.builder())
                if isinstance(output, InitProviderModel7.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("init_provider", value)

        def management_policies(
            self,
            value: Optional[
                List[Literal["Observe", "Create", "Update", "Delete", "LateInitialize", "*"]]
            ],
            /,
        ) -> Self:
            """
            THIS IS A BETA FIELD. It is on by default but can be opted out
            through a Crossplane feature flag.
            ManagementPolicies specify the array of actions Crossplane is allowed to
            take on the managed and external resources.
            This field is planned to replace the DeletionPolicy field in a future
            release. Currently, both could be set independently and non-default
            values would be honored if the feature flag is enabled. If both are
            custom, the DeletionPolicy field will be ignored.
            See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
            and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
            """
            return self._set("management_policies", value)

        @overload
        def provider_config_ref(
            self, value_or_callback: Optional[ProviderConfigRef], /
        ) -> "UserSpec.Builder": ...

        @overload
        def provider_config_ref(
            self,
            value_or_callback: Callable[
                [ProviderConfigRef.Builder],
                ProviderConfigRef.Builder | ProviderConfigRef,
            ],
            /,
        ) -> "UserSpec.Builder": ...

        @overload
        def provider_config_ref(
            self, value_or_callback: Never = ...
        ) -> "ProviderConfigRef.BuilderContext": ...

        def provider_config_ref(self, value_or_callback=None, /):
            """
            ProviderConfigReference specifies how the provider that will be used to
            create, observe, update, and delete this managed resource should be
            configured.
            """
            if self._in_context and value_or_callback is None:
                context = ProviderConfigRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "provider_config_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ProviderConfigRef.builder())
                if isinstance(output, ProviderConfigRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("provider_config_ref", value)

        @overload
        def publish_connection_details_to(
            self, value_or_callback: Optional[PublishConnectionDetailsTo], /
        ) -> "UserSpec.Builder": ...

        @overload
        def publish_connection_details_to(
            self,
            value_or_callback: Callable[
                [PublishConnectionDetailsTo.Builder],
                PublishConnectionDetailsTo.Builder | PublishConnectionDetailsTo,
            ],
            /,
        ) -> "UserSpec.Builder": ...

        @overload
        def publish_connection_details_to(
            self, value_or_callback: Never = ...
        ) -> "PublishConnectionDetailsTo.BuilderContext": ...

        def publish_connection_details_to(self, value_or_callback=None, /):
            """
            PublishConnectionDetailsTo specifies the connection secret config which
            contains a name, metadata and a reference to secret store config to
            which any connection details for this managed resource should be written.
            Connection details frequently include the endpoint, username,
            and password required to connect to the managed resource.
            """
            if self._in_context and value_or_callback is None:
                context = PublishConnectionDetailsTo.BuilderContext()
                context._parent_builder = self
                context._field_name = "publish_connection_details_to"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PublishConnectionDetailsTo.builder())
                if isinstance(output, PublishConnectionDetailsTo.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("publish_connection_details_to", value)

        @overload
        def write_connection_secret_to_ref(
            self, value_or_callback: Optional[WriteConnectionSecretToRef], /
        ) -> "UserSpec.Builder": ...

        @overload
        def write_connection_secret_to_ref(
            self,
            value_or_callback: Callable[
                [WriteConnectionSecretToRef.Builder],
                WriteConnectionSecretToRef.Builder | WriteConnectionSecretToRef,
            ],
            /,
        ) -> "UserSpec.Builder": ...

        @overload
        def write_connection_secret_to_ref(
            self, value_or_callback: Never = ...
        ) -> "WriteConnectionSecretToRef.BuilderContext": ...

        def write_connection_secret_to_ref(self, value_or_callback=None, /):
            """
            WriteConnectionSecretToReference specifies the namespace and name of a
            Secret to which any connection details for this managed resource should
            be written. Connection details frequently include the endpoint, username,
            and password required to connect to the managed resource.
            This field is planned to be replaced in a future release in favor of
            PublishConnectionDetailsTo. Currently, both could be set independently
            and connection details would be published to both without affecting
            each other.
            """
            if self._in_context and value_or_callback is None:
                context = WriteConnectionSecretToRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "write_connection_secret_to_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(WriteConnectionSecretToRef.builder())
                if isinstance(output, WriteConnectionSecretToRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("write_connection_secret_to_ref", value)

    class BuilderContext(BuilderContextBase["UserSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = UserSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for UserSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["UserSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use UserSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    deletion_policy: Annotated[
        Optional[Literal["Orphan", "Delete"]], Field(alias="deletionPolicy")
    ] = "Delete"
    """
    DeletionPolicy specifies what will happen to the underlying external
    when this managed resource is deleted - either "Delete" or "Orphan" the
    external resource.
    This field is planned to be deprecated in favor of the ManagementPolicies
    field in a future release. Currently, both could be set independently and
    non-default values would be honored if the feature flag is enabled.
    See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    """
    for_provider: Annotated[ForProviderModel7, Field(alias="forProvider")]
    init_provider: Annotated[Optional[InitProviderModel7], Field(alias="initProvider")] = None
    """
    THIS IS A BETA FIELD. It will be honored
    unless the Management Policies feature flag is disabled.
    InitProvider holds the same fields as ForProvider, with the exception
    of Identifier and other resource reference fields. The fields that are
    in InitProvider are merged into ForProvider when the resource is created.
    The same fields are also added to the terraform ignore_changes hook, to
    avoid updating them after creation. This is useful for fields that are
    required on creation, but we do not desire to update them after creation,
    for example because of an external controller is managing them, like an
    autoscaler.
    """
    management_policies: Annotated[
        Optional[List[Literal["Observe", "Create", "Update", "Delete", "LateInitialize", "*"]]],
        Field(alias="managementPolicies"),
    ] = ["*"]
    """
    THIS IS A BETA FIELD. It is on by default but can be opted out
    through a Crossplane feature flag.
    ManagementPolicies specify the array of actions Crossplane is allowed to
    take on the managed and external resources.
    This field is planned to replace the DeletionPolicy field in a future
    release. Currently, both could be set independently and non-default
    values would be honored if the feature flag is enabled. If both are
    custom, the DeletionPolicy field will be ignored.
    See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
    """
    provider_config_ref: Annotated[
        Optional[ProviderConfigRef],
        Field(
            default_factory=lambda: ProviderConfigRef.model_validate({"name": "default"}),
            alias="providerConfigRef",
        ),
    ] = {"name": "default"}
    """
    ProviderConfigReference specifies how the provider that will be used to
    create, observe, update, and delete this managed resource should be
    configured.
    """
    publish_connection_details_to: Annotated[
        Optional[PublishConnectionDetailsTo], Field(alias="publishConnectionDetailsTo")
    ] = None
    """
    PublishConnectionDetailsTo specifies the connection secret config which
    contains a name, metadata and a reference to secret store config to
    which any connection details for this managed resource should be written.
    Connection details frequently include the endpoint, username,
    and password required to connect to the managed resource.
    """
    write_connection_secret_to_ref: Annotated[
        Optional[WriteConnectionSecretToRef], Field(alias="writeConnectionSecretToRef")
    ] = None
    """
    WriteConnectionSecretToReference specifies the namespace and name of a
    Secret to which any connection details for this managed resource should
    be written. Connection details frequently include the endpoint, username,
    and password required to connect to the managed resource.
    This field is planned to be replaced in a future release in favor of
    PublishConnectionDetailsTo. Currently, both could be set independently
    and connection details would be published to both without affecting
    each other.
    """


class AclModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AclModel"]:
            return AclModel

        def build(self) -> "AclModel":
            return AclModel(**self._attrs)

        def id(self, value: Optional[str], /) -> Self:
            """
            An identifier for the ACL, this will be automatically assigned when you create an ACL entry
            """
            return self._set("id", value)

        def permission(self, value: Optional[str], /) -> Self:
            """
            The permission level applied to the ACL. This includes "admin", "consume", "produce", and "produceconsume". "admin" allows for producing and consuming as well as add/delete/update permission for topics. "consume" allows only for reading topic messages. "produce" allows only for writing topic messages. "produceconsume" allows for both reading and writing topic messages.
            """
            return self._set("permission", value)

        def topic(self, value: Optional[str], /) -> Self:
            """
            A regex for matching the topic(s) that this ACL should apply to. The regex can assume one of 3 patterns: "", "", or "". "" is a special value indicating a wildcard that matches on all topics. "" defines a regex that matches all topics with the prefix. "" performs an exact match on a topic name and only applies to that topic.
            """
            return self._set("topic", value)

    class BuilderContext(BuilderContextBase["AclModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AclModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AclModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AclModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AclModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    id: Optional[str] = None
    """
    An identifier for the ACL, this will be automatically assigned when you create an ACL entry
    """
    permission: Optional[str] = None
    """
    The permission level applied to the ACL. This includes "admin", "consume", "produce", and "produceconsume". "admin" allows for producing and consuming as well as add/delete/update permission for topics. "consume" allows only for reading topic messages. "produce" allows only for writing topic messages. "produceconsume" allows for both reading and writing topic messages.
    """
    topic: Optional[str] = None
    """
    A regex for matching the topic(s) that this ACL should apply to. The regex can assume one of 3 patterns: "", "", or "". "" is a special value indicating a wildcard that matches on all topics. "" defines a regex that matches all topics with the prefix. "" performs an exact match on a topic name and only applies to that topic.
    """


class AtProviderModel7(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AtProviderModel7"]:
            return AtProviderModel7

        def build(self) -> "AtProviderModel7":
            return AtProviderModel7(**self._attrs)

        def cluster_id(self, value: Optional[str], /) -> Self:
            """
            The ID of the original source database cluster.
            """
            return self._set("cluster_id", value)

        def id(self, value: Optional[str], /) -> Self:
            """
            An identifier for the ACL, this will be automatically assigned when you create an ACL entry
            """
            return self._set("id", value)

        def mysql_auth_plugin(self, value: Optional[str], /) -> Self:
            """
            The authentication method to use for connections to the MySQL user account. The valid values are mysql_native_password or caching_sha2_password (this is the default).
            """
            return self._set("mysql_auth_plugin", value)

        def role(self, value: Optional[str], /) -> Self:
            """
            Role for the database user. The value will be either "primary" or "normal".
            """
            return self._set("role", value)

        @overload
        def settings(self, value_or_callback: List[Setting], /) -> "AtProviderModel7.Builder": ...

        @overload
        def settings(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Setting, Setting.Builder]],
                GenericListBuilder[Setting, Setting.Builder] | List[Setting],
            ],
            /,
        ) -> "AtProviderModel7.Builder": ...

        @overload
        def settings(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Setting.Builder]: ...

        def settings(self, value_or_callback=None, /):
            """
            Contains optional settings for the user.
            The settings block is documented below.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Setting.Builder]()
                context._parent_builder = self
                context._field_name = "settings"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Setting.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("settings", value)

    class BuilderContext(BuilderContextBase["AtProviderModel7.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AtProviderModel7.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AtProviderModel7."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AtProviderModel7", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AtProviderModel7.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    cluster_id: Annotated[Optional[str], Field(alias="clusterId")] = None
    """
    The ID of the original source database cluster.
    """
    id: Optional[str] = None
    """
    An identifier for the ACL, this will be automatically assigned when you create an ACL entry
    """
    mysql_auth_plugin: Annotated[Optional[str], Field(alias="mysqlAuthPlugin")] = None
    """
    The authentication method to use for connections to the MySQL user account. The valid values are mysql_native_password or caching_sha2_password (this is the default).
    """
    role: Optional[str] = None
    """
    Role for the database user. The value will be either "primary" or "normal".
    """
    settings: Optional[List[Setting]] = None
    """
    Contains optional settings for the user.
    The settings block is documented below.
    """


class UserStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["UserStatus"]:
            return UserStatus

        def build(self) -> "UserStatus":
            return UserStatus(**self._attrs)

        @overload
        def at_provider(
            self, value_or_callback: Optional[AtProviderModel7], /
        ) -> "UserStatus.Builder": ...

        @overload
        def at_provider(
            self,
            value_or_callback: Callable[
                [AtProviderModel7.Builder], AtProviderModel7.Builder | AtProviderModel7
            ],
            /,
        ) -> "UserStatus.Builder": ...

        @overload
        def at_provider(
            self, value_or_callback: Never = ...
        ) -> "AtProviderModel7.BuilderContext": ...

        def at_provider(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = AtProviderModel7.BuilderContext()
                context._parent_builder = self
                context._field_name = "at_provider"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AtProviderModel7.builder())
                if isinstance(output, AtProviderModel7.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("at_provider", value)

        @overload
        def conditions(self, value_or_callback: List[Condition], /) -> "UserStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Condition, Condition.Builder]],
                GenericListBuilder[Condition, Condition.Builder] | List[Condition],
            ],
            /,
        ) -> "UserStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            """
            Conditions of the resource.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        def observed_generation(self, value: Optional[int], /) -> Self:
            """
            ObservedGeneration is the latest metadata.generation
            which resulted in either a ready state, or stalled due to error
            it can not recover from without human intervention.
            """
            return self._set("observed_generation", value)

    class BuilderContext(BuilderContextBase["UserStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = UserStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for UserStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["UserStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use UserStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    at_provider: Annotated[Optional[AtProviderModel7], Field(alias="atProvider")] = None
    conditions: Optional[List[Condition]] = None
    """
    Conditions of the resource.
    """
    observed_generation: Annotated[Optional[int], Field(alias="observedGeneration")] = None
    """
    ObservedGeneration is the latest metadata.generation
    which resulted in either a ready state, or stalled due to error
    it can not recover from without human intervention.
    """


class Cluster(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Cluster"]:
            return Cluster

        def build(self) -> "Cluster":
            return Cluster(**self._attrs)

        def api_version(
            self,
            value: Optional[Literal["database.digitalocean.crossplane.io/v1alpha1"]],
            /,
        ) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["Cluster"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "Cluster.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "Cluster.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(self, value_or_callback: ClusterSpec, /) -> "Cluster.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[[ClusterSpec.Builder], ClusterSpec.Builder | ClusterSpec],
            /,
        ) -> "Cluster.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "ClusterSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ClusterSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ClusterSpec.builder())
                if isinstance(output, ClusterSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(self, value_or_callback: Optional[ClusterStatus], /) -> "Cluster.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [ClusterStatus.Builder], ClusterStatus.Builder | ClusterStatus
            ],
            /,
        ) -> "Cluster.Builder": ...

        @overload
        def status(self, value_or_callback: Never = ...) -> "ClusterStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ClusterStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ClusterStatus.builder())
                if isinstance(output, ClusterStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["Cluster.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Cluster.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Cluster."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Cluster", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Cluster.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[
        Optional[Literal["database.digitalocean.crossplane.io/v1alpha1"]],
        Field(alias="apiVersion"),
    ] = "database.digitalocean.crossplane.io/v1alpha1"
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["Cluster"]] = "Cluster"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: ClusterSpec
    status: Optional[ClusterStatus] = None


class ConnectionPool(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ConnectionPool"]:
            return ConnectionPool

        def build(self) -> "ConnectionPool":
            return ConnectionPool(**self._attrs)

        def api_version(
            self,
            value: Optional[Literal["database.digitalocean.crossplane.io/v1alpha1"]],
            /,
        ) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["ConnectionPool"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "ConnectionPool.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "ConnectionPool.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(self, value_or_callback: ConnectionPoolSpec, /) -> "ConnectionPool.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [ConnectionPoolSpec.Builder],
                ConnectionPoolSpec.Builder | ConnectionPoolSpec,
            ],
            /,
        ) -> "ConnectionPool.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "ConnectionPoolSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ConnectionPoolSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ConnectionPoolSpec.builder())
                if isinstance(output, ConnectionPoolSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(
            self, value_or_callback: Optional[ConnectionPoolStatus], /
        ) -> "ConnectionPool.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [ConnectionPoolStatus.Builder],
                ConnectionPoolStatus.Builder | ConnectionPoolStatus,
            ],
            /,
        ) -> "ConnectionPool.Builder": ...

        @overload
        def status(
            self, value_or_callback: Never = ...
        ) -> "ConnectionPoolStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ConnectionPoolStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ConnectionPoolStatus.builder())
                if isinstance(output, ConnectionPoolStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["ConnectionPool.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ConnectionPool.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ConnectionPool."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ConnectionPool", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ConnectionPool.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[
        Optional[Literal["database.digitalocean.crossplane.io/v1alpha1"]],
        Field(alias="apiVersion"),
    ] = "database.digitalocean.crossplane.io/v1alpha1"
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["ConnectionPool"]] = "ConnectionPool"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: ConnectionPoolSpec
    status: Optional[ConnectionPoolStatus] = None


class DB(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["DB"]:
            return DB

        def build(self) -> "DB":
            return DB(**self._attrs)

        def api_version(
            self,
            value: Optional[Literal["database.digitalocean.crossplane.io/v1alpha1"]],
            /,
        ) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["DB"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "DB.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "DB.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(self, value_or_callback: DBSpec, /) -> "DB.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[[DBSpec.Builder], DBSpec.Builder | DBSpec],
            /,
        ) -> "DB.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "DBSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = DBSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(DBSpec.builder())
                if isinstance(output, DBSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(self, value_or_callback: Optional[DBStatus], /) -> "DB.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[[DBStatus.Builder], DBStatus.Builder | DBStatus],
            /,
        ) -> "DB.Builder": ...

        @overload
        def status(self, value_or_callback: Never = ...) -> "DBStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = DBStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(DBStatus.builder())
                if isinstance(output, DBStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["DB.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DB.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DB."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["DB", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use DB.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[
        Optional[Literal["database.digitalocean.crossplane.io/v1alpha1"]],
        Field(alias="apiVersion"),
    ] = "database.digitalocean.crossplane.io/v1alpha1"
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["DB"]] = "DB"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: DBSpec
    status: Optional[DBStatus] = None


class Firewall(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Firewall"]:
            return Firewall

        def build(self) -> "Firewall":
            return Firewall(**self._attrs)

        def api_version(
            self,
            value: Optional[Literal["database.digitalocean.crossplane.io/v1alpha1"]],
            /,
        ) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["Firewall"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "Firewall.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "Firewall.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(self, value_or_callback: FirewallSpec, /) -> "Firewall.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [FirewallSpec.Builder], FirewallSpec.Builder | FirewallSpec
            ],
            /,
        ) -> "Firewall.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "FirewallSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = FirewallSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(FirewallSpec.builder())
                if isinstance(output, FirewallSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(self, value_or_callback: Optional[FirewallStatus], /) -> "Firewall.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [FirewallStatus.Builder], FirewallStatus.Builder | FirewallStatus
            ],
            /,
        ) -> "Firewall.Builder": ...

        @overload
        def status(self, value_or_callback: Never = ...) -> "FirewallStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = FirewallStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(FirewallStatus.builder())
                if isinstance(output, FirewallStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["Firewall.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Firewall.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Firewall."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Firewall", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Firewall.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[
        Optional[Literal["database.digitalocean.crossplane.io/v1alpha1"]],
        Field(alias="apiVersion"),
    ] = "database.digitalocean.crossplane.io/v1alpha1"
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["Firewall"]] = "Firewall"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: FirewallSpec
    status: Optional[FirewallStatus] = None


class KafkaTopic(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["KafkaTopic"]:
            return KafkaTopic

        def build(self) -> "KafkaTopic":
            return KafkaTopic(**self._attrs)

        def api_version(
            self,
            value: Optional[Literal["database.digitalocean.crossplane.io/v1alpha1"]],
            /,
        ) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["KafkaTopic"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "KafkaTopic.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "KafkaTopic.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(self, value_or_callback: KafkaTopicSpec, /) -> "KafkaTopic.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [KafkaTopicSpec.Builder], KafkaTopicSpec.Builder | KafkaTopicSpec
            ],
            /,
        ) -> "KafkaTopic.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "KafkaTopicSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = KafkaTopicSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(KafkaTopicSpec.builder())
                if isinstance(output, KafkaTopicSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(
            self, value_or_callback: Optional[KafkaTopicStatus], /
        ) -> "KafkaTopic.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [KafkaTopicStatus.Builder], KafkaTopicStatus.Builder | KafkaTopicStatus
            ],
            /,
        ) -> "KafkaTopic.Builder": ...

        @overload
        def status(self, value_or_callback: Never = ...) -> "KafkaTopicStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = KafkaTopicStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(KafkaTopicStatus.builder())
                if isinstance(output, KafkaTopicStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["KafkaTopic.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = KafkaTopic.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for KafkaTopic."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["KafkaTopic", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use KafkaTopic.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[
        Optional[Literal["database.digitalocean.crossplane.io/v1alpha1"]],
        Field(alias="apiVersion"),
    ] = "database.digitalocean.crossplane.io/v1alpha1"
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["KafkaTopic"]] = "KafkaTopic"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: KafkaTopicSpec
    status: Optional[KafkaTopicStatus] = None


class MySQLConfig(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["MySQLConfig"]:
            return MySQLConfig

        def build(self) -> "MySQLConfig":
            return MySQLConfig(**self._attrs)

        def api_version(
            self,
            value: Optional[Literal["database.digitalocean.crossplane.io/v1alpha1"]],
            /,
        ) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["MySQLConfig"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "MySQLConfig.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "MySQLConfig.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(self, value_or_callback: MySQLConfigSpec, /) -> "MySQLConfig.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [MySQLConfigSpec.Builder], MySQLConfigSpec.Builder | MySQLConfigSpec
            ],
            /,
        ) -> "MySQLConfig.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "MySQLConfigSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = MySQLConfigSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(MySQLConfigSpec.builder())
                if isinstance(output, MySQLConfigSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(
            self, value_or_callback: Optional[MySQLConfigStatus], /
        ) -> "MySQLConfig.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [MySQLConfigStatus.Builder],
                MySQLConfigStatus.Builder | MySQLConfigStatus,
            ],
            /,
        ) -> "MySQLConfig.Builder": ...

        @overload
        def status(self, value_or_callback: Never = ...) -> "MySQLConfigStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = MySQLConfigStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(MySQLConfigStatus.builder())
                if isinstance(output, MySQLConfigStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["MySQLConfig.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = MySQLConfig.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for MySQLConfig."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["MySQLConfig", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use MySQLConfig.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[
        Optional[Literal["database.digitalocean.crossplane.io/v1alpha1"]],
        Field(alias="apiVersion"),
    ] = "database.digitalocean.crossplane.io/v1alpha1"
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["MySQLConfig"]] = "MySQLConfig"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: MySQLConfigSpec
    status: Optional[MySQLConfigStatus] = None


class RedisConfig(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["RedisConfig"]:
            return RedisConfig

        def build(self) -> "RedisConfig":
            return RedisConfig(**self._attrs)

        def api_version(
            self,
            value: Optional[Literal["database.digitalocean.crossplane.io/v1alpha1"]],
            /,
        ) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["RedisConfig"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "RedisConfig.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "RedisConfig.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(self, value_or_callback: RedisConfigSpec, /) -> "RedisConfig.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [RedisConfigSpec.Builder], RedisConfigSpec.Builder | RedisConfigSpec
            ],
            /,
        ) -> "RedisConfig.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "RedisConfigSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = RedisConfigSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(RedisConfigSpec.builder())
                if isinstance(output, RedisConfigSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(
            self, value_or_callback: Optional[RedisConfigStatus], /
        ) -> "RedisConfig.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [RedisConfigStatus.Builder],
                RedisConfigStatus.Builder | RedisConfigStatus,
            ],
            /,
        ) -> "RedisConfig.Builder": ...

        @overload
        def status(self, value_or_callback: Never = ...) -> "RedisConfigStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = RedisConfigStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(RedisConfigStatus.builder())
                if isinstance(output, RedisConfigStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["RedisConfig.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = RedisConfig.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RedisConfig."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["RedisConfig", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use RedisConfig.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[
        Optional[Literal["database.digitalocean.crossplane.io/v1alpha1"]],
        Field(alias="apiVersion"),
    ] = "database.digitalocean.crossplane.io/v1alpha1"
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["RedisConfig"]] = "RedisConfig"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: RedisConfigSpec
    status: Optional[RedisConfigStatus] = None


class Replica(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Replica"]:
            return Replica

        def build(self) -> "Replica":
            return Replica(**self._attrs)

        def api_version(
            self,
            value: Optional[Literal["database.digitalocean.crossplane.io/v1alpha1"]],
            /,
        ) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["Replica"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "Replica.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "Replica.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(self, value_or_callback: ReplicaSpec, /) -> "Replica.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[[ReplicaSpec.Builder], ReplicaSpec.Builder | ReplicaSpec],
            /,
        ) -> "Replica.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "ReplicaSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ReplicaSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ReplicaSpec.builder())
                if isinstance(output, ReplicaSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(self, value_or_callback: Optional[ReplicaStatus], /) -> "Replica.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [ReplicaStatus.Builder], ReplicaStatus.Builder | ReplicaStatus
            ],
            /,
        ) -> "Replica.Builder": ...

        @overload
        def status(self, value_or_callback: Never = ...) -> "ReplicaStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ReplicaStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ReplicaStatus.builder())
                if isinstance(output, ReplicaStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["Replica.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Replica.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Replica."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Replica", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Replica.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[
        Optional[Literal["database.digitalocean.crossplane.io/v1alpha1"]],
        Field(alias="apiVersion"),
    ] = "database.digitalocean.crossplane.io/v1alpha1"
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["Replica"]] = "Replica"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: ReplicaSpec
    status: Optional[ReplicaStatus] = None


class User(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["User"]:
            return User

        def build(self) -> "User":
            return User(**self._attrs)

        def api_version(
            self,
            value: Optional[Literal["database.digitalocean.crossplane.io/v1alpha1"]],
            /,
        ) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["User"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "User.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "User.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(self, value_or_callback: UserSpec, /) -> "User.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[[UserSpec.Builder], UserSpec.Builder | UserSpec],
            /,
        ) -> "User.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "UserSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = UserSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(UserSpec.builder())
                if isinstance(output, UserSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(self, value_or_callback: Optional[UserStatus], /) -> "User.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[[UserStatus.Builder], UserStatus.Builder | UserStatus],
            /,
        ) -> "User.Builder": ...

        @overload
        def status(self, value_or_callback: Never = ...) -> "UserStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = UserStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(UserStatus.builder())
                if isinstance(output, UserStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["User.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = User.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for User."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["User", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use User.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[
        Optional[Literal["database.digitalocean.crossplane.io/v1alpha1"]],
        Field(alias="apiVersion"),
    ] = "database.digitalocean.crossplane.io/v1alpha1"
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["User"]] = "User"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: UserSpec
    status: Optional[UserStatus] = None
