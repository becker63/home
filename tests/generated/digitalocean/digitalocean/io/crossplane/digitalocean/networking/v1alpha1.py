# Generated by cloudcoil-model-codegen v0.5.8
# DO NOT EDIT


from __future__ import annotations

from typing import (
    Annotated,
    Callable,
    Dict,
    List,
    Literal,
    Optional,
    Type,
    overload,
)

from cloudcoil import apimachinery
from cloudcoil.pydantic import (
    BaseModel,
    BaseModelBuilder,
    BuilderContextBase,
    GenericListBuilder,
    ListBuilderContext,
    Never,
    Self,
)
from cloudcoil.resources import Resource
from pydantic import AwareDatetime, Field


class Policy(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Policy"]:
            return Policy

        def build(self) -> "Policy":
            return Policy(**self._attrs)

        def resolution(self, value: Optional[Literal["Required", "Optional"]], /) -> Self:
            """
            Resolution specifies whether resolution of this reference is required.
            The default is 'Required', which means the reconcile will fail if the
            reference cannot be resolved. 'Optional' means this reference will be
            a no-op if it cannot be resolved.
            """
            return self._set("resolution", value)

        def resolve(self, value: Optional[Literal["Always", "IfNotPresent"]], /) -> Self:
            """
            Resolve specifies when this reference should be resolved. The default
            is 'IfNotPresent', which will attempt to resolve the reference only when
            the corresponding field is not present. Use 'Always' to resolve the
            reference on every reconcile.
            """
            return self._set("resolve", value)

    class BuilderContext(BuilderContextBase["Policy.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Policy.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Policy."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Policy", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Policy.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    resolution: Optional[Literal["Required", "Optional"]] = "Required"
    """
    Resolution specifies whether resolution of this reference is required.
    The default is 'Required', which means the reconcile will fail if the
    reference cannot be resolved. 'Optional' means this reference will be
    a no-op if it cannot be resolved.
    """
    resolve: Optional[Literal["Always", "IfNotPresent"]] = None
    """
    Resolve specifies when this reference should be resolved. The default
    is 'IfNotPresent', which will attempt to resolve the reference only when
    the corresponding field is not present. Use 'Always' to resolve the
    reference on every reconcile.
    """


class DomainsRef(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["DomainsRef"]:
            return DomainsRef

        def build(self) -> "DomainsRef":
            return DomainsRef(**self._attrs)

        def name(self, value: str, /) -> Self:
            """
            Name of the referenced object.
            """
            return self._set("name", value)

        @overload
        def policy(self, value_or_callback: Optional[Policy], /) -> "DomainsRef.Builder": ...

        @overload
        def policy(
            self,
            value_or_callback: Callable[[Policy.Builder], Policy.Builder | Policy],
            /,
        ) -> "DomainsRef.Builder": ...

        @overload
        def policy(self, value_or_callback: Never = ...) -> "Policy.BuilderContext": ...

        def policy(self, value_or_callback=None, /):
            """
            Policies for referencing.
            """
            if self._in_context and value_or_callback is None:
                context = Policy.BuilderContext()
                context._parent_builder = self
                context._field_name = "policy"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Policy.builder())
                if isinstance(output, Policy.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("policy", value)

    class BuilderContext(BuilderContextBase["DomainsRef.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DomainsRef.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DomainsRef."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["DomainsRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use DomainsRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: str
    """
    Name of the referenced object.
    """
    policy: Optional[Policy] = None
    """
    Policies for referencing.
    """


class Id(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Id"]:
            return Id

        def build(self) -> "Id":
            return Id(**self._attrs)

        def match_controller_ref(self, value: Optional[bool], /) -> Self:
            """
            MatchControllerRef ensures an object with the same controller reference
            as the selecting object is selected.
            """
            return self._set("match_controller_ref", value)

        def match_labels(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            MatchLabels ensures an object with matching labels is selected.
            """
            return self._set("match_labels", value)

        @overload
        def policy(self, value_or_callback: Optional[Policy], /) -> "Id.Builder": ...

        @overload
        def policy(
            self,
            value_or_callback: Callable[[Policy.Builder], Policy.Builder | Policy],
            /,
        ) -> "Id.Builder": ...

        @overload
        def policy(self, value_or_callback: Never = ...) -> "Policy.BuilderContext": ...

        def policy(self, value_or_callback=None, /):
            """
            Policies for selection.
            """
            if self._in_context and value_or_callback is None:
                context = Policy.BuilderContext()
                context._parent_builder = self
                context._field_name = "policy"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Policy.builder())
                if isinstance(output, Policy.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("policy", value)

    class BuilderContext(BuilderContextBase["Id.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Id.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Id."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Id", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Id.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    match_controller_ref: Annotated[Optional[bool], Field(alias="matchControllerRef")] = None
    """
    MatchControllerRef ensures an object with the same controller reference
    as the selecting object is selected.
    """
    match_labels: Annotated[Optional[Dict[str, str]], Field(alias="matchLabels")] = None
    """
    MatchLabels ensures an object with matching labels is selected.
    """
    policy: Optional[Policy] = None
    """
    Policies for selection.
    """


class PrivateKeySecretRef(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PrivateKeySecretRef"]:
            return PrivateKeySecretRef

        def build(self) -> "PrivateKeySecretRef":
            return PrivateKeySecretRef(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            The key to select.
            """
            return self._set("key", value)

        def name(self, value: str, /) -> Self:
            """
            Name of the secret.
            """
            return self._set("name", value)

        def namespace(self, value: str, /) -> Self:
            """
            Namespace of the secret.
            """
            return self._set("namespace", value)

    class BuilderContext(BuilderContextBase["PrivateKeySecretRef.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PrivateKeySecretRef.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PrivateKeySecretRef."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["PrivateKeySecretRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PrivateKeySecretRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: str
    """
    The key to select.
    """
    name: str
    """
    Name of the secret.
    """
    namespace: str
    """
    Namespace of the secret.
    """


class ForProvider(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ForProvider"]:
            return ForProvider

        def build(self) -> "ForProvider":
            return ForProvider(**self._attrs)

        def certificate_chain(self, value: Optional[str], /) -> Self:
            """
            The full PEM-formatted trust chain
            between the certificate authority's certificate and your domain's TLS
            certificate. Only valid when type is custom.
            """
            return self._set("certificate_chain", value)

        def domains(self, value: Optional[List[str]], /) -> Self:
            """
            List of fully qualified domain names (FQDNs) for
            which the certificate will be issued. The domains must be managed using
            DigitalOcean's DNS. Only valid when type is lets_encrypt.
            """
            return self._set("domains", value)

        @overload
        def domains_refs(self, value_or_callback: List[DomainsRef], /) -> "ForProvider.Builder": ...

        @overload
        def domains_refs(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[DomainsRef, DomainsRef.Builder]],
                GenericListBuilder[DomainsRef, DomainsRef.Builder] | List[DomainsRef],
            ],
            /,
        ) -> "ForProvider.Builder": ...

        @overload
        def domains_refs(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[DomainsRef.Builder]: ...

        def domains_refs(self, value_or_callback=None, /):
            """
            References to Domain in dns to populate domains.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[DomainsRef.Builder]()
                context._parent_builder = self
                context._field_name = "domains_refs"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(DomainsRef.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("domains_refs", value)

        @overload
        def id(self, value_or_callback: Optional[Id], /) -> "ForProvider.Builder": ...

        @overload
        def id(
            self, value_or_callback: Callable[[Id.Builder], Id.Builder | Id], /
        ) -> "ForProvider.Builder": ...

        @overload
        def id(self, value_or_callback: Never = ...) -> "Id.BuilderContext": ...

        def id(self, value_or_callback=None, /):
            """
            The unique name of the certificate
            """
            if self._in_context and value_or_callback is None:
                context = Id.BuilderContext()
                context._parent_builder = self
                context._field_name = "id"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Id.builder())
                if isinstance(output, Id.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("id", value)

        def leaf_certificate(self, value: Optional[str], /) -> Self:
            """
            The contents of a PEM-formatted public
            TLS certificate. Only valid when type is custom.
            """
            return self._set("leaf_certificate", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            The name of the certificate for identification.
            """
            return self._set("name", value)

        @overload
        def private_key_secret_ref(
            self, value_or_callback: Optional[PrivateKeySecretRef], /
        ) -> "ForProvider.Builder": ...

        @overload
        def private_key_secret_ref(
            self,
            value_or_callback: Callable[
                [PrivateKeySecretRef.Builder],
                PrivateKeySecretRef.Builder | PrivateKeySecretRef,
            ],
            /,
        ) -> "ForProvider.Builder": ...

        @overload
        def private_key_secret_ref(
            self, value_or_callback: Never = ...
        ) -> "PrivateKeySecretRef.BuilderContext": ...

        def private_key_secret_ref(self, value_or_callback=None, /):
            """
            The contents of a PEM-formatted private-key
            corresponding to the SSL certificate. Only valid when type is custom.
            """
            if self._in_context and value_or_callback is None:
                context = PrivateKeySecretRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "private_key_secret_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PrivateKeySecretRef.builder())
                if isinstance(output, PrivateKeySecretRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("private_key_secret_ref", value)

        def type(self, value: Optional[str], /) -> Self:
            """
            The type of certificate to provision. Can be either
            custom or lets_encrypt. Defaults to custom.
            """
            return self._set("type", value)

    class BuilderContext(BuilderContextBase["ForProvider.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ForProvider.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ForProvider."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ForProvider", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ForProvider.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    certificate_chain: Annotated[Optional[str], Field(alias="certificateChain")] = None
    """
    The full PEM-formatted trust chain
    between the certificate authority's certificate and your domain's TLS
    certificate. Only valid when type is custom.
    """
    domains: Optional[List[str]] = None
    """
    List of fully qualified domain names (FQDNs) for
    which the certificate will be issued. The domains must be managed using
    DigitalOcean's DNS. Only valid when type is lets_encrypt.
    """
    domains_refs: Annotated[Optional[List[DomainsRef]], Field(alias="domainsRefs")] = None
    """
    References to Domain in dns to populate domains.
    """
    id: Optional[Id] = None
    """
    The unique name of the certificate
    """
    leaf_certificate: Annotated[Optional[str], Field(alias="leafCertificate")] = None
    """
    The contents of a PEM-formatted public
    TLS certificate. Only valid when type is custom.
    """
    name: Optional[str] = None
    """
    The name of the certificate for identification.
    """
    private_key_secret_ref: Annotated[
        Optional[PrivateKeySecretRef], Field(alias="privateKeySecretRef")
    ] = None
    """
    The contents of a PEM-formatted private-key
    corresponding to the SSL certificate. Only valid when type is custom.
    """
    type: Optional[str] = None
    """
    The type of certificate to provision. Can be either
    custom or lets_encrypt. Defaults to custom.
    """


class InitProvider(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["InitProvider"]:
            return InitProvider

        def build(self) -> "InitProvider":
            return InitProvider(**self._attrs)

        def certificate_chain(self, value: Optional[str], /) -> Self:
            """
            The full PEM-formatted trust chain
            between the certificate authority's certificate and your domain's TLS
            certificate. Only valid when type is custom.
            """
            return self._set("certificate_chain", value)

        def domains(self, value: Optional[List[str]], /) -> Self:
            """
            List of fully qualified domain names (FQDNs) for
            which the certificate will be issued. The domains must be managed using
            DigitalOcean's DNS. Only valid when type is lets_encrypt.
            """
            return self._set("domains", value)

        @overload
        def domains_refs(
            self, value_or_callback: List[DomainsRef], /
        ) -> "InitProvider.Builder": ...

        @overload
        def domains_refs(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[DomainsRef, DomainsRef.Builder]],
                GenericListBuilder[DomainsRef, DomainsRef.Builder] | List[DomainsRef],
            ],
            /,
        ) -> "InitProvider.Builder": ...

        @overload
        def domains_refs(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[DomainsRef.Builder]: ...

        def domains_refs(self, value_or_callback=None, /):
            """
            References to Domain in dns to populate domains.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[DomainsRef.Builder]()
                context._parent_builder = self
                context._field_name = "domains_refs"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(DomainsRef.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("domains_refs", value)

        @overload
        def id(self, value_or_callback: Optional[Id], /) -> "InitProvider.Builder": ...

        @overload
        def id(
            self, value_or_callback: Callable[[Id.Builder], Id.Builder | Id], /
        ) -> "InitProvider.Builder": ...

        @overload
        def id(self, value_or_callback: Never = ...) -> "Id.BuilderContext": ...

        def id(self, value_or_callback=None, /):
            """
            The unique name of the certificate
            """
            if self._in_context and value_or_callback is None:
                context = Id.BuilderContext()
                context._parent_builder = self
                context._field_name = "id"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Id.builder())
                if isinstance(output, Id.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("id", value)

        def leaf_certificate(self, value: Optional[str], /) -> Self:
            """
            The contents of a PEM-formatted public
            TLS certificate. Only valid when type is custom.
            """
            return self._set("leaf_certificate", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            The name of the certificate for identification.
            """
            return self._set("name", value)

        @overload
        def private_key_secret_ref(
            self, value_or_callback: Optional[PrivateKeySecretRef], /
        ) -> "InitProvider.Builder": ...

        @overload
        def private_key_secret_ref(
            self,
            value_or_callback: Callable[
                [PrivateKeySecretRef.Builder],
                PrivateKeySecretRef.Builder | PrivateKeySecretRef,
            ],
            /,
        ) -> "InitProvider.Builder": ...

        @overload
        def private_key_secret_ref(
            self, value_or_callback: Never = ...
        ) -> "PrivateKeySecretRef.BuilderContext": ...

        def private_key_secret_ref(self, value_or_callback=None, /):
            """
            The contents of a PEM-formatted private-key
            corresponding to the SSL certificate. Only valid when type is custom.
            """
            if self._in_context and value_or_callback is None:
                context = PrivateKeySecretRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "private_key_secret_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PrivateKeySecretRef.builder())
                if isinstance(output, PrivateKeySecretRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("private_key_secret_ref", value)

        def type(self, value: Optional[str], /) -> Self:
            """
            The type of certificate to provision. Can be either
            custom or lets_encrypt. Defaults to custom.
            """
            return self._set("type", value)

    class BuilderContext(BuilderContextBase["InitProvider.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = InitProvider.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for InitProvider."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["InitProvider", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use InitProvider.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    certificate_chain: Annotated[Optional[str], Field(alias="certificateChain")] = None
    """
    The full PEM-formatted trust chain
    between the certificate authority's certificate and your domain's TLS
    certificate. Only valid when type is custom.
    """
    domains: Optional[List[str]] = None
    """
    List of fully qualified domain names (FQDNs) for
    which the certificate will be issued. The domains must be managed using
    DigitalOcean's DNS. Only valid when type is lets_encrypt.
    """
    domains_refs: Annotated[Optional[List[DomainsRef]], Field(alias="domainsRefs")] = None
    """
    References to Domain in dns to populate domains.
    """
    id: Optional[Id] = None
    """
    The unique name of the certificate
    """
    leaf_certificate: Annotated[Optional[str], Field(alias="leafCertificate")] = None
    """
    The contents of a PEM-formatted public
    TLS certificate. Only valid when type is custom.
    """
    name: Optional[str] = None
    """
    The name of the certificate for identification.
    """
    private_key_secret_ref: Annotated[
        Optional[PrivateKeySecretRef], Field(alias="privateKeySecretRef")
    ] = None
    """
    The contents of a PEM-formatted private-key
    corresponding to the SSL certificate. Only valid when type is custom.
    """
    type: Optional[str] = None
    """
    The type of certificate to provision. Can be either
    custom or lets_encrypt. Defaults to custom.
    """


class ProviderConfigRef(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ProviderConfigRef"]:
            return ProviderConfigRef

        def build(self) -> "ProviderConfigRef":
            return ProviderConfigRef(**self._attrs)

        def name(self, value: str, /) -> Self:
            """
            Name of the referenced object.
            """
            return self._set("name", value)

        @overload
        def policy(self, value_or_callback: Optional[Policy], /) -> "ProviderConfigRef.Builder": ...

        @overload
        def policy(
            self,
            value_or_callback: Callable[[Policy.Builder], Policy.Builder | Policy],
            /,
        ) -> "ProviderConfigRef.Builder": ...

        @overload
        def policy(self, value_or_callback: Never = ...) -> "Policy.BuilderContext": ...

        def policy(self, value_or_callback=None, /):
            """
            Policies for referencing.
            """
            if self._in_context and value_or_callback is None:
                context = Policy.BuilderContext()
                context._parent_builder = self
                context._field_name = "policy"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Policy.builder())
                if isinstance(output, Policy.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("policy", value)

    class BuilderContext(BuilderContextBase["ProviderConfigRef.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ProviderConfigRef.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ProviderConfigRef."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ProviderConfigRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ProviderConfigRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: str
    """
    Name of the referenced object.
    """
    policy: Optional[Policy] = None
    """
    Policies for referencing.
    """


class ConfigRef(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ConfigRef"]:
            return ConfigRef

        def build(self) -> "ConfigRef":
            return ConfigRef(**self._attrs)

        def name(self, value: str, /) -> Self:
            """
            Name of the referenced object.
            """
            return self._set("name", value)

        @overload
        def policy(self, value_or_callback: Optional[Policy], /) -> "ConfigRef.Builder": ...

        @overload
        def policy(
            self,
            value_or_callback: Callable[[Policy.Builder], Policy.Builder | Policy],
            /,
        ) -> "ConfigRef.Builder": ...

        @overload
        def policy(self, value_or_callback: Never = ...) -> "Policy.BuilderContext": ...

        def policy(self, value_or_callback=None, /):
            """
            Policies for referencing.
            """
            if self._in_context and value_or_callback is None:
                context = Policy.BuilderContext()
                context._parent_builder = self
                context._field_name = "policy"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Policy.builder())
                if isinstance(output, Policy.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("policy", value)

    class BuilderContext(BuilderContextBase["ConfigRef.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ConfigRef.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ConfigRef."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ConfigRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ConfigRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: str
    """
    Name of the referenced object.
    """
    policy: Optional[Policy] = None
    """
    Policies for referencing.
    """


class Metadata(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Metadata"]:
            return Metadata

        def build(self) -> "Metadata":
            return Metadata(**self._attrs)

        def annotations(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            Annotations are the annotations to be added to connection secret.
            - For Kubernetes secrets, this will be used as "metadata.annotations".
            - It is up to Secret Store implementation for others store types.
            """
            return self._set("annotations", value)

        def labels(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            Labels are the labels/tags to be added to connection secret.
            - For Kubernetes secrets, this will be used as "metadata.labels".
            - It is up to Secret Store implementation for others store types.
            """
            return self._set("labels", value)

        def type(self, value: Optional[str], /) -> Self:
            """
            Type is the SecretType for the connection secret.
            - Only valid for Kubernetes Secret Stores.
            """
            return self._set("type", value)

    class BuilderContext(BuilderContextBase["Metadata.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Metadata.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Metadata."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Metadata", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Metadata.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    annotations: Optional[Dict[str, str]] = None
    """
    Annotations are the annotations to be added to connection secret.
    - For Kubernetes secrets, this will be used as "metadata.annotations".
    - It is up to Secret Store implementation for others store types.
    """
    labels: Optional[Dict[str, str]] = None
    """
    Labels are the labels/tags to be added to connection secret.
    - For Kubernetes secrets, this will be used as "metadata.labels".
    - It is up to Secret Store implementation for others store types.
    """
    type: Optional[str] = None
    """
    Type is the SecretType for the connection secret.
    - Only valid for Kubernetes Secret Stores.
    """


class PublishConnectionDetailsTo(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PublishConnectionDetailsTo"]:
            return PublishConnectionDetailsTo

        def build(self) -> "PublishConnectionDetailsTo":
            return PublishConnectionDetailsTo(**self._attrs)

        @overload
        def config_ref(
            self, value_or_callback: Optional[ConfigRef], /
        ) -> "PublishConnectionDetailsTo.Builder": ...

        @overload
        def config_ref(
            self,
            value_or_callback: Callable[[ConfigRef.Builder], ConfigRef.Builder | ConfigRef],
            /,
        ) -> "PublishConnectionDetailsTo.Builder": ...

        @overload
        def config_ref(self, value_or_callback: Never = ...) -> "ConfigRef.BuilderContext": ...

        def config_ref(self, value_or_callback=None, /):
            """
            SecretStoreConfigRef specifies which secret store config should be used
            for this ConnectionSecret.
            """
            if self._in_context and value_or_callback is None:
                context = ConfigRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "config_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ConfigRef.builder())
                if isinstance(output, ConfigRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("config_ref", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[Metadata], /
        ) -> "PublishConnectionDetailsTo.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[[Metadata.Builder], Metadata.Builder | Metadata],
            /,
        ) -> "PublishConnectionDetailsTo.Builder": ...

        @overload
        def metadata(self, value_or_callback: Never = ...) -> "Metadata.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            """
            Metadata is the metadata for connection secret.
            """
            if self._in_context and value_or_callback is None:
                context = Metadata.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Metadata.builder())
                if isinstance(output, Metadata.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        def name(self, value: str, /) -> Self:
            """
            Name is the name of the connection secret.
            """
            return self._set("name", value)

    class BuilderContext(BuilderContextBase["PublishConnectionDetailsTo.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PublishConnectionDetailsTo.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PublishConnectionDetailsTo."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["PublishConnectionDetailsTo", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PublishConnectionDetailsTo.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    config_ref: Annotated[
        Optional[ConfigRef],
        Field(
            default_factory=lambda: ConfigRef.model_validate({"name": "default"}),
            alias="configRef",
        ),
    ] = {"name": "default"}
    """
    SecretStoreConfigRef specifies which secret store config should be used
    for this ConnectionSecret.
    """
    metadata: Optional[Metadata] = None
    """
    Metadata is the metadata for connection secret.
    """
    name: str
    """
    Name is the name of the connection secret.
    """


class WriteConnectionSecretToRef(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["WriteConnectionSecretToRef"]:
            return WriteConnectionSecretToRef

        def build(self) -> "WriteConnectionSecretToRef":
            return WriteConnectionSecretToRef(**self._attrs)

        def name(self, value: str, /) -> Self:
            """
            Name of the secret.
            """
            return self._set("name", value)

        def namespace(self, value: str, /) -> Self:
            """
            Namespace of the secret.
            """
            return self._set("namespace", value)

    class BuilderContext(BuilderContextBase["WriteConnectionSecretToRef.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = WriteConnectionSecretToRef.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for WriteConnectionSecretToRef."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["WriteConnectionSecretToRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use WriteConnectionSecretToRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: str
    """
    Name of the secret.
    """
    namespace: str
    """
    Namespace of the secret.
    """


class CertificateSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["CertificateSpec"]:
            return CertificateSpec

        def build(self) -> "CertificateSpec":
            return CertificateSpec(**self._attrs)

        def deletion_policy(self, value: Optional[Literal["Orphan", "Delete"]], /) -> Self:
            """
            DeletionPolicy specifies what will happen to the underlying external
            when this managed resource is deleted - either "Delete" or "Orphan" the
            external resource.
            This field is planned to be deprecated in favor of the ManagementPolicies
            field in a future release. Currently, both could be set independently and
            non-default values would be honored if the feature flag is enabled.
            See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
            """
            return self._set("deletion_policy", value)

        @overload
        def for_provider(self, value_or_callback: ForProvider, /) -> "CertificateSpec.Builder": ...

        @overload
        def for_provider(
            self,
            value_or_callback: Callable[[ForProvider.Builder], ForProvider.Builder | ForProvider],
            /,
        ) -> "CertificateSpec.Builder": ...

        @overload
        def for_provider(self, value_or_callback: Never = ...) -> "ForProvider.BuilderContext": ...

        def for_provider(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ForProvider.BuilderContext()
                context._parent_builder = self
                context._field_name = "for_provider"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ForProvider.builder())
                if isinstance(output, ForProvider.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("for_provider", value)

        @overload
        def init_provider(
            self, value_or_callback: Optional[InitProvider], /
        ) -> "CertificateSpec.Builder": ...

        @overload
        def init_provider(
            self,
            value_or_callback: Callable[
                [InitProvider.Builder], InitProvider.Builder | InitProvider
            ],
            /,
        ) -> "CertificateSpec.Builder": ...

        @overload
        def init_provider(
            self, value_or_callback: Never = ...
        ) -> "InitProvider.BuilderContext": ...

        def init_provider(self, value_or_callback=None, /):
            """
            THIS IS A BETA FIELD. It will be honored
            unless the Management Policies feature flag is disabled.
            InitProvider holds the same fields as ForProvider, with the exception
            of Identifier and other resource reference fields. The fields that are
            in InitProvider are merged into ForProvider when the resource is created.
            The same fields are also added to the terraform ignore_changes hook, to
            avoid updating them after creation. This is useful for fields that are
            required on creation, but we do not desire to update them after creation,
            for example because of an external controller is managing them, like an
            autoscaler.
            """
            if self._in_context and value_or_callback is None:
                context = InitProvider.BuilderContext()
                context._parent_builder = self
                context._field_name = "init_provider"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(InitProvider.builder())
                if isinstance(output, InitProvider.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("init_provider", value)

        def management_policies(
            self,
            value: Optional[
                List[Literal["Observe", "Create", "Update", "Delete", "LateInitialize", "*"]]
            ],
            /,
        ) -> Self:
            """
            THIS IS A BETA FIELD. It is on by default but can be opted out
            through a Crossplane feature flag.
            ManagementPolicies specify the array of actions Crossplane is allowed to
            take on the managed and external resources.
            This field is planned to replace the DeletionPolicy field in a future
            release. Currently, both could be set independently and non-default
            values would be honored if the feature flag is enabled. If both are
            custom, the DeletionPolicy field will be ignored.
            See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
            and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
            """
            return self._set("management_policies", value)

        @overload
        def provider_config_ref(
            self, value_or_callback: Optional[ProviderConfigRef], /
        ) -> "CertificateSpec.Builder": ...

        @overload
        def provider_config_ref(
            self,
            value_or_callback: Callable[
                [ProviderConfigRef.Builder],
                ProviderConfigRef.Builder | ProviderConfigRef,
            ],
            /,
        ) -> "CertificateSpec.Builder": ...

        @overload
        def provider_config_ref(
            self, value_or_callback: Never = ...
        ) -> "ProviderConfigRef.BuilderContext": ...

        def provider_config_ref(self, value_or_callback=None, /):
            """
            ProviderConfigReference specifies how the provider that will be used to
            create, observe, update, and delete this managed resource should be
            configured.
            """
            if self._in_context and value_or_callback is None:
                context = ProviderConfigRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "provider_config_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ProviderConfigRef.builder())
                if isinstance(output, ProviderConfigRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("provider_config_ref", value)

        @overload
        def publish_connection_details_to(
            self, value_or_callback: Optional[PublishConnectionDetailsTo], /
        ) -> "CertificateSpec.Builder": ...

        @overload
        def publish_connection_details_to(
            self,
            value_or_callback: Callable[
                [PublishConnectionDetailsTo.Builder],
                PublishConnectionDetailsTo.Builder | PublishConnectionDetailsTo,
            ],
            /,
        ) -> "CertificateSpec.Builder": ...

        @overload
        def publish_connection_details_to(
            self, value_or_callback: Never = ...
        ) -> "PublishConnectionDetailsTo.BuilderContext": ...

        def publish_connection_details_to(self, value_or_callback=None, /):
            """
            PublishConnectionDetailsTo specifies the connection secret config which
            contains a name, metadata and a reference to secret store config to
            which any connection details for this managed resource should be written.
            Connection details frequently include the endpoint, username,
            and password required to connect to the managed resource.
            """
            if self._in_context and value_or_callback is None:
                context = PublishConnectionDetailsTo.BuilderContext()
                context._parent_builder = self
                context._field_name = "publish_connection_details_to"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PublishConnectionDetailsTo.builder())
                if isinstance(output, PublishConnectionDetailsTo.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("publish_connection_details_to", value)

        @overload
        def write_connection_secret_to_ref(
            self, value_or_callback: Optional[WriteConnectionSecretToRef], /
        ) -> "CertificateSpec.Builder": ...

        @overload
        def write_connection_secret_to_ref(
            self,
            value_or_callback: Callable[
                [WriteConnectionSecretToRef.Builder],
                WriteConnectionSecretToRef.Builder | WriteConnectionSecretToRef,
            ],
            /,
        ) -> "CertificateSpec.Builder": ...

        @overload
        def write_connection_secret_to_ref(
            self, value_or_callback: Never = ...
        ) -> "WriteConnectionSecretToRef.BuilderContext": ...

        def write_connection_secret_to_ref(self, value_or_callback=None, /):
            """
            WriteConnectionSecretToReference specifies the namespace and name of a
            Secret to which any connection details for this managed resource should
            be written. Connection details frequently include the endpoint, username,
            and password required to connect to the managed resource.
            This field is planned to be replaced in a future release in favor of
            PublishConnectionDetailsTo. Currently, both could be set independently
            and connection details would be published to both without affecting
            each other.
            """
            if self._in_context and value_or_callback is None:
                context = WriteConnectionSecretToRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "write_connection_secret_to_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(WriteConnectionSecretToRef.builder())
                if isinstance(output, WriteConnectionSecretToRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("write_connection_secret_to_ref", value)

    class BuilderContext(BuilderContextBase["CertificateSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = CertificateSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for CertificateSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["CertificateSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use CertificateSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    deletion_policy: Annotated[
        Optional[Literal["Orphan", "Delete"]], Field(alias="deletionPolicy")
    ] = "Delete"
    """
    DeletionPolicy specifies what will happen to the underlying external
    when this managed resource is deleted - either "Delete" or "Orphan" the
    external resource.
    This field is planned to be deprecated in favor of the ManagementPolicies
    field in a future release. Currently, both could be set independently and
    non-default values would be honored if the feature flag is enabled.
    See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    """
    for_provider: Annotated[ForProvider, Field(alias="forProvider")]
    init_provider: Annotated[Optional[InitProvider], Field(alias="initProvider")] = None
    """
    THIS IS A BETA FIELD. It will be honored
    unless the Management Policies feature flag is disabled.
    InitProvider holds the same fields as ForProvider, with the exception
    of Identifier and other resource reference fields. The fields that are
    in InitProvider are merged into ForProvider when the resource is created.
    The same fields are also added to the terraform ignore_changes hook, to
    avoid updating them after creation. This is useful for fields that are
    required on creation, but we do not desire to update them after creation,
    for example because of an external controller is managing them, like an
    autoscaler.
    """
    management_policies: Annotated[
        Optional[List[Literal["Observe", "Create", "Update", "Delete", "LateInitialize", "*"]]],
        Field(alias="managementPolicies"),
    ] = ["*"]
    """
    THIS IS A BETA FIELD. It is on by default but can be opted out
    through a Crossplane feature flag.
    ManagementPolicies specify the array of actions Crossplane is allowed to
    take on the managed and external resources.
    This field is planned to replace the DeletionPolicy field in a future
    release. Currently, both could be set independently and non-default
    values would be honored if the feature flag is enabled. If both are
    custom, the DeletionPolicy field will be ignored.
    See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
    """
    provider_config_ref: Annotated[
        Optional[ProviderConfigRef],
        Field(
            default_factory=lambda: ProviderConfigRef.model_validate({"name": "default"}),
            alias="providerConfigRef",
        ),
    ] = {"name": "default"}
    """
    ProviderConfigReference specifies how the provider that will be used to
    create, observe, update, and delete this managed resource should be
    configured.
    """
    publish_connection_details_to: Annotated[
        Optional[PublishConnectionDetailsTo], Field(alias="publishConnectionDetailsTo")
    ] = None
    """
    PublishConnectionDetailsTo specifies the connection secret config which
    contains a name, metadata and a reference to secret store config to
    which any connection details for this managed resource should be written.
    Connection details frequently include the endpoint, username,
    and password required to connect to the managed resource.
    """
    write_connection_secret_to_ref: Annotated[
        Optional[WriteConnectionSecretToRef], Field(alias="writeConnectionSecretToRef")
    ] = None
    """
    WriteConnectionSecretToReference specifies the namespace and name of a
    Secret to which any connection details for this managed resource should
    be written. Connection details frequently include the endpoint, username,
    and password required to connect to the managed resource.
    This field is planned to be replaced in a future release in favor of
    PublishConnectionDetailsTo. Currently, both could be set independently
    and connection details would be published to both without affecting
    each other.
    """


class AtProvider(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AtProvider"]:
            return AtProvider

        def build(self) -> "AtProvider":
            return AtProvider(**self._attrs)

        def certificate_chain(self, value: Optional[str], /) -> Self:
            """
            The full PEM-formatted trust chain
            between the certificate authority's certificate and your domain's TLS
            certificate. Only valid when type is custom.
            """
            return self._set("certificate_chain", value)

        def domains(self, value: Optional[List[str]], /) -> Self:
            """
            List of fully qualified domain names (FQDNs) for
            which the certificate will be issued. The domains must be managed using
            DigitalOcean's DNS. Only valid when type is lets_encrypt.
            """
            return self._set("domains", value)

        def id(self, value: Optional[str], /) -> Self:
            """
            The unique name of the certificate
            """
            return self._set("id", value)

        def leaf_certificate(self, value: Optional[str], /) -> Self:
            """
            The contents of a PEM-formatted public
            TLS certificate. Only valid when type is custom.
            """
            return self._set("leaf_certificate", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            The name of the certificate for identification.
            """
            return self._set("name", value)

        def not_after(self, value: Optional[str], /) -> Self:
            """
            The expiration date of the certificate
            """
            return self._set("not_after", value)

        def sha1_fingerprint(self, value: Optional[str], /) -> Self:
            """
            The SHA-1 fingerprint of the certificate
            """
            return self._set("sha1_fingerprint", value)

        def state(self, value: Optional[str], /) -> Self:
            return self._set("state", value)

        def type(self, value: Optional[str], /) -> Self:
            """
            The type of certificate to provision. Can be either
            custom or lets_encrypt. Defaults to custom.
            """
            return self._set("type", value)

        def uuid(self, value: Optional[str], /) -> Self:
            """
            The UUID of the certificate
            """
            return self._set("uuid", value)

    class BuilderContext(BuilderContextBase["AtProvider.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AtProvider.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AtProvider."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AtProvider", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AtProvider.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    certificate_chain: Annotated[Optional[str], Field(alias="certificateChain")] = None
    """
    The full PEM-formatted trust chain
    between the certificate authority's certificate and your domain's TLS
    certificate. Only valid when type is custom.
    """
    domains: Optional[List[str]] = None
    """
    List of fully qualified domain names (FQDNs) for
    which the certificate will be issued. The domains must be managed using
    DigitalOcean's DNS. Only valid when type is lets_encrypt.
    """
    id: Optional[str] = None
    """
    The unique name of the certificate
    """
    leaf_certificate: Annotated[Optional[str], Field(alias="leafCertificate")] = None
    """
    The contents of a PEM-formatted public
    TLS certificate. Only valid when type is custom.
    """
    name: Optional[str] = None
    """
    The name of the certificate for identification.
    """
    not_after: Annotated[Optional[str], Field(alias="notAfter")] = None
    """
    The expiration date of the certificate
    """
    sha1_fingerprint: Annotated[Optional[str], Field(alias="sha1Fingerprint")] = None
    """
    The SHA-1 fingerprint of the certificate
    """
    state: Optional[str] = None
    type: Optional[str] = None
    """
    The type of certificate to provision. Can be either
    custom or lets_encrypt. Defaults to custom.
    """
    uuid: Optional[str] = None
    """
    The UUID of the certificate
    """


class Condition(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Condition"]:
            return Condition

        def build(self) -> "Condition":
            return Condition(**self._attrs)

        def last_transition_time(self, value: AwareDatetime, /) -> Self:
            """
            LastTransitionTime is the last time this condition transitioned from one
            status to another.
            """
            return self._set("last_transition_time", value)

        def message(self, value: Optional[str], /) -> Self:
            """
            A Message containing details about this condition's last transition from
            one status to another, if any.
            """
            return self._set("message", value)

        def observed_generation(self, value: Optional[int], /) -> Self:
            """
            ObservedGeneration represents the .metadata.generation that the condition was set based upon.
            For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
            with respect to the current state of the instance.
            """
            return self._set("observed_generation", value)

        def reason(self, value: str, /) -> Self:
            """
            A Reason for this condition's last transition from one status to another.
            """
            return self._set("reason", value)

        def status(self, value: str, /) -> Self:
            """
            Status of this condition; is it currently True, False, or Unknown?
            """
            return self._set("status", value)

        def type(self, value: str, /) -> Self:
            """
            Type of this condition. At most one of each condition type may apply to
            a resource at any point in time.
            """
            return self._set("type", value)

    class BuilderContext(BuilderContextBase["Condition.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Condition.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Condition."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Condition", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Condition.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    last_transition_time: Annotated[AwareDatetime, Field(alias="lastTransitionTime")]
    """
    LastTransitionTime is the last time this condition transitioned from one
    status to another.
    """
    message: Optional[str] = None
    """
    A Message containing details about this condition's last transition from
    one status to another, if any.
    """
    observed_generation: Annotated[Optional[int], Field(alias="observedGeneration")] = None
    """
    ObservedGeneration represents the .metadata.generation that the condition was set based upon.
    For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
    with respect to the current state of the instance.
    """
    reason: str
    """
    A Reason for this condition's last transition from one status to another.
    """
    status: str
    """
    Status of this condition; is it currently True, False, or Unknown?
    """
    type: str
    """
    Type of this condition. At most one of each condition type may apply to
    a resource at any point in time.
    """


class CertificateStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["CertificateStatus"]:
            return CertificateStatus

        def build(self) -> "CertificateStatus":
            return CertificateStatus(**self._attrs)

        @overload
        def at_provider(
            self, value_or_callback: Optional[AtProvider], /
        ) -> "CertificateStatus.Builder": ...

        @overload
        def at_provider(
            self,
            value_or_callback: Callable[[AtProvider.Builder], AtProvider.Builder | AtProvider],
            /,
        ) -> "CertificateStatus.Builder": ...

        @overload
        def at_provider(self, value_or_callback: Never = ...) -> "AtProvider.BuilderContext": ...

        def at_provider(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = AtProvider.BuilderContext()
                context._parent_builder = self
                context._field_name = "at_provider"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AtProvider.builder())
                if isinstance(output, AtProvider.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("at_provider", value)

        @overload
        def conditions(
            self, value_or_callback: List[Condition], /
        ) -> "CertificateStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Condition, Condition.Builder]],
                GenericListBuilder[Condition, Condition.Builder] | List[Condition],
            ],
            /,
        ) -> "CertificateStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            """
            Conditions of the resource.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        def observed_generation(self, value: Optional[int], /) -> Self:
            """
            ObservedGeneration is the latest metadata.generation
            which resulted in either a ready state, or stalled due to error
            it can not recover from without human intervention.
            """
            return self._set("observed_generation", value)

    class BuilderContext(BuilderContextBase["CertificateStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = CertificateStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for CertificateStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["CertificateStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use CertificateStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    at_provider: Annotated[Optional[AtProvider], Field(alias="atProvider")] = None
    conditions: Optional[List[Condition]] = None
    """
    Conditions of the resource.
    """
    observed_generation: Annotated[Optional[int], Field(alias="observedGeneration")] = None
    """
    ObservedGeneration is the latest metadata.generation
    which resulted in either a ready state, or stalled due to error
    it can not recover from without human intervention.
    """


class DropletIdsRef(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["DropletIdsRef"]:
            return DropletIdsRef

        def build(self) -> "DropletIdsRef":
            return DropletIdsRef(**self._attrs)

        def name(self, value: str, /) -> Self:
            """
            Name of the referenced object.
            """
            return self._set("name", value)

        @overload
        def policy(self, value_or_callback: Optional[Policy], /) -> "DropletIdsRef.Builder": ...

        @overload
        def policy(
            self,
            value_or_callback: Callable[[Policy.Builder], Policy.Builder | Policy],
            /,
        ) -> "DropletIdsRef.Builder": ...

        @overload
        def policy(self, value_or_callback: Never = ...) -> "Policy.BuilderContext": ...

        def policy(self, value_or_callback=None, /):
            """
            Policies for referencing.
            """
            if self._in_context and value_or_callback is None:
                context = Policy.BuilderContext()
                context._parent_builder = self
                context._field_name = "policy"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Policy.builder())
                if isinstance(output, Policy.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("policy", value)

    class BuilderContext(BuilderContextBase["DropletIdsRef.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DropletIdsRef.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DropletIdsRef."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["DropletIdsRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use DropletIdsRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: str
    """
    Name of the referenced object.
    """
    policy: Optional[Policy] = None
    """
    Policies for referencing.
    """


class DropletIdsSelector(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["DropletIdsSelector"]:
            return DropletIdsSelector

        def build(self) -> "DropletIdsSelector":
            return DropletIdsSelector(**self._attrs)

        def match_controller_ref(self, value: Optional[bool], /) -> Self:
            """
            MatchControllerRef ensures an object with the same controller reference
            as the selecting object is selected.
            """
            return self._set("match_controller_ref", value)

        def match_labels(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            MatchLabels ensures an object with matching labels is selected.
            """
            return self._set("match_labels", value)

        @overload
        def policy(
            self, value_or_callback: Optional[Policy], /
        ) -> "DropletIdsSelector.Builder": ...

        @overload
        def policy(
            self,
            value_or_callback: Callable[[Policy.Builder], Policy.Builder | Policy],
            /,
        ) -> "DropletIdsSelector.Builder": ...

        @overload
        def policy(self, value_or_callback: Never = ...) -> "Policy.BuilderContext": ...

        def policy(self, value_or_callback=None, /):
            """
            Policies for selection.
            """
            if self._in_context and value_or_callback is None:
                context = Policy.BuilderContext()
                context._parent_builder = self
                context._field_name = "policy"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Policy.builder())
                if isinstance(output, Policy.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("policy", value)

    class BuilderContext(BuilderContextBase["DropletIdsSelector.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DropletIdsSelector.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DropletIdsSelector."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["DropletIdsSelector", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use DropletIdsSelector.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    match_controller_ref: Annotated[Optional[bool], Field(alias="matchControllerRef")] = None
    """
    MatchControllerRef ensures an object with the same controller reference
    as the selecting object is selected.
    """
    match_labels: Annotated[Optional[Dict[str, str]], Field(alias="matchLabels")] = None
    """
    MatchLabels ensures an object with matching labels is selected.
    """
    policy: Optional[Policy] = None
    """
    Policies for selection.
    """


class InboundRule(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["InboundRule"]:
            return InboundRule

        def build(self) -> "InboundRule":
            return InboundRule(**self._attrs)

        def port_range(self, value: Optional[str], /) -> Self:
            """
            The ports on which traffic will be allowed
            specified as a string containing a single port, a range (e.g. "8000-9000"),
            or "1-65535" to open all ports for a protocol. Required for when protocol is
            tcp or udp.
            """
            return self._set("port_range", value)

        def protocol(self, value: Optional[str], /) -> Self:
            """
            The type of traffic to be allowed.
            This may be one of "tcp", "udp", or "icmp".
            """
            return self._set("protocol", value)

        def source_addresses(self, value: Optional[List[str]], /) -> Self:
            """
            An array of strings containing the IPv4
            addresses, IPv6 addresses, IPv4 CIDRs, and/or IPv6 CIDRs from which the
            inbound traffic will be accepted.
            """
            return self._set("source_addresses", value)

        def source_droplet_ids(self, value: Optional[List[float]], /) -> Self:
            """
            An array containing the IDs of
            the Droplets from which the inbound traffic will be accepted.
            """
            return self._set("source_droplet_ids", value)

        def source_kubernetes_ids(self, value: Optional[List[str]], /) -> Self:
            """
            An array containing the IDs of
            the Kubernetes clusters from which the inbound traffic will be accepted.
            """
            return self._set("source_kubernetes_ids", value)

        def source_load_balancer_uids(self, value: Optional[List[str]], /) -> Self:
            """
            An array containing the IDs
            of the Load Balancers from which the inbound traffic will be accepted.
            """
            return self._set("source_load_balancer_uids", value)

        def source_tags(self, value: Optional[List[str]], /) -> Self:
            """
            An array containing the names of Tags
            corresponding to groups of Droplets from which the inbound traffic
            will be accepted.
            """
            return self._set("source_tags", value)

    class BuilderContext(BuilderContextBase["InboundRule.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = InboundRule.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for InboundRule."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["InboundRule", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use InboundRule.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    port_range: Annotated[Optional[str], Field(alias="portRange")] = None
    """
    The ports on which traffic will be allowed
    specified as a string containing a single port, a range (e.g. "8000-9000"),
    or "1-65535" to open all ports for a protocol. Required for when protocol is
    tcp or udp.
    """
    protocol: Optional[str] = None
    """
    The type of traffic to be allowed.
    This may be one of "tcp", "udp", or "icmp".
    """
    source_addresses: Annotated[Optional[List[str]], Field(alias="sourceAddresses")] = None
    """
    An array of strings containing the IPv4
    addresses, IPv6 addresses, IPv4 CIDRs, and/or IPv6 CIDRs from which the
    inbound traffic will be accepted.
    """
    source_droplet_ids: Annotated[Optional[List[float]], Field(alias="sourceDropletIds")] = None
    """
    An array containing the IDs of
    the Droplets from which the inbound traffic will be accepted.
    """
    source_kubernetes_ids: Annotated[Optional[List[str]], Field(alias="sourceKubernetesIds")] = None
    """
    An array containing the IDs of
    the Kubernetes clusters from which the inbound traffic will be accepted.
    """
    source_load_balancer_uids: Annotated[
        Optional[List[str]], Field(alias="sourceLoadBalancerUids")
    ] = None
    """
    An array containing the IDs
    of the Load Balancers from which the inbound traffic will be accepted.
    """
    source_tags: Annotated[Optional[List[str]], Field(alias="sourceTags")] = None
    """
    An array containing the names of Tags
    corresponding to groups of Droplets from which the inbound traffic
    will be accepted.
    """


class OutboundRule(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["OutboundRule"]:
            return OutboundRule

        def build(self) -> "OutboundRule":
            return OutboundRule(**self._attrs)

        def destination_addresses(self, value: Optional[List[str]], /) -> Self:
            """
            An array of strings containing the IPv4
            addresses, IPv6 addresses, IPv4 CIDRs, and/or IPv6 CIDRs to which the
            outbound traffic will be allowed.
            """
            return self._set("destination_addresses", value)

        def destination_droplet_ids(self, value: Optional[List[float]], /) -> Self:
            """
            An array containing the IDs of
            the Droplets to which the outbound traffic will be allowed.
            """
            return self._set("destination_droplet_ids", value)

        def destination_kubernetes_ids(self, value: Optional[List[str]], /) -> Self:
            """
            An array containing the IDs of
            the Kubernetes clusters to which the outbound traffic will be allowed.
            """
            return self._set("destination_kubernetes_ids", value)

        def destination_load_balancer_uids(self, value: Optional[List[str]], /) -> Self:
            """
            An array containing the IDs
            of the Load Balancers to which the outbound traffic will be allowed.
            """
            return self._set("destination_load_balancer_uids", value)

        def destination_tags(self, value: Optional[List[str]], /) -> Self:
            """
            An array containing the names of Tags
            corresponding to groups of Droplets to which the outbound traffic will
            be allowed.
            """
            return self._set("destination_tags", value)

        def port_range(self, value: Optional[str], /) -> Self:
            """
            The ports on which traffic will be allowed
            specified as a string containing a single port, a range (e.g. "8000-9000"),
            or "1-65535" to open all ports for a protocol. Required for when protocol is
            tcp or udp.
            """
            return self._set("port_range", value)

        def protocol(self, value: Optional[str], /) -> Self:
            """
            The type of traffic to be allowed.
            This may be one of "tcp", "udp", or "icmp".
            """
            return self._set("protocol", value)

    class BuilderContext(BuilderContextBase["OutboundRule.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = OutboundRule.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for OutboundRule."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["OutboundRule", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use OutboundRule.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    destination_addresses: Annotated[Optional[List[str]], Field(alias="destinationAddresses")] = (
        None
    )
    """
    An array of strings containing the IPv4
    addresses, IPv6 addresses, IPv4 CIDRs, and/or IPv6 CIDRs to which the
    outbound traffic will be allowed.
    """
    destination_droplet_ids: Annotated[
        Optional[List[float]], Field(alias="destinationDropletIds")
    ] = None
    """
    An array containing the IDs of
    the Droplets to which the outbound traffic will be allowed.
    """
    destination_kubernetes_ids: Annotated[
        Optional[List[str]], Field(alias="destinationKubernetesIds")
    ] = None
    """
    An array containing the IDs of
    the Kubernetes clusters to which the outbound traffic will be allowed.
    """
    destination_load_balancer_uids: Annotated[
        Optional[List[str]], Field(alias="destinationLoadBalancerUids")
    ] = None
    """
    An array containing the IDs
    of the Load Balancers to which the outbound traffic will be allowed.
    """
    destination_tags: Annotated[Optional[List[str]], Field(alias="destinationTags")] = None
    """
    An array containing the names of Tags
    corresponding to groups of Droplets to which the outbound traffic will
    be allowed.
    """
    port_range: Annotated[Optional[str], Field(alias="portRange")] = None
    """
    The ports on which traffic will be allowed
    specified as a string containing a single port, a range (e.g. "8000-9000"),
    or "1-65535" to open all ports for a protocol. Required for when protocol is
    tcp or udp.
    """
    protocol: Optional[str] = None
    """
    The type of traffic to be allowed.
    This may be one of "tcp", "udp", or "icmp".
    """


class ForProviderModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ForProviderModel"]:
            return ForProviderModel

        def build(self) -> "ForProviderModel":
            return ForProviderModel(**self._attrs)

        def droplet_ids(self, value: Optional[List[float]], /) -> Self:
            """
            The list of the IDs of the Droplets assigned
            to the Firewall.
            """
            return self._set("droplet_ids", value)

        @overload
        def droplet_ids_refs(
            self, value_or_callback: List[DropletIdsRef], /
        ) -> "ForProviderModel.Builder": ...

        @overload
        def droplet_ids_refs(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[DropletIdsRef, DropletIdsRef.Builder]],
                GenericListBuilder[DropletIdsRef, DropletIdsRef.Builder] | List[DropletIdsRef],
            ],
            /,
        ) -> "ForProviderModel.Builder": ...

        @overload
        def droplet_ids_refs(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[DropletIdsRef.Builder]: ...

        def droplet_ids_refs(self, value_or_callback=None, /):
            """
            References to Droplet in droplet to populate dropletIds.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[DropletIdsRef.Builder]()
                context._parent_builder = self
                context._field_name = "droplet_ids_refs"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(DropletIdsRef.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("droplet_ids_refs", value)

        @overload
        def droplet_ids_selector(
            self, value_or_callback: Optional[DropletIdsSelector], /
        ) -> "ForProviderModel.Builder": ...

        @overload
        def droplet_ids_selector(
            self,
            value_or_callback: Callable[
                [DropletIdsSelector.Builder],
                DropletIdsSelector.Builder | DropletIdsSelector,
            ],
            /,
        ) -> "ForProviderModel.Builder": ...

        @overload
        def droplet_ids_selector(
            self, value_or_callback: Never = ...
        ) -> "DropletIdsSelector.BuilderContext": ...

        def droplet_ids_selector(self, value_or_callback=None, /):
            """
            Selector for a list of Droplet in droplet to populate dropletIds.
            """
            if self._in_context and value_or_callback is None:
                context = DropletIdsSelector.BuilderContext()
                context._parent_builder = self
                context._field_name = "droplet_ids_selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(DropletIdsSelector.builder())
                if isinstance(output, DropletIdsSelector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("droplet_ids_selector", value)

        @overload
        def inbound_rule(
            self, value_or_callback: List[InboundRule], /
        ) -> "ForProviderModel.Builder": ...

        @overload
        def inbound_rule(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[InboundRule, InboundRule.Builder]],
                GenericListBuilder[InboundRule, InboundRule.Builder] | List[InboundRule],
            ],
            /,
        ) -> "ForProviderModel.Builder": ...

        @overload
        def inbound_rule(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[InboundRule.Builder]: ...

        def inbound_rule(self, value_or_callback=None, /):
            """
            The inbound access rule block for the Firewall.
            The inbound_rule block is documented below.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[InboundRule.Builder]()
                context._parent_builder = self
                context._field_name = "inbound_rule"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(InboundRule.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("inbound_rule", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            The Firewall name
            """
            return self._set("name", value)

        @overload
        def outbound_rule(
            self, value_or_callback: List[OutboundRule], /
        ) -> "ForProviderModel.Builder": ...

        @overload
        def outbound_rule(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[OutboundRule, OutboundRule.Builder]],
                GenericListBuilder[OutboundRule, OutboundRule.Builder] | List[OutboundRule],
            ],
            /,
        ) -> "ForProviderModel.Builder": ...

        @overload
        def outbound_rule(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[OutboundRule.Builder]: ...

        def outbound_rule(self, value_or_callback=None, /):
            """
            The outbound access rule block for the Firewall.
            The outbound_rule block is documented below.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[OutboundRule.Builder]()
                context._parent_builder = self
                context._field_name = "outbound_rule"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(OutboundRule.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("outbound_rule", value)

        def tags(self, value: Optional[List[str]], /) -> Self:
            """
            The names of the Tags assigned to the Firewall.
            """
            return self._set("tags", value)

    class BuilderContext(BuilderContextBase["ForProviderModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ForProviderModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ForProviderModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ForProviderModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ForProviderModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    droplet_ids: Annotated[Optional[List[float]], Field(alias="dropletIds")] = None
    """
    The list of the IDs of the Droplets assigned
    to the Firewall.
    """
    droplet_ids_refs: Annotated[Optional[List[DropletIdsRef]], Field(alias="dropletIdsRefs")] = None
    """
    References to Droplet in droplet to populate dropletIds.
    """
    droplet_ids_selector: Annotated[
        Optional[DropletIdsSelector], Field(alias="dropletIdsSelector")
    ] = None
    """
    Selector for a list of Droplet in droplet to populate dropletIds.
    """
    inbound_rule: Annotated[Optional[List[InboundRule]], Field(alias="inboundRule")] = None
    """
    The inbound access rule block for the Firewall.
    The inbound_rule block is documented below.
    """
    name: Optional[str] = None
    """
    The Firewall name
    """
    outbound_rule: Annotated[Optional[List[OutboundRule]], Field(alias="outboundRule")] = None
    """
    The outbound access rule block for the Firewall.
    The outbound_rule block is documented below.
    """
    tags: Optional[List[str]] = None
    """
    The names of the Tags assigned to the Firewall.
    """


class InitProviderModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["InitProviderModel"]:
            return InitProviderModel

        def build(self) -> "InitProviderModel":
            return InitProviderModel(**self._attrs)

        def droplet_ids(self, value: Optional[List[float]], /) -> Self:
            """
            The list of the IDs of the Droplets assigned
            to the Firewall.
            """
            return self._set("droplet_ids", value)

        @overload
        def droplet_ids_refs(
            self, value_or_callback: List[DropletIdsRef], /
        ) -> "InitProviderModel.Builder": ...

        @overload
        def droplet_ids_refs(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[DropletIdsRef, DropletIdsRef.Builder]],
                GenericListBuilder[DropletIdsRef, DropletIdsRef.Builder] | List[DropletIdsRef],
            ],
            /,
        ) -> "InitProviderModel.Builder": ...

        @overload
        def droplet_ids_refs(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[DropletIdsRef.Builder]: ...

        def droplet_ids_refs(self, value_or_callback=None, /):
            """
            References to Droplet in droplet to populate dropletIds.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[DropletIdsRef.Builder]()
                context._parent_builder = self
                context._field_name = "droplet_ids_refs"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(DropletIdsRef.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("droplet_ids_refs", value)

        @overload
        def droplet_ids_selector(
            self, value_or_callback: Optional[DropletIdsSelector], /
        ) -> "InitProviderModel.Builder": ...

        @overload
        def droplet_ids_selector(
            self,
            value_or_callback: Callable[
                [DropletIdsSelector.Builder],
                DropletIdsSelector.Builder | DropletIdsSelector,
            ],
            /,
        ) -> "InitProviderModel.Builder": ...

        @overload
        def droplet_ids_selector(
            self, value_or_callback: Never = ...
        ) -> "DropletIdsSelector.BuilderContext": ...

        def droplet_ids_selector(self, value_or_callback=None, /):
            """
            Selector for a list of Droplet in droplet to populate dropletIds.
            """
            if self._in_context and value_or_callback is None:
                context = DropletIdsSelector.BuilderContext()
                context._parent_builder = self
                context._field_name = "droplet_ids_selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(DropletIdsSelector.builder())
                if isinstance(output, DropletIdsSelector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("droplet_ids_selector", value)

        @overload
        def inbound_rule(
            self, value_or_callback: List[InboundRule], /
        ) -> "InitProviderModel.Builder": ...

        @overload
        def inbound_rule(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[InboundRule, InboundRule.Builder]],
                GenericListBuilder[InboundRule, InboundRule.Builder] | List[InboundRule],
            ],
            /,
        ) -> "InitProviderModel.Builder": ...

        @overload
        def inbound_rule(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[InboundRule.Builder]: ...

        def inbound_rule(self, value_or_callback=None, /):
            """
            The inbound access rule block for the Firewall.
            The inbound_rule block is documented below.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[InboundRule.Builder]()
                context._parent_builder = self
                context._field_name = "inbound_rule"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(InboundRule.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("inbound_rule", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            The Firewall name
            """
            return self._set("name", value)

        @overload
        def outbound_rule(
            self, value_or_callback: List[OutboundRule], /
        ) -> "InitProviderModel.Builder": ...

        @overload
        def outbound_rule(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[OutboundRule, OutboundRule.Builder]],
                GenericListBuilder[OutboundRule, OutboundRule.Builder] | List[OutboundRule],
            ],
            /,
        ) -> "InitProviderModel.Builder": ...

        @overload
        def outbound_rule(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[OutboundRule.Builder]: ...

        def outbound_rule(self, value_or_callback=None, /):
            """
            The outbound access rule block for the Firewall.
            The outbound_rule block is documented below.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[OutboundRule.Builder]()
                context._parent_builder = self
                context._field_name = "outbound_rule"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(OutboundRule.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("outbound_rule", value)

        def tags(self, value: Optional[List[str]], /) -> Self:
            """
            The names of the Tags assigned to the Firewall.
            """
            return self._set("tags", value)

    class BuilderContext(BuilderContextBase["InitProviderModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = InitProviderModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for InitProviderModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["InitProviderModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use InitProviderModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    droplet_ids: Annotated[Optional[List[float]], Field(alias="dropletIds")] = None
    """
    The list of the IDs of the Droplets assigned
    to the Firewall.
    """
    droplet_ids_refs: Annotated[Optional[List[DropletIdsRef]], Field(alias="dropletIdsRefs")] = None
    """
    References to Droplet in droplet to populate dropletIds.
    """
    droplet_ids_selector: Annotated[
        Optional[DropletIdsSelector], Field(alias="dropletIdsSelector")
    ] = None
    """
    Selector for a list of Droplet in droplet to populate dropletIds.
    """
    inbound_rule: Annotated[Optional[List[InboundRule]], Field(alias="inboundRule")] = None
    """
    The inbound access rule block for the Firewall.
    The inbound_rule block is documented below.
    """
    name: Optional[str] = None
    """
    The Firewall name
    """
    outbound_rule: Annotated[Optional[List[OutboundRule]], Field(alias="outboundRule")] = None
    """
    The outbound access rule block for the Firewall.
    The outbound_rule block is documented below.
    """
    tags: Optional[List[str]] = None
    """
    The names of the Tags assigned to the Firewall.
    """


class FirewallSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["FirewallSpec"]:
            return FirewallSpec

        def build(self) -> "FirewallSpec":
            return FirewallSpec(**self._attrs)

        def deletion_policy(self, value: Optional[Literal["Orphan", "Delete"]], /) -> Self:
            """
            DeletionPolicy specifies what will happen to the underlying external
            when this managed resource is deleted - either "Delete" or "Orphan" the
            external resource.
            This field is planned to be deprecated in favor of the ManagementPolicies
            field in a future release. Currently, both could be set independently and
            non-default values would be honored if the feature flag is enabled.
            See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
            """
            return self._set("deletion_policy", value)

        @overload
        def for_provider(
            self, value_or_callback: ForProviderModel, /
        ) -> "FirewallSpec.Builder": ...

        @overload
        def for_provider(
            self,
            value_or_callback: Callable[
                [ForProviderModel.Builder], ForProviderModel.Builder | ForProviderModel
            ],
            /,
        ) -> "FirewallSpec.Builder": ...

        @overload
        def for_provider(
            self, value_or_callback: Never = ...
        ) -> "ForProviderModel.BuilderContext": ...

        def for_provider(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ForProviderModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "for_provider"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ForProviderModel.builder())
                if isinstance(output, ForProviderModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("for_provider", value)

        @overload
        def init_provider(
            self, value_or_callback: Optional[InitProviderModel], /
        ) -> "FirewallSpec.Builder": ...

        @overload
        def init_provider(
            self,
            value_or_callback: Callable[
                [InitProviderModel.Builder],
                InitProviderModel.Builder | InitProviderModel,
            ],
            /,
        ) -> "FirewallSpec.Builder": ...

        @overload
        def init_provider(
            self, value_or_callback: Never = ...
        ) -> "InitProviderModel.BuilderContext": ...

        def init_provider(self, value_or_callback=None, /):
            """
            THIS IS A BETA FIELD. It will be honored
            unless the Management Policies feature flag is disabled.
            InitProvider holds the same fields as ForProvider, with the exception
            of Identifier and other resource reference fields. The fields that are
            in InitProvider are merged into ForProvider when the resource is created.
            The same fields are also added to the terraform ignore_changes hook, to
            avoid updating them after creation. This is useful for fields that are
            required on creation, but we do not desire to update them after creation,
            for example because of an external controller is managing them, like an
            autoscaler.
            """
            if self._in_context and value_or_callback is None:
                context = InitProviderModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "init_provider"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(InitProviderModel.builder())
                if isinstance(output, InitProviderModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("init_provider", value)

        def management_policies(
            self,
            value: Optional[
                List[Literal["Observe", "Create", "Update", "Delete", "LateInitialize", "*"]]
            ],
            /,
        ) -> Self:
            """
            THIS IS A BETA FIELD. It is on by default but can be opted out
            through a Crossplane feature flag.
            ManagementPolicies specify the array of actions Crossplane is allowed to
            take on the managed and external resources.
            This field is planned to replace the DeletionPolicy field in a future
            release. Currently, both could be set independently and non-default
            values would be honored if the feature flag is enabled. If both are
            custom, the DeletionPolicy field will be ignored.
            See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
            and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
            """
            return self._set("management_policies", value)

        @overload
        def provider_config_ref(
            self, value_or_callback: Optional[ProviderConfigRef], /
        ) -> "FirewallSpec.Builder": ...

        @overload
        def provider_config_ref(
            self,
            value_or_callback: Callable[
                [ProviderConfigRef.Builder],
                ProviderConfigRef.Builder | ProviderConfigRef,
            ],
            /,
        ) -> "FirewallSpec.Builder": ...

        @overload
        def provider_config_ref(
            self, value_or_callback: Never = ...
        ) -> "ProviderConfigRef.BuilderContext": ...

        def provider_config_ref(self, value_or_callback=None, /):
            """
            ProviderConfigReference specifies how the provider that will be used to
            create, observe, update, and delete this managed resource should be
            configured.
            """
            if self._in_context and value_or_callback is None:
                context = ProviderConfigRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "provider_config_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ProviderConfigRef.builder())
                if isinstance(output, ProviderConfigRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("provider_config_ref", value)

        @overload
        def publish_connection_details_to(
            self, value_or_callback: Optional[PublishConnectionDetailsTo], /
        ) -> "FirewallSpec.Builder": ...

        @overload
        def publish_connection_details_to(
            self,
            value_or_callback: Callable[
                [PublishConnectionDetailsTo.Builder],
                PublishConnectionDetailsTo.Builder | PublishConnectionDetailsTo,
            ],
            /,
        ) -> "FirewallSpec.Builder": ...

        @overload
        def publish_connection_details_to(
            self, value_or_callback: Never = ...
        ) -> "PublishConnectionDetailsTo.BuilderContext": ...

        def publish_connection_details_to(self, value_or_callback=None, /):
            """
            PublishConnectionDetailsTo specifies the connection secret config which
            contains a name, metadata and a reference to secret store config to
            which any connection details for this managed resource should be written.
            Connection details frequently include the endpoint, username,
            and password required to connect to the managed resource.
            """
            if self._in_context and value_or_callback is None:
                context = PublishConnectionDetailsTo.BuilderContext()
                context._parent_builder = self
                context._field_name = "publish_connection_details_to"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PublishConnectionDetailsTo.builder())
                if isinstance(output, PublishConnectionDetailsTo.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("publish_connection_details_to", value)

        @overload
        def write_connection_secret_to_ref(
            self, value_or_callback: Optional[WriteConnectionSecretToRef], /
        ) -> "FirewallSpec.Builder": ...

        @overload
        def write_connection_secret_to_ref(
            self,
            value_or_callback: Callable[
                [WriteConnectionSecretToRef.Builder],
                WriteConnectionSecretToRef.Builder | WriteConnectionSecretToRef,
            ],
            /,
        ) -> "FirewallSpec.Builder": ...

        @overload
        def write_connection_secret_to_ref(
            self, value_or_callback: Never = ...
        ) -> "WriteConnectionSecretToRef.BuilderContext": ...

        def write_connection_secret_to_ref(self, value_or_callback=None, /):
            """
            WriteConnectionSecretToReference specifies the namespace and name of a
            Secret to which any connection details for this managed resource should
            be written. Connection details frequently include the endpoint, username,
            and password required to connect to the managed resource.
            This field is planned to be replaced in a future release in favor of
            PublishConnectionDetailsTo. Currently, both could be set independently
            and connection details would be published to both without affecting
            each other.
            """
            if self._in_context and value_or_callback is None:
                context = WriteConnectionSecretToRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "write_connection_secret_to_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(WriteConnectionSecretToRef.builder())
                if isinstance(output, WriteConnectionSecretToRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("write_connection_secret_to_ref", value)

    class BuilderContext(BuilderContextBase["FirewallSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = FirewallSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for FirewallSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["FirewallSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use FirewallSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    deletion_policy: Annotated[
        Optional[Literal["Orphan", "Delete"]], Field(alias="deletionPolicy")
    ] = "Delete"
    """
    DeletionPolicy specifies what will happen to the underlying external
    when this managed resource is deleted - either "Delete" or "Orphan" the
    external resource.
    This field is planned to be deprecated in favor of the ManagementPolicies
    field in a future release. Currently, both could be set independently and
    non-default values would be honored if the feature flag is enabled.
    See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    """
    for_provider: Annotated[ForProviderModel, Field(alias="forProvider")]
    init_provider: Annotated[Optional[InitProviderModel], Field(alias="initProvider")] = None
    """
    THIS IS A BETA FIELD. It will be honored
    unless the Management Policies feature flag is disabled.
    InitProvider holds the same fields as ForProvider, with the exception
    of Identifier and other resource reference fields. The fields that are
    in InitProvider are merged into ForProvider when the resource is created.
    The same fields are also added to the terraform ignore_changes hook, to
    avoid updating them after creation. This is useful for fields that are
    required on creation, but we do not desire to update them after creation,
    for example because of an external controller is managing them, like an
    autoscaler.
    """
    management_policies: Annotated[
        Optional[List[Literal["Observe", "Create", "Update", "Delete", "LateInitialize", "*"]]],
        Field(alias="managementPolicies"),
    ] = ["*"]
    """
    THIS IS A BETA FIELD. It is on by default but can be opted out
    through a Crossplane feature flag.
    ManagementPolicies specify the array of actions Crossplane is allowed to
    take on the managed and external resources.
    This field is planned to replace the DeletionPolicy field in a future
    release. Currently, both could be set independently and non-default
    values would be honored if the feature flag is enabled. If both are
    custom, the DeletionPolicy field will be ignored.
    See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
    """
    provider_config_ref: Annotated[
        Optional[ProviderConfigRef],
        Field(
            default_factory=lambda: ProviderConfigRef.model_validate({"name": "default"}),
            alias="providerConfigRef",
        ),
    ] = {"name": "default"}
    """
    ProviderConfigReference specifies how the provider that will be used to
    create, observe, update, and delete this managed resource should be
    configured.
    """
    publish_connection_details_to: Annotated[
        Optional[PublishConnectionDetailsTo], Field(alias="publishConnectionDetailsTo")
    ] = None
    """
    PublishConnectionDetailsTo specifies the connection secret config which
    contains a name, metadata and a reference to secret store config to
    which any connection details for this managed resource should be written.
    Connection details frequently include the endpoint, username,
    and password required to connect to the managed resource.
    """
    write_connection_secret_to_ref: Annotated[
        Optional[WriteConnectionSecretToRef], Field(alias="writeConnectionSecretToRef")
    ] = None
    """
    WriteConnectionSecretToReference specifies the namespace and name of a
    Secret to which any connection details for this managed resource should
    be written. Connection details frequently include the endpoint, username,
    and password required to connect to the managed resource.
    This field is planned to be replaced in a future release in favor of
    PublishConnectionDetailsTo. Currently, both could be set independently
    and connection details would be published to both without affecting
    each other.
    """


class PendingChange(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PendingChange"]:
            return PendingChange

        def build(self) -> "PendingChange":
            return PendingChange(**self._attrs)

        def droplet_id(self, value: Optional[float], /) -> Self:
            """
            A unique ID that can be used to identify and reference a Firewall.
            """
            return self._set("droplet_id", value)

        def removing(self, value: Optional[bool], /) -> Self:
            return self._set("removing", value)

        def status(self, value: Optional[str], /) -> Self:
            """
            A status string indicating the current state of the Firewall.
            This can be "waiting", "succeeded", or "failed".
            """
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["PendingChange.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PendingChange.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PendingChange."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["PendingChange", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PendingChange.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    droplet_id: Annotated[Optional[float], Field(alias="dropletId")] = None
    """
    A unique ID that can be used to identify and reference a Firewall.
    """
    removing: Optional[bool] = None
    status: Optional[str] = None
    """
    A status string indicating the current state of the Firewall.
    This can be "waiting", "succeeded", or "failed".
    """


class AtProviderModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AtProviderModel"]:
            return AtProviderModel

        def build(self) -> "AtProviderModel":
            return AtProviderModel(**self._attrs)

        def created_at(self, value: Optional[str], /) -> Self:
            """
            A time value given in ISO8601 combined date and time format
            that represents when the Firewall was created.
            """
            return self._set("created_at", value)

        def droplet_ids(self, value: Optional[List[float]], /) -> Self:
            """
            The list of the IDs of the Droplets assigned
            to the Firewall.
            """
            return self._set("droplet_ids", value)

        def id(self, value: Optional[str], /) -> Self:
            """
            A unique ID that can be used to identify and reference a Firewall.
            """
            return self._set("id", value)

        @overload
        def inbound_rule(
            self, value_or_callback: List[InboundRule], /
        ) -> "AtProviderModel.Builder": ...

        @overload
        def inbound_rule(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[InboundRule, InboundRule.Builder]],
                GenericListBuilder[InboundRule, InboundRule.Builder] | List[InboundRule],
            ],
            /,
        ) -> "AtProviderModel.Builder": ...

        @overload
        def inbound_rule(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[InboundRule.Builder]: ...

        def inbound_rule(self, value_or_callback=None, /):
            """
            The inbound access rule block for the Firewall.
            The inbound_rule block is documented below.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[InboundRule.Builder]()
                context._parent_builder = self
                context._field_name = "inbound_rule"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(InboundRule.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("inbound_rule", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            The Firewall name
            """
            return self._set("name", value)

        @overload
        def outbound_rule(
            self, value_or_callback: List[OutboundRule], /
        ) -> "AtProviderModel.Builder": ...

        @overload
        def outbound_rule(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[OutboundRule, OutboundRule.Builder]],
                GenericListBuilder[OutboundRule, OutboundRule.Builder] | List[OutboundRule],
            ],
            /,
        ) -> "AtProviderModel.Builder": ...

        @overload
        def outbound_rule(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[OutboundRule.Builder]: ...

        def outbound_rule(self, value_or_callback=None, /):
            """
            The outbound access rule block for the Firewall.
            The outbound_rule block is documented below.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[OutboundRule.Builder]()
                context._parent_builder = self
                context._field_name = "outbound_rule"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(OutboundRule.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("outbound_rule", value)

        @overload
        def pending_changes(
            self, value_or_callback: List[PendingChange], /
        ) -> "AtProviderModel.Builder": ...

        @overload
        def pending_changes(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[PendingChange, PendingChange.Builder]],
                GenericListBuilder[PendingChange, PendingChange.Builder] | List[PendingChange],
            ],
            /,
        ) -> "AtProviderModel.Builder": ...

        @overload
        def pending_changes(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[PendingChange.Builder]: ...

        def pending_changes(self, value_or_callback=None, /):
            """
            An list of object containing the fields, "droplet_id",
            "removing", and "status".  It is provided to detail exactly which Droplets
            are having their security policies updated.  When empty, all changes
            have been successfully applied.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[PendingChange.Builder]()
                context._parent_builder = self
                context._field_name = "pending_changes"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PendingChange.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("pending_changes", value)

        def status(self, value: Optional[str], /) -> Self:
            """
            A status string indicating the current state of the Firewall.
            This can be "waiting", "succeeded", or "failed".
            """
            return self._set("status", value)

        def tags(self, value: Optional[List[str]], /) -> Self:
            """
            The names of the Tags assigned to the Firewall.
            """
            return self._set("tags", value)

    class BuilderContext(BuilderContextBase["AtProviderModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AtProviderModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AtProviderModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AtProviderModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AtProviderModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    created_at: Annotated[Optional[str], Field(alias="createdAt")] = None
    """
    A time value given in ISO8601 combined date and time format
    that represents when the Firewall was created.
    """
    droplet_ids: Annotated[Optional[List[float]], Field(alias="dropletIds")] = None
    """
    The list of the IDs of the Droplets assigned
    to the Firewall.
    """
    id: Optional[str] = None
    """
    A unique ID that can be used to identify and reference a Firewall.
    """
    inbound_rule: Annotated[Optional[List[InboundRule]], Field(alias="inboundRule")] = None
    """
    The inbound access rule block for the Firewall.
    The inbound_rule block is documented below.
    """
    name: Optional[str] = None
    """
    The Firewall name
    """
    outbound_rule: Annotated[Optional[List[OutboundRule]], Field(alias="outboundRule")] = None
    """
    The outbound access rule block for the Firewall.
    The outbound_rule block is documented below.
    """
    pending_changes: Annotated[Optional[List[PendingChange]], Field(alias="pendingChanges")] = None
    """
    An list of object containing the fields, "droplet_id",
    "removing", and "status".  It is provided to detail exactly which Droplets
    are having their security policies updated.  When empty, all changes
    have been successfully applied.
    """
    status: Optional[str] = None
    """
    A status string indicating the current state of the Firewall.
    This can be "waiting", "succeeded", or "failed".
    """
    tags: Optional[List[str]] = None
    """
    The names of the Tags assigned to the Firewall.
    """


class FirewallStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["FirewallStatus"]:
            return FirewallStatus

        def build(self) -> "FirewallStatus":
            return FirewallStatus(**self._attrs)

        @overload
        def at_provider(
            self, value_or_callback: Optional[AtProviderModel], /
        ) -> "FirewallStatus.Builder": ...

        @overload
        def at_provider(
            self,
            value_or_callback: Callable[
                [AtProviderModel.Builder], AtProviderModel.Builder | AtProviderModel
            ],
            /,
        ) -> "FirewallStatus.Builder": ...

        @overload
        def at_provider(
            self, value_or_callback: Never = ...
        ) -> "AtProviderModel.BuilderContext": ...

        def at_provider(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = AtProviderModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "at_provider"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AtProviderModel.builder())
                if isinstance(output, AtProviderModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("at_provider", value)

        @overload
        def conditions(self, value_or_callback: List[Condition], /) -> "FirewallStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Condition, Condition.Builder]],
                GenericListBuilder[Condition, Condition.Builder] | List[Condition],
            ],
            /,
        ) -> "FirewallStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            """
            Conditions of the resource.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        def observed_generation(self, value: Optional[int], /) -> Self:
            """
            ObservedGeneration is the latest metadata.generation
            which resulted in either a ready state, or stalled due to error
            it can not recover from without human intervention.
            """
            return self._set("observed_generation", value)

    class BuilderContext(BuilderContextBase["FirewallStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = FirewallStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for FirewallStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["FirewallStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use FirewallStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    at_provider: Annotated[Optional[AtProviderModel], Field(alias="atProvider")] = None
    conditions: Optional[List[Condition]] = None
    """
    Conditions of the resource.
    """
    observed_generation: Annotated[Optional[int], Field(alias="observedGeneration")] = None
    """
    ObservedGeneration is the latest metadata.generation
    which resulted in either a ready state, or stalled due to error
    it can not recover from without human intervention.
    """


class DropletIdRef(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["DropletIdRef"]:
            return DropletIdRef

        def build(self) -> "DropletIdRef":
            return DropletIdRef(**self._attrs)

        def name(self, value: str, /) -> Self:
            """
            Name of the referenced object.
            """
            return self._set("name", value)

        @overload
        def policy(self, value_or_callback: Optional[Policy], /) -> "DropletIdRef.Builder": ...

        @overload
        def policy(
            self,
            value_or_callback: Callable[[Policy.Builder], Policy.Builder | Policy],
            /,
        ) -> "DropletIdRef.Builder": ...

        @overload
        def policy(self, value_or_callback: Never = ...) -> "Policy.BuilderContext": ...

        def policy(self, value_or_callback=None, /):
            """
            Policies for referencing.
            """
            if self._in_context and value_or_callback is None:
                context = Policy.BuilderContext()
                context._parent_builder = self
                context._field_name = "policy"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Policy.builder())
                if isinstance(output, Policy.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("policy", value)

    class BuilderContext(BuilderContextBase["DropletIdRef.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DropletIdRef.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DropletIdRef."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["DropletIdRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use DropletIdRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: str
    """
    Name of the referenced object.
    """
    policy: Optional[Policy] = None
    """
    Policies for referencing.
    """


class DropletIdSelector(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["DropletIdSelector"]:
            return DropletIdSelector

        def build(self) -> "DropletIdSelector":
            return DropletIdSelector(**self._attrs)

        def match_controller_ref(self, value: Optional[bool], /) -> Self:
            """
            MatchControllerRef ensures an object with the same controller reference
            as the selecting object is selected.
            """
            return self._set("match_controller_ref", value)

        def match_labels(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            MatchLabels ensures an object with matching labels is selected.
            """
            return self._set("match_labels", value)

        @overload
        def policy(self, value_or_callback: Optional[Policy], /) -> "DropletIdSelector.Builder": ...

        @overload
        def policy(
            self,
            value_or_callback: Callable[[Policy.Builder], Policy.Builder | Policy],
            /,
        ) -> "DropletIdSelector.Builder": ...

        @overload
        def policy(self, value_or_callback: Never = ...) -> "Policy.BuilderContext": ...

        def policy(self, value_or_callback=None, /):
            """
            Policies for selection.
            """
            if self._in_context and value_or_callback is None:
                context = Policy.BuilderContext()
                context._parent_builder = self
                context._field_name = "policy"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Policy.builder())
                if isinstance(output, Policy.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("policy", value)

    class BuilderContext(BuilderContextBase["DropletIdSelector.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DropletIdSelector.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DropletIdSelector."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["DropletIdSelector", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use DropletIdSelector.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    match_controller_ref: Annotated[Optional[bool], Field(alias="matchControllerRef")] = None
    """
    MatchControllerRef ensures an object with the same controller reference
    as the selecting object is selected.
    """
    match_labels: Annotated[Optional[Dict[str, str]], Field(alias="matchLabels")] = None
    """
    MatchLabels ensures an object with matching labels is selected.
    """
    policy: Optional[Policy] = None
    """
    Policies for selection.
    """


class IpAddressRef(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["IpAddressRef"]:
            return IpAddressRef

        def build(self) -> "IpAddressRef":
            return IpAddressRef(**self._attrs)

        def name(self, value: str, /) -> Self:
            """
            Name of the referenced object.
            """
            return self._set("name", value)

        @overload
        def policy(self, value_or_callback: Optional[Policy], /) -> "IpAddressRef.Builder": ...

        @overload
        def policy(
            self,
            value_or_callback: Callable[[Policy.Builder], Policy.Builder | Policy],
            /,
        ) -> "IpAddressRef.Builder": ...

        @overload
        def policy(self, value_or_callback: Never = ...) -> "Policy.BuilderContext": ...

        def policy(self, value_or_callback=None, /):
            """
            Policies for referencing.
            """
            if self._in_context and value_or_callback is None:
                context = Policy.BuilderContext()
                context._parent_builder = self
                context._field_name = "policy"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Policy.builder())
                if isinstance(output, Policy.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("policy", value)

    class BuilderContext(BuilderContextBase["IpAddressRef.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = IpAddressRef.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for IpAddressRef."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["IpAddressRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use IpAddressRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: str
    """
    Name of the referenced object.
    """
    policy: Optional[Policy] = None
    """
    Policies for referencing.
    """


class IpAddressSelector(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["IpAddressSelector"]:
            return IpAddressSelector

        def build(self) -> "IpAddressSelector":
            return IpAddressSelector(**self._attrs)

        def match_controller_ref(self, value: Optional[bool], /) -> Self:
            """
            MatchControllerRef ensures an object with the same controller reference
            as the selecting object is selected.
            """
            return self._set("match_controller_ref", value)

        def match_labels(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            MatchLabels ensures an object with matching labels is selected.
            """
            return self._set("match_labels", value)

        @overload
        def policy(self, value_or_callback: Optional[Policy], /) -> "IpAddressSelector.Builder": ...

        @overload
        def policy(
            self,
            value_or_callback: Callable[[Policy.Builder], Policy.Builder | Policy],
            /,
        ) -> "IpAddressSelector.Builder": ...

        @overload
        def policy(self, value_or_callback: Never = ...) -> "Policy.BuilderContext": ...

        def policy(self, value_or_callback=None, /):
            """
            Policies for selection.
            """
            if self._in_context and value_or_callback is None:
                context = Policy.BuilderContext()
                context._parent_builder = self
                context._field_name = "policy"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Policy.builder())
                if isinstance(output, Policy.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("policy", value)

    class BuilderContext(BuilderContextBase["IpAddressSelector.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = IpAddressSelector.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for IpAddressSelector."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["IpAddressSelector", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use IpAddressSelector.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    match_controller_ref: Annotated[Optional[bool], Field(alias="matchControllerRef")] = None
    """
    MatchControllerRef ensures an object with the same controller reference
    as the selecting object is selected.
    """
    match_labels: Annotated[Optional[Dict[str, str]], Field(alias="matchLabels")] = None
    """
    MatchLabels ensures an object with matching labels is selected.
    """
    policy: Optional[Policy] = None
    """
    Policies for selection.
    """


class ForProviderModel1(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ForProviderModel1"]:
            return ForProviderModel1

        def build(self) -> "ForProviderModel1":
            return ForProviderModel1(**self._attrs)

        def droplet_id(self, value: Optional[float], /) -> Self:
            """
            The ID of Droplet that the reserved IP will be assigned to.
            """
            return self._set("droplet_id", value)

        @overload
        def droplet_id_ref(
            self, value_or_callback: Optional[DropletIdRef], /
        ) -> "ForProviderModel1.Builder": ...

        @overload
        def droplet_id_ref(
            self,
            value_or_callback: Callable[
                [DropletIdRef.Builder], DropletIdRef.Builder | DropletIdRef
            ],
            /,
        ) -> "ForProviderModel1.Builder": ...

        @overload
        def droplet_id_ref(
            self, value_or_callback: Never = ...
        ) -> "DropletIdRef.BuilderContext": ...

        def droplet_id_ref(self, value_or_callback=None, /):
            """
            Reference to a Droplet in droplet to populate dropletId.
            """
            if self._in_context and value_or_callback is None:
                context = DropletIdRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "droplet_id_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(DropletIdRef.builder())
                if isinstance(output, DropletIdRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("droplet_id_ref", value)

        @overload
        def droplet_id_selector(
            self, value_or_callback: Optional[DropletIdSelector], /
        ) -> "ForProviderModel1.Builder": ...

        @overload
        def droplet_id_selector(
            self,
            value_or_callback: Callable[
                [DropletIdSelector.Builder],
                DropletIdSelector.Builder | DropletIdSelector,
            ],
            /,
        ) -> "ForProviderModel1.Builder": ...

        @overload
        def droplet_id_selector(
            self, value_or_callback: Never = ...
        ) -> "DropletIdSelector.BuilderContext": ...

        def droplet_id_selector(self, value_or_callback=None, /):
            """
            Selector for a Droplet in droplet to populate dropletId.
            """
            if self._in_context and value_or_callback is None:
                context = DropletIdSelector.BuilderContext()
                context._parent_builder = self
                context._field_name = "droplet_id_selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(DropletIdSelector.builder())
                if isinstance(output, DropletIdSelector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("droplet_id_selector", value)

        def ip_address(self, value: Optional[str], /) -> Self:
            """
            The reserved IP to assign to the Droplet.
            """
            return self._set("ip_address", value)

        @overload
        def ip_address_ref(
            self, value_or_callback: Optional[IpAddressRef], /
        ) -> "ForProviderModel1.Builder": ...

        @overload
        def ip_address_ref(
            self,
            value_or_callback: Callable[
                [IpAddressRef.Builder], IpAddressRef.Builder | IpAddressRef
            ],
            /,
        ) -> "ForProviderModel1.Builder": ...

        @overload
        def ip_address_ref(
            self, value_or_callback: Never = ...
        ) -> "IpAddressRef.BuilderContext": ...

        def ip_address_ref(self, value_or_callback=None, /):
            """
            Reference to a IP in networking to populate ipAddress.
            """
            if self._in_context and value_or_callback is None:
                context = IpAddressRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "ip_address_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(IpAddressRef.builder())
                if isinstance(output, IpAddressRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("ip_address_ref", value)

        @overload
        def ip_address_selector(
            self, value_or_callback: Optional[IpAddressSelector], /
        ) -> "ForProviderModel1.Builder": ...

        @overload
        def ip_address_selector(
            self,
            value_or_callback: Callable[
                [IpAddressSelector.Builder],
                IpAddressSelector.Builder | IpAddressSelector,
            ],
            /,
        ) -> "ForProviderModel1.Builder": ...

        @overload
        def ip_address_selector(
            self, value_or_callback: Never = ...
        ) -> "IpAddressSelector.BuilderContext": ...

        def ip_address_selector(self, value_or_callback=None, /):
            """
            Selector for a IP in networking to populate ipAddress.
            """
            if self._in_context and value_or_callback is None:
                context = IpAddressSelector.BuilderContext()
                context._parent_builder = self
                context._field_name = "ip_address_selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(IpAddressSelector.builder())
                if isinstance(output, IpAddressSelector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("ip_address_selector", value)

    class BuilderContext(BuilderContextBase["ForProviderModel1.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ForProviderModel1.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ForProviderModel1."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ForProviderModel1", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ForProviderModel1.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    droplet_id: Annotated[Optional[float], Field(alias="dropletId")] = None
    """
    The ID of Droplet that the reserved IP will be assigned to.
    """
    droplet_id_ref: Annotated[Optional[DropletIdRef], Field(alias="dropletIdRef")] = None
    """
    Reference to a Droplet in droplet to populate dropletId.
    """
    droplet_id_selector: Annotated[
        Optional[DropletIdSelector], Field(alias="dropletIdSelector")
    ] = None
    """
    Selector for a Droplet in droplet to populate dropletId.
    """
    ip_address: Annotated[Optional[str], Field(alias="ipAddress")] = None
    """
    The reserved IP to assign to the Droplet.
    """
    ip_address_ref: Annotated[Optional[IpAddressRef], Field(alias="ipAddressRef")] = None
    """
    Reference to a IP in networking to populate ipAddress.
    """
    ip_address_selector: Annotated[
        Optional[IpAddressSelector], Field(alias="ipAddressSelector")
    ] = None
    """
    Selector for a IP in networking to populate ipAddress.
    """


class InitProviderModel1(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["InitProviderModel1"]:
            return InitProviderModel1

        def build(self) -> "InitProviderModel1":
            return InitProviderModel1(**self._attrs)

        def droplet_id(self, value: Optional[float], /) -> Self:
            """
            The ID of Droplet that the reserved IP will be assigned to.
            """
            return self._set("droplet_id", value)

        @overload
        def droplet_id_ref(
            self, value_or_callback: Optional[DropletIdRef], /
        ) -> "InitProviderModel1.Builder": ...

        @overload
        def droplet_id_ref(
            self,
            value_or_callback: Callable[
                [DropletIdRef.Builder], DropletIdRef.Builder | DropletIdRef
            ],
            /,
        ) -> "InitProviderModel1.Builder": ...

        @overload
        def droplet_id_ref(
            self, value_or_callback: Never = ...
        ) -> "DropletIdRef.BuilderContext": ...

        def droplet_id_ref(self, value_or_callback=None, /):
            """
            Reference to a Droplet in droplet to populate dropletId.
            """
            if self._in_context and value_or_callback is None:
                context = DropletIdRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "droplet_id_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(DropletIdRef.builder())
                if isinstance(output, DropletIdRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("droplet_id_ref", value)

        @overload
        def droplet_id_selector(
            self, value_or_callback: Optional[DropletIdSelector], /
        ) -> "InitProviderModel1.Builder": ...

        @overload
        def droplet_id_selector(
            self,
            value_or_callback: Callable[
                [DropletIdSelector.Builder],
                DropletIdSelector.Builder | DropletIdSelector,
            ],
            /,
        ) -> "InitProviderModel1.Builder": ...

        @overload
        def droplet_id_selector(
            self, value_or_callback: Never = ...
        ) -> "DropletIdSelector.BuilderContext": ...

        def droplet_id_selector(self, value_or_callback=None, /):
            """
            Selector for a Droplet in droplet to populate dropletId.
            """
            if self._in_context and value_or_callback is None:
                context = DropletIdSelector.BuilderContext()
                context._parent_builder = self
                context._field_name = "droplet_id_selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(DropletIdSelector.builder())
                if isinstance(output, DropletIdSelector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("droplet_id_selector", value)

        def ip_address(self, value: Optional[str], /) -> Self:
            """
            The reserved IP to assign to the Droplet.
            """
            return self._set("ip_address", value)

        @overload
        def ip_address_ref(
            self, value_or_callback: Optional[IpAddressRef], /
        ) -> "InitProviderModel1.Builder": ...

        @overload
        def ip_address_ref(
            self,
            value_or_callback: Callable[
                [IpAddressRef.Builder], IpAddressRef.Builder | IpAddressRef
            ],
            /,
        ) -> "InitProviderModel1.Builder": ...

        @overload
        def ip_address_ref(
            self, value_or_callback: Never = ...
        ) -> "IpAddressRef.BuilderContext": ...

        def ip_address_ref(self, value_or_callback=None, /):
            """
            Reference to a IP in networking to populate ipAddress.
            """
            if self._in_context and value_or_callback is None:
                context = IpAddressRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "ip_address_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(IpAddressRef.builder())
                if isinstance(output, IpAddressRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("ip_address_ref", value)

        @overload
        def ip_address_selector(
            self, value_or_callback: Optional[IpAddressSelector], /
        ) -> "InitProviderModel1.Builder": ...

        @overload
        def ip_address_selector(
            self,
            value_or_callback: Callable[
                [IpAddressSelector.Builder],
                IpAddressSelector.Builder | IpAddressSelector,
            ],
            /,
        ) -> "InitProviderModel1.Builder": ...

        @overload
        def ip_address_selector(
            self, value_or_callback: Never = ...
        ) -> "IpAddressSelector.BuilderContext": ...

        def ip_address_selector(self, value_or_callback=None, /):
            """
            Selector for a IP in networking to populate ipAddress.
            """
            if self._in_context and value_or_callback is None:
                context = IpAddressSelector.BuilderContext()
                context._parent_builder = self
                context._field_name = "ip_address_selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(IpAddressSelector.builder())
                if isinstance(output, IpAddressSelector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("ip_address_selector", value)

    class BuilderContext(BuilderContextBase["InitProviderModel1.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = InitProviderModel1.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for InitProviderModel1."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["InitProviderModel1", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use InitProviderModel1.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    droplet_id: Annotated[Optional[float], Field(alias="dropletId")] = None
    """
    The ID of Droplet that the reserved IP will be assigned to.
    """
    droplet_id_ref: Annotated[Optional[DropletIdRef], Field(alias="dropletIdRef")] = None
    """
    Reference to a Droplet in droplet to populate dropletId.
    """
    droplet_id_selector: Annotated[
        Optional[DropletIdSelector], Field(alias="dropletIdSelector")
    ] = None
    """
    Selector for a Droplet in droplet to populate dropletId.
    """
    ip_address: Annotated[Optional[str], Field(alias="ipAddress")] = None
    """
    The reserved IP to assign to the Droplet.
    """
    ip_address_ref: Annotated[Optional[IpAddressRef], Field(alias="ipAddressRef")] = None
    """
    Reference to a IP in networking to populate ipAddress.
    """
    ip_address_selector: Annotated[
        Optional[IpAddressSelector], Field(alias="ipAddressSelector")
    ] = None
    """
    Selector for a IP in networking to populate ipAddress.
    """


class IPAssignmentSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["IPAssignmentSpec"]:
            return IPAssignmentSpec

        def build(self) -> "IPAssignmentSpec":
            return IPAssignmentSpec(**self._attrs)

        def deletion_policy(self, value: Optional[Literal["Orphan", "Delete"]], /) -> Self:
            """
            DeletionPolicy specifies what will happen to the underlying external
            when this managed resource is deleted - either "Delete" or "Orphan" the
            external resource.
            This field is planned to be deprecated in favor of the ManagementPolicies
            field in a future release. Currently, both could be set independently and
            non-default values would be honored if the feature flag is enabled.
            See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
            """
            return self._set("deletion_policy", value)

        @overload
        def for_provider(
            self, value_or_callback: ForProviderModel1, /
        ) -> "IPAssignmentSpec.Builder": ...

        @overload
        def for_provider(
            self,
            value_or_callback: Callable[
                [ForProviderModel1.Builder],
                ForProviderModel1.Builder | ForProviderModel1,
            ],
            /,
        ) -> "IPAssignmentSpec.Builder": ...

        @overload
        def for_provider(
            self, value_or_callback: Never = ...
        ) -> "ForProviderModel1.BuilderContext": ...

        def for_provider(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ForProviderModel1.BuilderContext()
                context._parent_builder = self
                context._field_name = "for_provider"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ForProviderModel1.builder())
                if isinstance(output, ForProviderModel1.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("for_provider", value)

        @overload
        def init_provider(
            self, value_or_callback: Optional[InitProviderModel1], /
        ) -> "IPAssignmentSpec.Builder": ...

        @overload
        def init_provider(
            self,
            value_or_callback: Callable[
                [InitProviderModel1.Builder],
                InitProviderModel1.Builder | InitProviderModel1,
            ],
            /,
        ) -> "IPAssignmentSpec.Builder": ...

        @overload
        def init_provider(
            self, value_or_callback: Never = ...
        ) -> "InitProviderModel1.BuilderContext": ...

        def init_provider(self, value_or_callback=None, /):
            """
            THIS IS A BETA FIELD. It will be honored
            unless the Management Policies feature flag is disabled.
            InitProvider holds the same fields as ForProvider, with the exception
            of Identifier and other resource reference fields. The fields that are
            in InitProvider are merged into ForProvider when the resource is created.
            The same fields are also added to the terraform ignore_changes hook, to
            avoid updating them after creation. This is useful for fields that are
            required on creation, but we do not desire to update them after creation,
            for example because of an external controller is managing them, like an
            autoscaler.
            """
            if self._in_context and value_or_callback is None:
                context = InitProviderModel1.BuilderContext()
                context._parent_builder = self
                context._field_name = "init_provider"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(InitProviderModel1.builder())
                if isinstance(output, InitProviderModel1.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("init_provider", value)

        def management_policies(
            self,
            value: Optional[
                List[Literal["Observe", "Create", "Update", "Delete", "LateInitialize", "*"]]
            ],
            /,
        ) -> Self:
            """
            THIS IS A BETA FIELD. It is on by default but can be opted out
            through a Crossplane feature flag.
            ManagementPolicies specify the array of actions Crossplane is allowed to
            take on the managed and external resources.
            This field is planned to replace the DeletionPolicy field in a future
            release. Currently, both could be set independently and non-default
            values would be honored if the feature flag is enabled. If both are
            custom, the DeletionPolicy field will be ignored.
            See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
            and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
            """
            return self._set("management_policies", value)

        @overload
        def provider_config_ref(
            self, value_or_callback: Optional[ProviderConfigRef], /
        ) -> "IPAssignmentSpec.Builder": ...

        @overload
        def provider_config_ref(
            self,
            value_or_callback: Callable[
                [ProviderConfigRef.Builder],
                ProviderConfigRef.Builder | ProviderConfigRef,
            ],
            /,
        ) -> "IPAssignmentSpec.Builder": ...

        @overload
        def provider_config_ref(
            self, value_or_callback: Never = ...
        ) -> "ProviderConfigRef.BuilderContext": ...

        def provider_config_ref(self, value_or_callback=None, /):
            """
            ProviderConfigReference specifies how the provider that will be used to
            create, observe, update, and delete this managed resource should be
            configured.
            """
            if self._in_context and value_or_callback is None:
                context = ProviderConfigRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "provider_config_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ProviderConfigRef.builder())
                if isinstance(output, ProviderConfigRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("provider_config_ref", value)

        @overload
        def publish_connection_details_to(
            self, value_or_callback: Optional[PublishConnectionDetailsTo], /
        ) -> "IPAssignmentSpec.Builder": ...

        @overload
        def publish_connection_details_to(
            self,
            value_or_callback: Callable[
                [PublishConnectionDetailsTo.Builder],
                PublishConnectionDetailsTo.Builder | PublishConnectionDetailsTo,
            ],
            /,
        ) -> "IPAssignmentSpec.Builder": ...

        @overload
        def publish_connection_details_to(
            self, value_or_callback: Never = ...
        ) -> "PublishConnectionDetailsTo.BuilderContext": ...

        def publish_connection_details_to(self, value_or_callback=None, /):
            """
            PublishConnectionDetailsTo specifies the connection secret config which
            contains a name, metadata and a reference to secret store config to
            which any connection details for this managed resource should be written.
            Connection details frequently include the endpoint, username,
            and password required to connect to the managed resource.
            """
            if self._in_context and value_or_callback is None:
                context = PublishConnectionDetailsTo.BuilderContext()
                context._parent_builder = self
                context._field_name = "publish_connection_details_to"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PublishConnectionDetailsTo.builder())
                if isinstance(output, PublishConnectionDetailsTo.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("publish_connection_details_to", value)

        @overload
        def write_connection_secret_to_ref(
            self, value_or_callback: Optional[WriteConnectionSecretToRef], /
        ) -> "IPAssignmentSpec.Builder": ...

        @overload
        def write_connection_secret_to_ref(
            self,
            value_or_callback: Callable[
                [WriteConnectionSecretToRef.Builder],
                WriteConnectionSecretToRef.Builder | WriteConnectionSecretToRef,
            ],
            /,
        ) -> "IPAssignmentSpec.Builder": ...

        @overload
        def write_connection_secret_to_ref(
            self, value_or_callback: Never = ...
        ) -> "WriteConnectionSecretToRef.BuilderContext": ...

        def write_connection_secret_to_ref(self, value_or_callback=None, /):
            """
            WriteConnectionSecretToReference specifies the namespace and name of a
            Secret to which any connection details for this managed resource should
            be written. Connection details frequently include the endpoint, username,
            and password required to connect to the managed resource.
            This field is planned to be replaced in a future release in favor of
            PublishConnectionDetailsTo. Currently, both could be set independently
            and connection details would be published to both without affecting
            each other.
            """
            if self._in_context and value_or_callback is None:
                context = WriteConnectionSecretToRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "write_connection_secret_to_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(WriteConnectionSecretToRef.builder())
                if isinstance(output, WriteConnectionSecretToRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("write_connection_secret_to_ref", value)

    class BuilderContext(BuilderContextBase["IPAssignmentSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = IPAssignmentSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for IPAssignmentSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["IPAssignmentSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use IPAssignmentSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    deletion_policy: Annotated[
        Optional[Literal["Orphan", "Delete"]], Field(alias="deletionPolicy")
    ] = "Delete"
    """
    DeletionPolicy specifies what will happen to the underlying external
    when this managed resource is deleted - either "Delete" or "Orphan" the
    external resource.
    This field is planned to be deprecated in favor of the ManagementPolicies
    field in a future release. Currently, both could be set independently and
    non-default values would be honored if the feature flag is enabled.
    See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    """
    for_provider: Annotated[ForProviderModel1, Field(alias="forProvider")]
    init_provider: Annotated[Optional[InitProviderModel1], Field(alias="initProvider")] = None
    """
    THIS IS A BETA FIELD. It will be honored
    unless the Management Policies feature flag is disabled.
    InitProvider holds the same fields as ForProvider, with the exception
    of Identifier and other resource reference fields. The fields that are
    in InitProvider are merged into ForProvider when the resource is created.
    The same fields are also added to the terraform ignore_changes hook, to
    avoid updating them after creation. This is useful for fields that are
    required on creation, but we do not desire to update them after creation,
    for example because of an external controller is managing them, like an
    autoscaler.
    """
    management_policies: Annotated[
        Optional[List[Literal["Observe", "Create", "Update", "Delete", "LateInitialize", "*"]]],
        Field(alias="managementPolicies"),
    ] = ["*"]
    """
    THIS IS A BETA FIELD. It is on by default but can be opted out
    through a Crossplane feature flag.
    ManagementPolicies specify the array of actions Crossplane is allowed to
    take on the managed and external resources.
    This field is planned to replace the DeletionPolicy field in a future
    release. Currently, both could be set independently and non-default
    values would be honored if the feature flag is enabled. If both are
    custom, the DeletionPolicy field will be ignored.
    See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
    """
    provider_config_ref: Annotated[
        Optional[ProviderConfigRef],
        Field(
            default_factory=lambda: ProviderConfigRef.model_validate({"name": "default"}),
            alias="providerConfigRef",
        ),
    ] = {"name": "default"}
    """
    ProviderConfigReference specifies how the provider that will be used to
    create, observe, update, and delete this managed resource should be
    configured.
    """
    publish_connection_details_to: Annotated[
        Optional[PublishConnectionDetailsTo], Field(alias="publishConnectionDetailsTo")
    ] = None
    """
    PublishConnectionDetailsTo specifies the connection secret config which
    contains a name, metadata and a reference to secret store config to
    which any connection details for this managed resource should be written.
    Connection details frequently include the endpoint, username,
    and password required to connect to the managed resource.
    """
    write_connection_secret_to_ref: Annotated[
        Optional[WriteConnectionSecretToRef], Field(alias="writeConnectionSecretToRef")
    ] = None
    """
    WriteConnectionSecretToReference specifies the namespace and name of a
    Secret to which any connection details for this managed resource should
    be written. Connection details frequently include the endpoint, username,
    and password required to connect to the managed resource.
    This field is planned to be replaced in a future release in favor of
    PublishConnectionDetailsTo. Currently, both could be set independently
    and connection details would be published to both without affecting
    each other.
    """


class AtProviderModel1(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AtProviderModel1"]:
            return AtProviderModel1

        def build(self) -> "AtProviderModel1":
            return AtProviderModel1(**self._attrs)

        def droplet_id(self, value: Optional[float], /) -> Self:
            """
            The ID of Droplet that the reserved IP will be assigned to.
            """
            return self._set("droplet_id", value)

        def id(self, value: Optional[str], /) -> Self:
            return self._set("id", value)

        def ip_address(self, value: Optional[str], /) -> Self:
            """
            The reserved IP to assign to the Droplet.
            """
            return self._set("ip_address", value)

    class BuilderContext(BuilderContextBase["AtProviderModel1.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AtProviderModel1.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AtProviderModel1."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AtProviderModel1", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AtProviderModel1.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    droplet_id: Annotated[Optional[float], Field(alias="dropletId")] = None
    """
    The ID of Droplet that the reserved IP will be assigned to.
    """
    id: Optional[str] = None
    ip_address: Annotated[Optional[str], Field(alias="ipAddress")] = None
    """
    The reserved IP to assign to the Droplet.
    """


class IPAssignmentStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["IPAssignmentStatus"]:
            return IPAssignmentStatus

        def build(self) -> "IPAssignmentStatus":
            return IPAssignmentStatus(**self._attrs)

        @overload
        def at_provider(
            self, value_or_callback: Optional[AtProviderModel1], /
        ) -> "IPAssignmentStatus.Builder": ...

        @overload
        def at_provider(
            self,
            value_or_callback: Callable[
                [AtProviderModel1.Builder], AtProviderModel1.Builder | AtProviderModel1
            ],
            /,
        ) -> "IPAssignmentStatus.Builder": ...

        @overload
        def at_provider(
            self, value_or_callback: Never = ...
        ) -> "AtProviderModel1.BuilderContext": ...

        def at_provider(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = AtProviderModel1.BuilderContext()
                context._parent_builder = self
                context._field_name = "at_provider"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AtProviderModel1.builder())
                if isinstance(output, AtProviderModel1.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("at_provider", value)

        @overload
        def conditions(
            self, value_or_callback: List[Condition], /
        ) -> "IPAssignmentStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Condition, Condition.Builder]],
                GenericListBuilder[Condition, Condition.Builder] | List[Condition],
            ],
            /,
        ) -> "IPAssignmentStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            """
            Conditions of the resource.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        def observed_generation(self, value: Optional[int], /) -> Self:
            """
            ObservedGeneration is the latest metadata.generation
            which resulted in either a ready state, or stalled due to error
            it can not recover from without human intervention.
            """
            return self._set("observed_generation", value)

    class BuilderContext(BuilderContextBase["IPAssignmentStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = IPAssignmentStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for IPAssignmentStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["IPAssignmentStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use IPAssignmentStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    at_provider: Annotated[Optional[AtProviderModel1], Field(alias="atProvider")] = None
    conditions: Optional[List[Condition]] = None
    """
    Conditions of the resource.
    """
    observed_generation: Annotated[Optional[int], Field(alias="observedGeneration")] = None
    """
    ObservedGeneration is the latest metadata.generation
    which resulted in either a ready state, or stalled due to error
    it can not recover from without human intervention.
    """


class ForProviderModel2(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ForProviderModel2"]:
            return ForProviderModel2

        def build(self) -> "ForProviderModel2":
            return ForProviderModel2(**self._attrs)

        def droplet_id(self, value: Optional[float], /) -> Self:
            """
            The ID of Droplet that the reserved IP will be assigned to.
            """
            return self._set("droplet_id", value)

        @overload
        def droplet_id_ref(
            self, value_or_callback: Optional[DropletIdRef], /
        ) -> "ForProviderModel2.Builder": ...

        @overload
        def droplet_id_ref(
            self,
            value_or_callback: Callable[
                [DropletIdRef.Builder], DropletIdRef.Builder | DropletIdRef
            ],
            /,
        ) -> "ForProviderModel2.Builder": ...

        @overload
        def droplet_id_ref(
            self, value_or_callback: Never = ...
        ) -> "DropletIdRef.BuilderContext": ...

        def droplet_id_ref(self, value_or_callback=None, /):
            """
            Reference to a Droplet in droplet to populate dropletId.
            """
            if self._in_context and value_or_callback is None:
                context = DropletIdRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "droplet_id_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(DropletIdRef.builder())
                if isinstance(output, DropletIdRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("droplet_id_ref", value)

        @overload
        def droplet_id_selector(
            self, value_or_callback: Optional[DropletIdSelector], /
        ) -> "ForProviderModel2.Builder": ...

        @overload
        def droplet_id_selector(
            self,
            value_or_callback: Callable[
                [DropletIdSelector.Builder],
                DropletIdSelector.Builder | DropletIdSelector,
            ],
            /,
        ) -> "ForProviderModel2.Builder": ...

        @overload
        def droplet_id_selector(
            self, value_or_callback: Never = ...
        ) -> "DropletIdSelector.BuilderContext": ...

        def droplet_id_selector(self, value_or_callback=None, /):
            """
            Selector for a Droplet in droplet to populate dropletId.
            """
            if self._in_context and value_or_callback is None:
                context = DropletIdSelector.BuilderContext()
                context._parent_builder = self
                context._field_name = "droplet_id_selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(DropletIdSelector.builder())
                if isinstance(output, DropletIdSelector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("droplet_id_selector", value)

        def ip_address(self, value: Optional[str], /) -> Self:
            """
            The IP Address of the resource
            """
            return self._set("ip_address", value)

        def region(self, value: Optional[str], /) -> Self:
            """
            The region that the reserved IP is reserved to.
            """
            return self._set("region", value)

    class BuilderContext(BuilderContextBase["ForProviderModel2.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ForProviderModel2.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ForProviderModel2."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ForProviderModel2", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ForProviderModel2.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    droplet_id: Annotated[Optional[float], Field(alias="dropletId")] = None
    """
    The ID of Droplet that the reserved IP will be assigned to.
    """
    droplet_id_ref: Annotated[Optional[DropletIdRef], Field(alias="dropletIdRef")] = None
    """
    Reference to a Droplet in droplet to populate dropletId.
    """
    droplet_id_selector: Annotated[
        Optional[DropletIdSelector], Field(alias="dropletIdSelector")
    ] = None
    """
    Selector for a Droplet in droplet to populate dropletId.
    """
    ip_address: Annotated[Optional[str], Field(alias="ipAddress")] = None
    """
    The IP Address of the resource
    """
    region: Optional[str] = None
    """
    The region that the reserved IP is reserved to.
    """


class InitProviderModel2(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["InitProviderModel2"]:
            return InitProviderModel2

        def build(self) -> "InitProviderModel2":
            return InitProviderModel2(**self._attrs)

        def droplet_id(self, value: Optional[float], /) -> Self:
            """
            The ID of Droplet that the reserved IP will be assigned to.
            """
            return self._set("droplet_id", value)

        @overload
        def droplet_id_ref(
            self, value_or_callback: Optional[DropletIdRef], /
        ) -> "InitProviderModel2.Builder": ...

        @overload
        def droplet_id_ref(
            self,
            value_or_callback: Callable[
                [DropletIdRef.Builder], DropletIdRef.Builder | DropletIdRef
            ],
            /,
        ) -> "InitProviderModel2.Builder": ...

        @overload
        def droplet_id_ref(
            self, value_or_callback: Never = ...
        ) -> "DropletIdRef.BuilderContext": ...

        def droplet_id_ref(self, value_or_callback=None, /):
            """
            Reference to a Droplet in droplet to populate dropletId.
            """
            if self._in_context and value_or_callback is None:
                context = DropletIdRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "droplet_id_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(DropletIdRef.builder())
                if isinstance(output, DropletIdRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("droplet_id_ref", value)

        @overload
        def droplet_id_selector(
            self, value_or_callback: Optional[DropletIdSelector], /
        ) -> "InitProviderModel2.Builder": ...

        @overload
        def droplet_id_selector(
            self,
            value_or_callback: Callable[
                [DropletIdSelector.Builder],
                DropletIdSelector.Builder | DropletIdSelector,
            ],
            /,
        ) -> "InitProviderModel2.Builder": ...

        @overload
        def droplet_id_selector(
            self, value_or_callback: Never = ...
        ) -> "DropletIdSelector.BuilderContext": ...

        def droplet_id_selector(self, value_or_callback=None, /):
            """
            Selector for a Droplet in droplet to populate dropletId.
            """
            if self._in_context and value_or_callback is None:
                context = DropletIdSelector.BuilderContext()
                context._parent_builder = self
                context._field_name = "droplet_id_selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(DropletIdSelector.builder())
                if isinstance(output, DropletIdSelector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("droplet_id_selector", value)

        def ip_address(self, value: Optional[str], /) -> Self:
            """
            The IP Address of the resource
            """
            return self._set("ip_address", value)

        def region(self, value: Optional[str], /) -> Self:
            """
            The region that the reserved IP is reserved to.
            """
            return self._set("region", value)

    class BuilderContext(BuilderContextBase["InitProviderModel2.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = InitProviderModel2.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for InitProviderModel2."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["InitProviderModel2", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use InitProviderModel2.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    droplet_id: Annotated[Optional[float], Field(alias="dropletId")] = None
    """
    The ID of Droplet that the reserved IP will be assigned to.
    """
    droplet_id_ref: Annotated[Optional[DropletIdRef], Field(alias="dropletIdRef")] = None
    """
    Reference to a Droplet in droplet to populate dropletId.
    """
    droplet_id_selector: Annotated[
        Optional[DropletIdSelector], Field(alias="dropletIdSelector")
    ] = None
    """
    Selector for a Droplet in droplet to populate dropletId.
    """
    ip_address: Annotated[Optional[str], Field(alias="ipAddress")] = None
    """
    The IP Address of the resource
    """
    region: Optional[str] = None
    """
    The region that the reserved IP is reserved to.
    """


class IPSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["IPSpec"]:
            return IPSpec

        def build(self) -> "IPSpec":
            return IPSpec(**self._attrs)

        def deletion_policy(self, value: Optional[Literal["Orphan", "Delete"]], /) -> Self:
            """
            DeletionPolicy specifies what will happen to the underlying external
            when this managed resource is deleted - either "Delete" or "Orphan" the
            external resource.
            This field is planned to be deprecated in favor of the ManagementPolicies
            field in a future release. Currently, both could be set independently and
            non-default values would be honored if the feature flag is enabled.
            See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
            """
            return self._set("deletion_policy", value)

        @overload
        def for_provider(self, value_or_callback: ForProviderModel2, /) -> "IPSpec.Builder": ...

        @overload
        def for_provider(
            self,
            value_or_callback: Callable[
                [ForProviderModel2.Builder],
                ForProviderModel2.Builder | ForProviderModel2,
            ],
            /,
        ) -> "IPSpec.Builder": ...

        @overload
        def for_provider(
            self, value_or_callback: Never = ...
        ) -> "ForProviderModel2.BuilderContext": ...

        def for_provider(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ForProviderModel2.BuilderContext()
                context._parent_builder = self
                context._field_name = "for_provider"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ForProviderModel2.builder())
                if isinstance(output, ForProviderModel2.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("for_provider", value)

        @overload
        def init_provider(
            self, value_or_callback: Optional[InitProviderModel2], /
        ) -> "IPSpec.Builder": ...

        @overload
        def init_provider(
            self,
            value_or_callback: Callable[
                [InitProviderModel2.Builder],
                InitProviderModel2.Builder | InitProviderModel2,
            ],
            /,
        ) -> "IPSpec.Builder": ...

        @overload
        def init_provider(
            self, value_or_callback: Never = ...
        ) -> "InitProviderModel2.BuilderContext": ...

        def init_provider(self, value_or_callback=None, /):
            """
            THIS IS A BETA FIELD. It will be honored
            unless the Management Policies feature flag is disabled.
            InitProvider holds the same fields as ForProvider, with the exception
            of Identifier and other resource reference fields. The fields that are
            in InitProvider are merged into ForProvider when the resource is created.
            The same fields are also added to the terraform ignore_changes hook, to
            avoid updating them after creation. This is useful for fields that are
            required on creation, but we do not desire to update them after creation,
            for example because of an external controller is managing them, like an
            autoscaler.
            """
            if self._in_context and value_or_callback is None:
                context = InitProviderModel2.BuilderContext()
                context._parent_builder = self
                context._field_name = "init_provider"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(InitProviderModel2.builder())
                if isinstance(output, InitProviderModel2.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("init_provider", value)

        def management_policies(
            self,
            value: Optional[
                List[Literal["Observe", "Create", "Update", "Delete", "LateInitialize", "*"]]
            ],
            /,
        ) -> Self:
            """
            THIS IS A BETA FIELD. It is on by default but can be opted out
            through a Crossplane feature flag.
            ManagementPolicies specify the array of actions Crossplane is allowed to
            take on the managed and external resources.
            This field is planned to replace the DeletionPolicy field in a future
            release. Currently, both could be set independently and non-default
            values would be honored if the feature flag is enabled. If both are
            custom, the DeletionPolicy field will be ignored.
            See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
            and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
            """
            return self._set("management_policies", value)

        @overload
        def provider_config_ref(
            self, value_or_callback: Optional[ProviderConfigRef], /
        ) -> "IPSpec.Builder": ...

        @overload
        def provider_config_ref(
            self,
            value_or_callback: Callable[
                [ProviderConfigRef.Builder],
                ProviderConfigRef.Builder | ProviderConfigRef,
            ],
            /,
        ) -> "IPSpec.Builder": ...

        @overload
        def provider_config_ref(
            self, value_or_callback: Never = ...
        ) -> "ProviderConfigRef.BuilderContext": ...

        def provider_config_ref(self, value_or_callback=None, /):
            """
            ProviderConfigReference specifies how the provider that will be used to
            create, observe, update, and delete this managed resource should be
            configured.
            """
            if self._in_context and value_or_callback is None:
                context = ProviderConfigRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "provider_config_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ProviderConfigRef.builder())
                if isinstance(output, ProviderConfigRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("provider_config_ref", value)

        @overload
        def publish_connection_details_to(
            self, value_or_callback: Optional[PublishConnectionDetailsTo], /
        ) -> "IPSpec.Builder": ...

        @overload
        def publish_connection_details_to(
            self,
            value_or_callback: Callable[
                [PublishConnectionDetailsTo.Builder],
                PublishConnectionDetailsTo.Builder | PublishConnectionDetailsTo,
            ],
            /,
        ) -> "IPSpec.Builder": ...

        @overload
        def publish_connection_details_to(
            self, value_or_callback: Never = ...
        ) -> "PublishConnectionDetailsTo.BuilderContext": ...

        def publish_connection_details_to(self, value_or_callback=None, /):
            """
            PublishConnectionDetailsTo specifies the connection secret config which
            contains a name, metadata and a reference to secret store config to
            which any connection details for this managed resource should be written.
            Connection details frequently include the endpoint, username,
            and password required to connect to the managed resource.
            """
            if self._in_context and value_or_callback is None:
                context = PublishConnectionDetailsTo.BuilderContext()
                context._parent_builder = self
                context._field_name = "publish_connection_details_to"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PublishConnectionDetailsTo.builder())
                if isinstance(output, PublishConnectionDetailsTo.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("publish_connection_details_to", value)

        @overload
        def write_connection_secret_to_ref(
            self, value_or_callback: Optional[WriteConnectionSecretToRef], /
        ) -> "IPSpec.Builder": ...

        @overload
        def write_connection_secret_to_ref(
            self,
            value_or_callback: Callable[
                [WriteConnectionSecretToRef.Builder],
                WriteConnectionSecretToRef.Builder | WriteConnectionSecretToRef,
            ],
            /,
        ) -> "IPSpec.Builder": ...

        @overload
        def write_connection_secret_to_ref(
            self, value_or_callback: Never = ...
        ) -> "WriteConnectionSecretToRef.BuilderContext": ...

        def write_connection_secret_to_ref(self, value_or_callback=None, /):
            """
            WriteConnectionSecretToReference specifies the namespace and name of a
            Secret to which any connection details for this managed resource should
            be written. Connection details frequently include the endpoint, username,
            and password required to connect to the managed resource.
            This field is planned to be replaced in a future release in favor of
            PublishConnectionDetailsTo. Currently, both could be set independently
            and connection details would be published to both without affecting
            each other.
            """
            if self._in_context and value_or_callback is None:
                context = WriteConnectionSecretToRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "write_connection_secret_to_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(WriteConnectionSecretToRef.builder())
                if isinstance(output, WriteConnectionSecretToRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("write_connection_secret_to_ref", value)

    class BuilderContext(BuilderContextBase["IPSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = IPSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for IPSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["IPSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use IPSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    deletion_policy: Annotated[
        Optional[Literal["Orphan", "Delete"]], Field(alias="deletionPolicy")
    ] = "Delete"
    """
    DeletionPolicy specifies what will happen to the underlying external
    when this managed resource is deleted - either "Delete" or "Orphan" the
    external resource.
    This field is planned to be deprecated in favor of the ManagementPolicies
    field in a future release. Currently, both could be set independently and
    non-default values would be honored if the feature flag is enabled.
    See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    """
    for_provider: Annotated[ForProviderModel2, Field(alias="forProvider")]
    init_provider: Annotated[Optional[InitProviderModel2], Field(alias="initProvider")] = None
    """
    THIS IS A BETA FIELD. It will be honored
    unless the Management Policies feature flag is disabled.
    InitProvider holds the same fields as ForProvider, with the exception
    of Identifier and other resource reference fields. The fields that are
    in InitProvider are merged into ForProvider when the resource is created.
    The same fields are also added to the terraform ignore_changes hook, to
    avoid updating them after creation. This is useful for fields that are
    required on creation, but we do not desire to update them after creation,
    for example because of an external controller is managing them, like an
    autoscaler.
    """
    management_policies: Annotated[
        Optional[List[Literal["Observe", "Create", "Update", "Delete", "LateInitialize", "*"]]],
        Field(alias="managementPolicies"),
    ] = ["*"]
    """
    THIS IS A BETA FIELD. It is on by default but can be opted out
    through a Crossplane feature flag.
    ManagementPolicies specify the array of actions Crossplane is allowed to
    take on the managed and external resources.
    This field is planned to replace the DeletionPolicy field in a future
    release. Currently, both could be set independently and non-default
    values would be honored if the feature flag is enabled. If both are
    custom, the DeletionPolicy field will be ignored.
    See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
    """
    provider_config_ref: Annotated[
        Optional[ProviderConfigRef],
        Field(
            default_factory=lambda: ProviderConfigRef.model_validate({"name": "default"}),
            alias="providerConfigRef",
        ),
    ] = {"name": "default"}
    """
    ProviderConfigReference specifies how the provider that will be used to
    create, observe, update, and delete this managed resource should be
    configured.
    """
    publish_connection_details_to: Annotated[
        Optional[PublishConnectionDetailsTo], Field(alias="publishConnectionDetailsTo")
    ] = None
    """
    PublishConnectionDetailsTo specifies the connection secret config which
    contains a name, metadata and a reference to secret store config to
    which any connection details for this managed resource should be written.
    Connection details frequently include the endpoint, username,
    and password required to connect to the managed resource.
    """
    write_connection_secret_to_ref: Annotated[
        Optional[WriteConnectionSecretToRef], Field(alias="writeConnectionSecretToRef")
    ] = None
    """
    WriteConnectionSecretToReference specifies the namespace and name of a
    Secret to which any connection details for this managed resource should
    be written. Connection details frequently include the endpoint, username,
    and password required to connect to the managed resource.
    This field is planned to be replaced in a future release in favor of
    PublishConnectionDetailsTo. Currently, both could be set independently
    and connection details would be published to both without affecting
    each other.
    """


class AtProviderModel2(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AtProviderModel2"]:
            return AtProviderModel2

        def build(self) -> "AtProviderModel2":
            return AtProviderModel2(**self._attrs)

        def droplet_id(self, value: Optional[float], /) -> Self:
            """
            The ID of Droplet that the reserved IP will be assigned to.
            """
            return self._set("droplet_id", value)

        def id(self, value: Optional[str], /) -> Self:
            return self._set("id", value)

        def ip_address(self, value: Optional[str], /) -> Self:
            """
            The IP Address of the resource
            """
            return self._set("ip_address", value)

        def region(self, value: Optional[str], /) -> Self:
            """
            The region that the reserved IP is reserved to.
            """
            return self._set("region", value)

        def urn(self, value: Optional[str], /) -> Self:
            """
            The uniform resource name of the reserved ip
            the uniform resource name for the reserved ip
            """
            return self._set("urn", value)

    class BuilderContext(BuilderContextBase["AtProviderModel2.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AtProviderModel2.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AtProviderModel2."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AtProviderModel2", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AtProviderModel2.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    droplet_id: Annotated[Optional[float], Field(alias="dropletId")] = None
    """
    The ID of Droplet that the reserved IP will be assigned to.
    """
    id: Optional[str] = None
    ip_address: Annotated[Optional[str], Field(alias="ipAddress")] = None
    """
    The IP Address of the resource
    """
    region: Optional[str] = None
    """
    The region that the reserved IP is reserved to.
    """
    urn: Optional[str] = None
    """
    The uniform resource name of the reserved ip
    the uniform resource name for the reserved ip
    """


class IPStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["IPStatus"]:
            return IPStatus

        def build(self) -> "IPStatus":
            return IPStatus(**self._attrs)

        @overload
        def at_provider(
            self, value_or_callback: Optional[AtProviderModel2], /
        ) -> "IPStatus.Builder": ...

        @overload
        def at_provider(
            self,
            value_or_callback: Callable[
                [AtProviderModel2.Builder], AtProviderModel2.Builder | AtProviderModel2
            ],
            /,
        ) -> "IPStatus.Builder": ...

        @overload
        def at_provider(
            self, value_or_callback: Never = ...
        ) -> "AtProviderModel2.BuilderContext": ...

        def at_provider(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = AtProviderModel2.BuilderContext()
                context._parent_builder = self
                context._field_name = "at_provider"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AtProviderModel2.builder())
                if isinstance(output, AtProviderModel2.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("at_provider", value)

        @overload
        def conditions(self, value_or_callback: List[Condition], /) -> "IPStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Condition, Condition.Builder]],
                GenericListBuilder[Condition, Condition.Builder] | List[Condition],
            ],
            /,
        ) -> "IPStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            """
            Conditions of the resource.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        def observed_generation(self, value: Optional[int], /) -> Self:
            """
            ObservedGeneration is the latest metadata.generation
            which resulted in either a ready state, or stalled due to error
            it can not recover from without human intervention.
            """
            return self._set("observed_generation", value)

    class BuilderContext(BuilderContextBase["IPStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = IPStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for IPStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["IPStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use IPStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    at_provider: Annotated[Optional[AtProviderModel2], Field(alias="atProvider")] = None
    conditions: Optional[List[Condition]] = None
    """
    Conditions of the resource.
    """
    observed_generation: Annotated[Optional[int], Field(alias="observedGeneration")] = None
    """
    ObservedGeneration is the latest metadata.generation
    which resulted in either a ready state, or stalled due to error
    it can not recover from without human intervention.
    """


class Domain(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Domain"]:
            return Domain

        def build(self) -> "Domain":
            return Domain(**self._attrs)

        def certificate_name(self, value: Optional[str], /) -> Self:
            """
            The unique name of the TLS certificate to be used for SSL termination.
            name of certificate required for TLS handshaking
            """
            return self._set("certificate_name", value)

        def is_managed(self, value: Optional[bool], /) -> Self:
            """
            Control flag to specify whether the domain is managed by DigitalOcean.
            flag indicating if domain is managed by DigitalOcean
            """
            return self._set("is_managed", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            The Load Balancer name
            domain name
            """
            return self._set("name", value)

    class BuilderContext(BuilderContextBase["Domain.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Domain.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Domain."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Domain", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Domain.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    certificate_name: Annotated[Optional[str], Field(alias="certificateName")] = None
    """
    The unique name of the TLS certificate to be used for SSL termination.
    name of certificate required for TLS handshaking
    """
    is_managed: Annotated[Optional[bool], Field(alias="isManaged")] = None
    """
    Control flag to specify whether the domain is managed by DigitalOcean.
    flag indicating if domain is managed by DigitalOcean
    """
    name: Optional[str] = None
    """
    The Load Balancer name
    domain name
    """


class Firewall(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Firewall"]:
            return Firewall

        def build(self) -> "Firewall":
            return Firewall(**self._attrs)

        def allow(self, value: Optional[List[str]], /) -> Self:
            """
            A list of strings describing allow rules. Must be colon delimited strings of the form {type}:{source}
            the rules for ALLOWING traffic to the LB (strings in the form: 'ip:1.2.3.4' or 'cidr:1.2.0.0/16')
            """
            return self._set("allow", value)

        def deny(self, value: Optional[List[str]], /) -> Self:
            """
            A list of strings describing deny rules. Must be colon delimited strings of the form {type}:{source}
            the rules for DENYING traffic to the LB (strings in the form: 'ip:1.2.3.4' or 'cidr:1.2.0.0/16')
            """
            return self._set("deny", value)

    class BuilderContext(BuilderContextBase["Firewall.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Firewall.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Firewall."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Firewall", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Firewall.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    allow: Optional[List[str]] = None
    """
    A list of strings describing allow rules. Must be colon delimited strings of the form {type}:{source}
    the rules for ALLOWING traffic to the LB (strings in the form: 'ip:1.2.3.4' or 'cidr:1.2.0.0/16')
    """
    deny: Optional[List[str]] = None
    """
    A list of strings describing deny rules. Must be colon delimited strings of the form {type}:{source}
    the rules for DENYING traffic to the LB (strings in the form: 'ip:1.2.3.4' or 'cidr:1.2.0.0/16')
    """


class CertificateNameRef(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["CertificateNameRef"]:
            return CertificateNameRef

        def build(self) -> "CertificateNameRef":
            return CertificateNameRef(**self._attrs)

        def name(self, value: str, /) -> Self:
            """
            Name of the referenced object.
            """
            return self._set("name", value)

        @overload
        def policy(
            self, value_or_callback: Optional[Policy], /
        ) -> "CertificateNameRef.Builder": ...

        @overload
        def policy(
            self,
            value_or_callback: Callable[[Policy.Builder], Policy.Builder | Policy],
            /,
        ) -> "CertificateNameRef.Builder": ...

        @overload
        def policy(self, value_or_callback: Never = ...) -> "Policy.BuilderContext": ...

        def policy(self, value_or_callback=None, /):
            """
            Policies for referencing.
            """
            if self._in_context and value_or_callback is None:
                context = Policy.BuilderContext()
                context._parent_builder = self
                context._field_name = "policy"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Policy.builder())
                if isinstance(output, Policy.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("policy", value)

    class BuilderContext(BuilderContextBase["CertificateNameRef.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = CertificateNameRef.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for CertificateNameRef."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["CertificateNameRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use CertificateNameRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: str
    """
    Name of the referenced object.
    """
    policy: Optional[Policy] = None
    """
    Policies for referencing.
    """


class CertificateNameSelector(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["CertificateNameSelector"]:
            return CertificateNameSelector

        def build(self) -> "CertificateNameSelector":
            return CertificateNameSelector(**self._attrs)

        def match_controller_ref(self, value: Optional[bool], /) -> Self:
            """
            MatchControllerRef ensures an object with the same controller reference
            as the selecting object is selected.
            """
            return self._set("match_controller_ref", value)

        def match_labels(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            MatchLabels ensures an object with matching labels is selected.
            """
            return self._set("match_labels", value)

        @overload
        def policy(
            self, value_or_callback: Optional[Policy], /
        ) -> "CertificateNameSelector.Builder": ...

        @overload
        def policy(
            self,
            value_or_callback: Callable[[Policy.Builder], Policy.Builder | Policy],
            /,
        ) -> "CertificateNameSelector.Builder": ...

        @overload
        def policy(self, value_or_callback: Never = ...) -> "Policy.BuilderContext": ...

        def policy(self, value_or_callback=None, /):
            """
            Policies for selection.
            """
            if self._in_context and value_or_callback is None:
                context = Policy.BuilderContext()
                context._parent_builder = self
                context._field_name = "policy"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Policy.builder())
                if isinstance(output, Policy.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("policy", value)

    class BuilderContext(BuilderContextBase["CertificateNameSelector.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = CertificateNameSelector.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for CertificateNameSelector."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["CertificateNameSelector", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use CertificateNameSelector.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    match_controller_ref: Annotated[Optional[bool], Field(alias="matchControllerRef")] = None
    """
    MatchControllerRef ensures an object with the same controller reference
    as the selecting object is selected.
    """
    match_labels: Annotated[Optional[Dict[str, str]], Field(alias="matchLabels")] = None
    """
    MatchLabels ensures an object with matching labels is selected.
    """
    policy: Optional[Policy] = None
    """
    Policies for selection.
    """


class ForwardingRule(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ForwardingRule"]:
            return ForwardingRule

        def build(self) -> "ForwardingRule":
            return ForwardingRule(**self._attrs)

        def certificate_id(self, value: Optional[str], /) -> Self:
            """
            Deprecated The ID of the TLS certificate to be used for SSL termination.
            """
            return self._set("certificate_id", value)

        def certificate_name(self, value: Optional[str], /) -> Self:
            """
            The unique name of the TLS certificate to be used for SSL termination.
            """
            return self._set("certificate_name", value)

        @overload
        def certificate_name_ref(
            self, value_or_callback: Optional[CertificateNameRef], /
        ) -> "ForwardingRule.Builder": ...

        @overload
        def certificate_name_ref(
            self,
            value_or_callback: Callable[
                [CertificateNameRef.Builder],
                CertificateNameRef.Builder | CertificateNameRef,
            ],
            /,
        ) -> "ForwardingRule.Builder": ...

        @overload
        def certificate_name_ref(
            self, value_or_callback: Never = ...
        ) -> "CertificateNameRef.BuilderContext": ...

        def certificate_name_ref(self, value_or_callback=None, /):
            """
            Reference to a Certificate in networking to populate certificateName.
            """
            if self._in_context and value_or_callback is None:
                context = CertificateNameRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "certificate_name_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(CertificateNameRef.builder())
                if isinstance(output, CertificateNameRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("certificate_name_ref", value)

        @overload
        def certificate_name_selector(
            self, value_or_callback: Optional[CertificateNameSelector], /
        ) -> "ForwardingRule.Builder": ...

        @overload
        def certificate_name_selector(
            self,
            value_or_callback: Callable[
                [CertificateNameSelector.Builder],
                CertificateNameSelector.Builder | CertificateNameSelector,
            ],
            /,
        ) -> "ForwardingRule.Builder": ...

        @overload
        def certificate_name_selector(
            self, value_or_callback: Never = ...
        ) -> "CertificateNameSelector.BuilderContext": ...

        def certificate_name_selector(self, value_or_callback=None, /):
            """
            Selector for a Certificate in networking to populate certificateName.
            """
            if self._in_context and value_or_callback is None:
                context = CertificateNameSelector.BuilderContext()
                context._parent_builder = self
                context._field_name = "certificate_name_selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(CertificateNameSelector.builder())
                if isinstance(output, CertificateNameSelector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("certificate_name_selector", value)

        def entry_port(self, value: Optional[float], /) -> Self:
            """
            An integer representing the port on which the Load Balancer instance will listen.
            """
            return self._set("entry_port", value)

        def entry_protocol(self, value: Optional[str], /) -> Self:
            """
            The protocol used for traffic to the Load Balancer. The possible values are: http, https, http2, http3, tcp, or udp.
            """
            return self._set("entry_protocol", value)

        def target_port(self, value: Optional[float], /) -> Self:
            """
            An integer representing the port on the backend Droplets to which the Load Balancer will send traffic.
            """
            return self._set("target_port", value)

        def target_protocol(self, value: Optional[str], /) -> Self:
            """
            The protocol used for traffic from the Load Balancer to the backend Droplets. The possible values are: http, https, http2, tcp, or udp.
            """
            return self._set("target_protocol", value)

        def tls_passthrough(self, value: Optional[bool], /) -> Self:
            """
            A boolean value indicating whether SSL encrypted traffic will be passed through to the backend Droplets. The default value is false.
            """
            return self._set("tls_passthrough", value)

    class BuilderContext(BuilderContextBase["ForwardingRule.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ForwardingRule.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ForwardingRule."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ForwardingRule", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ForwardingRule.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    certificate_id: Annotated[Optional[str], Field(alias="certificateId")] = None
    """
    Deprecated The ID of the TLS certificate to be used for SSL termination.
    """
    certificate_name: Annotated[Optional[str], Field(alias="certificateName")] = None
    """
    The unique name of the TLS certificate to be used for SSL termination.
    """
    certificate_name_ref: Annotated[
        Optional[CertificateNameRef], Field(alias="certificateNameRef")
    ] = None
    """
    Reference to a Certificate in networking to populate certificateName.
    """
    certificate_name_selector: Annotated[
        Optional[CertificateNameSelector], Field(alias="certificateNameSelector")
    ] = None
    """
    Selector for a Certificate in networking to populate certificateName.
    """
    entry_port: Annotated[Optional[float], Field(alias="entryPort")] = None
    """
    An integer representing the port on which the Load Balancer instance will listen.
    """
    entry_protocol: Annotated[Optional[str], Field(alias="entryProtocol")] = None
    """
    The protocol used for traffic to the Load Balancer. The possible values are: http, https, http2, http3, tcp, or udp.
    """
    target_port: Annotated[Optional[float], Field(alias="targetPort")] = None
    """
    An integer representing the port on the backend Droplets to which the Load Balancer will send traffic.
    """
    target_protocol: Annotated[Optional[str], Field(alias="targetProtocol")] = None
    """
    The protocol used for traffic from the Load Balancer to the backend Droplets. The possible values are: http, https, http2, tcp, or udp.
    """
    tls_passthrough: Annotated[Optional[bool], Field(alias="tlsPassthrough")] = None
    """
    A boolean value indicating whether SSL encrypted traffic will be passed through to the backend Droplets. The default value is false.
    """


class Cdn(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Cdn"]:
            return Cdn

        def build(self) -> "Cdn":
            return Cdn(**self._attrs)

        def is_enabled(self, value: Optional[bool], /) -> Self:
            """
            Control flag to specify if caching is enabled.
            cache enable flag
            """
            return self._set("is_enabled", value)

    class BuilderContext(BuilderContextBase["Cdn.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Cdn.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Cdn."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Cdn", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Cdn.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    is_enabled: Annotated[Optional[bool], Field(alias="isEnabled")] = None
    """
    Control flag to specify if caching is enabled.
    cache enable flag
    """


class GlbSetting(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["GlbSetting"]:
            return GlbSetting

        def build(self) -> "GlbSetting":
            return GlbSetting(**self._attrs)

        @overload
        def cdn(self, value_or_callback: List[Cdn], /) -> "GlbSetting.Builder": ...

        @overload
        def cdn(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Cdn, Cdn.Builder]],
                GenericListBuilder[Cdn, Cdn.Builder] | List[Cdn],
            ],
            /,
        ) -> "GlbSetting.Builder": ...

        @overload
        def cdn(self, value_or_callback: Never = ...) -> ListBuilderContext[Cdn.Builder]: ...

        def cdn(self, value_or_callback=None, /):
            """
            CDN configuration supporting the following:
            CDN specific configurations
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Cdn.Builder]()
                context._parent_builder = self
                context._field_name = "cdn"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Cdn.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("cdn", value)

        def failover_threshold(self, value: Optional[float], /) -> Self:
            """
            fail-over threshold
            """
            return self._set("failover_threshold", value)

        def region_priorities(self, value: Optional[Dict[str, float]], /) -> Self:
            """
            region priority map
            """
            return self._set("region_priorities", value)

        def target_port(self, value: Optional[float], /) -> Self:
            """
            An integer representing the port on the backend Droplets to which the Load Balancer will send traffic.
            target port rules
            """
            return self._set("target_port", value)

        def target_protocol(self, value: Optional[str], /) -> Self:
            """
            The protocol used for traffic from the Load Balancer to the backend Droplets. The possible values are: http, https, http2, tcp, or udp.
            target protocol rules
            """
            return self._set("target_protocol", value)

    class BuilderContext(BuilderContextBase["GlbSetting.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = GlbSetting.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for GlbSetting."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["GlbSetting", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use GlbSetting.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    cdn: Optional[List[Cdn]] = None
    """
    CDN configuration supporting the following:
    CDN specific configurations
    """
    failover_threshold: Annotated[Optional[float], Field(alias="failoverThreshold")] = None
    """
    fail-over threshold
    """
    region_priorities: Annotated[Optional[Dict[str, float]], Field(alias="regionPriorities")] = None
    """
    region priority map
    """
    target_port: Annotated[Optional[float], Field(alias="targetPort")] = None
    """
    An integer representing the port on the backend Droplets to which the Load Balancer will send traffic.
    target port rules
    """
    target_protocol: Annotated[Optional[str], Field(alias="targetProtocol")] = None
    """
    The protocol used for traffic from the Load Balancer to the backend Droplets. The possible values are: http, https, http2, tcp, or udp.
    target protocol rules
    """


class Healthcheck(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Healthcheck"]:
            return Healthcheck

        def build(self) -> "Healthcheck":
            return Healthcheck(**self._attrs)

        def check_interval_seconds(self, value: Optional[float], /) -> Self:
            """
            The number of seconds between two consecutive health checks. If not specified, the default value is 10.
            """
            return self._set("check_interval_seconds", value)

        def healthy_threshold(self, value: Optional[float], /) -> Self:
            """
            The number of times a health check must pass for a backend Droplet to be marked "healthy" and be re-added to the pool. If not specified, the default value is 5.
            """
            return self._set("healthy_threshold", value)

        def path(self, value: Optional[str], /) -> Self:
            """
            The path on the backend Droplets to which the Load Balancer instance will send a request.
            """
            return self._set("path", value)

        def port(self, value: Optional[float], /) -> Self:
            """
            An integer representing the port on the backend Droplets on which the health check will attempt a connection.
            """
            return self._set("port", value)

        def protocol(self, value: Optional[str], /) -> Self:
            """
            The protocol used for health checks sent to the backend Droplets. The possible values are http, https or tcp.
            """
            return self._set("protocol", value)

        def response_timeout_seconds(self, value: Optional[float], /) -> Self:
            """
            The number of seconds the Load Balancer instance will wait for a response until marking a health check as failed. If not specified, the default value is 5.
            """
            return self._set("response_timeout_seconds", value)

        def unhealthy_threshold(self, value: Optional[float], /) -> Self:
            """
            The number of times a health check must fail for a backend Droplet to be marked "unhealthy" and be removed from the pool. If not specified, the default value is 3.
            """
            return self._set("unhealthy_threshold", value)

    class BuilderContext(BuilderContextBase["Healthcheck.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Healthcheck.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Healthcheck."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Healthcheck", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Healthcheck.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    check_interval_seconds: Annotated[Optional[float], Field(alias="checkIntervalSeconds")] = None
    """
    The number of seconds between two consecutive health checks. If not specified, the default value is 10.
    """
    healthy_threshold: Annotated[Optional[float], Field(alias="healthyThreshold")] = None
    """
    The number of times a health check must pass for a backend Droplet to be marked "healthy" and be re-added to the pool. If not specified, the default value is 5.
    """
    path: Optional[str] = None
    """
    The path on the backend Droplets to which the Load Balancer instance will send a request.
    """
    port: Optional[float] = None
    """
    An integer representing the port on the backend Droplets on which the health check will attempt a connection.
    """
    protocol: Optional[str] = None
    """
    The protocol used for health checks sent to the backend Droplets. The possible values are http, https or tcp.
    """
    response_timeout_seconds: Annotated[Optional[float], Field(alias="responseTimeoutSeconds")] = (
        None
    )
    """
    The number of seconds the Load Balancer instance will wait for a response until marking a health check as failed. If not specified, the default value is 5.
    """
    unhealthy_threshold: Annotated[Optional[float], Field(alias="unhealthyThreshold")] = None
    """
    The number of times a health check must fail for a backend Droplet to be marked "unhealthy" and be removed from the pool. If not specified, the default value is 3.
    """


class ProjectIdRef(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ProjectIdRef"]:
            return ProjectIdRef

        def build(self) -> "ProjectIdRef":
            return ProjectIdRef(**self._attrs)

        def name(self, value: str, /) -> Self:
            """
            Name of the referenced object.
            """
            return self._set("name", value)

        @overload
        def policy(self, value_or_callback: Optional[Policy], /) -> "ProjectIdRef.Builder": ...

        @overload
        def policy(
            self,
            value_or_callback: Callable[[Policy.Builder], Policy.Builder | Policy],
            /,
        ) -> "ProjectIdRef.Builder": ...

        @overload
        def policy(self, value_or_callback: Never = ...) -> "Policy.BuilderContext": ...

        def policy(self, value_or_callback=None, /):
            """
            Policies for referencing.
            """
            if self._in_context and value_or_callback is None:
                context = Policy.BuilderContext()
                context._parent_builder = self
                context._field_name = "policy"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Policy.builder())
                if isinstance(output, Policy.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("policy", value)

    class BuilderContext(BuilderContextBase["ProjectIdRef.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ProjectIdRef.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ProjectIdRef."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ProjectIdRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ProjectIdRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: str
    """
    Name of the referenced object.
    """
    policy: Optional[Policy] = None
    """
    Policies for referencing.
    """


class ProjectIdSelector(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ProjectIdSelector"]:
            return ProjectIdSelector

        def build(self) -> "ProjectIdSelector":
            return ProjectIdSelector(**self._attrs)

        def match_controller_ref(self, value: Optional[bool], /) -> Self:
            """
            MatchControllerRef ensures an object with the same controller reference
            as the selecting object is selected.
            """
            return self._set("match_controller_ref", value)

        def match_labels(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            MatchLabels ensures an object with matching labels is selected.
            """
            return self._set("match_labels", value)

        @overload
        def policy(self, value_or_callback: Optional[Policy], /) -> "ProjectIdSelector.Builder": ...

        @overload
        def policy(
            self,
            value_or_callback: Callable[[Policy.Builder], Policy.Builder | Policy],
            /,
        ) -> "ProjectIdSelector.Builder": ...

        @overload
        def policy(self, value_or_callback: Never = ...) -> "Policy.BuilderContext": ...

        def policy(self, value_or_callback=None, /):
            """
            Policies for selection.
            """
            if self._in_context and value_or_callback is None:
                context = Policy.BuilderContext()
                context._parent_builder = self
                context._field_name = "policy"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Policy.builder())
                if isinstance(output, Policy.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("policy", value)

    class BuilderContext(BuilderContextBase["ProjectIdSelector.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ProjectIdSelector.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ProjectIdSelector."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ProjectIdSelector", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ProjectIdSelector.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    match_controller_ref: Annotated[Optional[bool], Field(alias="matchControllerRef")] = None
    """
    MatchControllerRef ensures an object with the same controller reference
    as the selecting object is selected.
    """
    match_labels: Annotated[Optional[Dict[str, str]], Field(alias="matchLabels")] = None
    """
    MatchLabels ensures an object with matching labels is selected.
    """
    policy: Optional[Policy] = None
    """
    Policies for selection.
    """


class StickySession(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["StickySession"]:
            return StickySession

        def build(self) -> "StickySession":
            return StickySession(**self._attrs)

        def cookie_name(self, value: Optional[str], /) -> Self:
            """
            The name to be used for the cookie sent to the client. This attribute is required when using cookies for the sticky sessions type.
            """
            return self._set("cookie_name", value)

        def cookie_ttl_seconds(self, value: Optional[float], /) -> Self:
            """
            The number of seconds until the cookie set by the Load Balancer expires. This attribute is required when using cookies for the sticky sessions type.
            """
            return self._set("cookie_ttl_seconds", value)

        def type(self, value: Optional[str], /) -> Self:
            """
            The type of the Load Balancer. It must be either of REGIONAL or GLOBAL. Defaults to REGIONAL.
            NOTE: non-REGIONAL type may be part of closed beta feature and not available for public use.
            """
            return self._set("type", value)

    class BuilderContext(BuilderContextBase["StickySession.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = StickySession.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for StickySession."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["StickySession", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use StickySession.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    cookie_name: Annotated[Optional[str], Field(alias="cookieName")] = None
    """
    The name to be used for the cookie sent to the client. This attribute is required when using cookies for the sticky sessions type.
    """
    cookie_ttl_seconds: Annotated[Optional[float], Field(alias="cookieTtlSeconds")] = None
    """
    The number of seconds until the cookie set by the Load Balancer expires. This attribute is required when using cookies for the sticky sessions type.
    """
    type: Optional[str] = None
    """
    The type of the Load Balancer. It must be either of REGIONAL or GLOBAL. Defaults to REGIONAL.
    NOTE: non-REGIONAL type may be part of closed beta feature and not available for public use.
    """


class VpcUuidRef(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["VpcUuidRef"]:
            return VpcUuidRef

        def build(self) -> "VpcUuidRef":
            return VpcUuidRef(**self._attrs)

        def name(self, value: str, /) -> Self:
            """
            Name of the referenced object.
            """
            return self._set("name", value)

        @overload
        def policy(self, value_or_callback: Optional[Policy], /) -> "VpcUuidRef.Builder": ...

        @overload
        def policy(
            self,
            value_or_callback: Callable[[Policy.Builder], Policy.Builder | Policy],
            /,
        ) -> "VpcUuidRef.Builder": ...

        @overload
        def policy(self, value_or_callback: Never = ...) -> "Policy.BuilderContext": ...

        def policy(self, value_or_callback=None, /):
            """
            Policies for referencing.
            """
            if self._in_context and value_or_callback is None:
                context = Policy.BuilderContext()
                context._parent_builder = self
                context._field_name = "policy"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Policy.builder())
                if isinstance(output, Policy.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("policy", value)

    class BuilderContext(BuilderContextBase["VpcUuidRef.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = VpcUuidRef.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for VpcUuidRef."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["VpcUuidRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use VpcUuidRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: str
    """
    Name of the referenced object.
    """
    policy: Optional[Policy] = None
    """
    Policies for referencing.
    """


class VpcUuidSelector(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["VpcUuidSelector"]:
            return VpcUuidSelector

        def build(self) -> "VpcUuidSelector":
            return VpcUuidSelector(**self._attrs)

        def match_controller_ref(self, value: Optional[bool], /) -> Self:
            """
            MatchControllerRef ensures an object with the same controller reference
            as the selecting object is selected.
            """
            return self._set("match_controller_ref", value)

        def match_labels(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            MatchLabels ensures an object with matching labels is selected.
            """
            return self._set("match_labels", value)

        @overload
        def policy(self, value_or_callback: Optional[Policy], /) -> "VpcUuidSelector.Builder": ...

        @overload
        def policy(
            self,
            value_or_callback: Callable[[Policy.Builder], Policy.Builder | Policy],
            /,
        ) -> "VpcUuidSelector.Builder": ...

        @overload
        def policy(self, value_or_callback: Never = ...) -> "Policy.BuilderContext": ...

        def policy(self, value_or_callback=None, /):
            """
            Policies for selection.
            """
            if self._in_context and value_or_callback is None:
                context = Policy.BuilderContext()
                context._parent_builder = self
                context._field_name = "policy"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Policy.builder())
                if isinstance(output, Policy.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("policy", value)

    class BuilderContext(BuilderContextBase["VpcUuidSelector.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = VpcUuidSelector.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for VpcUuidSelector."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["VpcUuidSelector", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use VpcUuidSelector.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    match_controller_ref: Annotated[Optional[bool], Field(alias="matchControllerRef")] = None
    """
    MatchControllerRef ensures an object with the same controller reference
    as the selecting object is selected.
    """
    match_labels: Annotated[Optional[Dict[str, str]], Field(alias="matchLabels")] = None
    """
    MatchLabels ensures an object with matching labels is selected.
    """
    policy: Optional[Policy] = None
    """
    Policies for selection.
    """


class ForProviderModel3(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ForProviderModel3"]:
            return ForProviderModel3

        def build(self) -> "ForProviderModel3":
            return ForProviderModel3(**self._attrs)

        def algorithm(self, value: Optional[str], /) -> Self:
            """
            Deprecated This field has been deprecated. You can no longer specify an algorithm for load balancers.
            or least_connections. The default value is round_robin.
            """
            return self._set("algorithm", value)

        def disable_lets_encrypt_dns_records(self, value: Optional[bool], /) -> Self:
            """
            A boolean value indicating whether to disable automatic DNS record creation for Let's Encrypt certificates that are added to the load balancer. Default value is false.
            """
            return self._set("disable_lets_encrypt_dns_records", value)

        @overload
        def domains(self, value_or_callback: List[Domain], /) -> "ForProviderModel3.Builder": ...

        @overload
        def domains(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Domain, Domain.Builder]],
                GenericListBuilder[Domain, Domain.Builder] | List[Domain],
            ],
            /,
        ) -> "ForProviderModel3.Builder": ...

        @overload
        def domains(self, value_or_callback: Never = ...) -> ListBuilderContext[Domain.Builder]: ...

        def domains(self, value_or_callback=None, /):
            """
            A list of domains required to ingress traffic to a Global Load Balancer. The domains block is documented below.
            NOTE: this is a closed beta feature and not available for public use.
            the list of domains required to ingress traffic to global load balancer
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Domain.Builder]()
                context._parent_builder = self
                context._field_name = "domains"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Domain.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("domains", value)

        def droplet_ids(self, value: Optional[List[float]], /) -> Self:
            """
            A list of the IDs of each droplet to be attached to the Load Balancer.
            """
            return self._set("droplet_ids", value)

        @overload
        def droplet_ids_refs(
            self, value_or_callback: List[DropletIdsRef], /
        ) -> "ForProviderModel3.Builder": ...

        @overload
        def droplet_ids_refs(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[DropletIdsRef, DropletIdsRef.Builder]],
                GenericListBuilder[DropletIdsRef, DropletIdsRef.Builder] | List[DropletIdsRef],
            ],
            /,
        ) -> "ForProviderModel3.Builder": ...

        @overload
        def droplet_ids_refs(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[DropletIdsRef.Builder]: ...

        def droplet_ids_refs(self, value_or_callback=None, /):
            """
            References to Droplet in droplet to populate dropletIds.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[DropletIdsRef.Builder]()
                context._parent_builder = self
                context._field_name = "droplet_ids_refs"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(DropletIdsRef.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("droplet_ids_refs", value)

        @overload
        def droplet_ids_selector(
            self, value_or_callback: Optional[DropletIdsSelector], /
        ) -> "ForProviderModel3.Builder": ...

        @overload
        def droplet_ids_selector(
            self,
            value_or_callback: Callable[
                [DropletIdsSelector.Builder],
                DropletIdsSelector.Builder | DropletIdsSelector,
            ],
            /,
        ) -> "ForProviderModel3.Builder": ...

        @overload
        def droplet_ids_selector(
            self, value_or_callback: Never = ...
        ) -> "DropletIdsSelector.BuilderContext": ...

        def droplet_ids_selector(self, value_or_callback=None, /):
            """
            Selector for a list of Droplet in droplet to populate dropletIds.
            """
            if self._in_context and value_or_callback is None:
                context = DropletIdsSelector.BuilderContext()
                context._parent_builder = self
                context._field_name = "droplet_ids_selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(DropletIdsSelector.builder())
                if isinstance(output, DropletIdsSelector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("droplet_ids_selector", value)

        def droplet_tag(self, value: Optional[str], /) -> Self:
            """
            The name of a Droplet tag corresponding to Droplets to be assigned to the Load Balancer.
            """
            return self._set("droplet_tag", value)

        def enable_backend_keepalive(self, value: Optional[bool], /) -> Self:
            """
            A boolean value indicating whether HTTP keepalive connections are maintained to target Droplets. Default value is false.
            """
            return self._set("enable_backend_keepalive", value)

        def enable_proxy_protocol(self, value: Optional[bool], /) -> Self:
            """
            A boolean value indicating whether PROXY
            Protocol should be used to pass information from connecting client requests to
            the backend service. Default value is false.
            """
            return self._set("enable_proxy_protocol", value)

        @overload
        def firewall(self, value_or_callback: List[Firewall], /) -> "ForProviderModel3.Builder": ...

        @overload
        def firewall(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Firewall, Firewall.Builder]],
                GenericListBuilder[Firewall, Firewall.Builder] | List[Firewall],
            ],
            /,
        ) -> "ForProviderModel3.Builder": ...

        @overload
        def firewall(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Firewall.Builder]: ...

        def firewall(self, value_or_callback=None, /):
            """
            A block containing rules for allowing/denying traffic to the Load Balancer. The firewall block is documented below. Only 1 firewall is allowed.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Firewall.Builder]()
                context._parent_builder = self
                context._field_name = "firewall"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Firewall.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("firewall", value)

        @overload
        def forwarding_rule(
            self, value_or_callback: List[ForwardingRule], /
        ) -> "ForProviderModel3.Builder": ...

        @overload
        def forwarding_rule(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[ForwardingRule, ForwardingRule.Builder]],
                GenericListBuilder[ForwardingRule, ForwardingRule.Builder] | List[ForwardingRule],
            ],
            /,
        ) -> "ForProviderModel3.Builder": ...

        @overload
        def forwarding_rule(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ForwardingRule.Builder]: ...

        def forwarding_rule(self, value_or_callback=None, /):
            """
            A list of forwarding_rule to be assigned to the
            Load Balancer. The forwarding_rule block is documented below.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ForwardingRule.Builder]()
                context._parent_builder = self
                context._field_name = "forwarding_rule"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ForwardingRule.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("forwarding_rule", value)

        @overload
        def glb_settings(
            self, value_or_callback: List[GlbSetting], /
        ) -> "ForProviderModel3.Builder": ...

        @overload
        def glb_settings(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[GlbSetting, GlbSetting.Builder]],
                GenericListBuilder[GlbSetting, GlbSetting.Builder] | List[GlbSetting],
            ],
            /,
        ) -> "ForProviderModel3.Builder": ...

        @overload
        def glb_settings(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[GlbSetting.Builder]: ...

        def glb_settings(self, value_or_callback=None, /):
            """
            A block containing glb_settings required to define target rules for a Global Load Balancer. The glb_settings block is documented below.
            NOTE: this is a closed beta feature and not available for public use.
            configuration options for global load balancer
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[GlbSetting.Builder]()
                context._parent_builder = self
                context._field_name = "glb_settings"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(GlbSetting.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("glb_settings", value)

        @overload
        def healthcheck(
            self, value_or_callback: List[Healthcheck], /
        ) -> "ForProviderModel3.Builder": ...

        @overload
        def healthcheck(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Healthcheck, Healthcheck.Builder]],
                GenericListBuilder[Healthcheck, Healthcheck.Builder] | List[Healthcheck],
            ],
            /,
        ) -> "ForProviderModel3.Builder": ...

        @overload
        def healthcheck(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Healthcheck.Builder]: ...

        def healthcheck(self, value_or_callback=None, /):
            """
            A healthcheck block to be assigned to the
            Load Balancer. The healthcheck block is documented below. Only 1 healthcheck is allowed.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Healthcheck.Builder]()
                context._parent_builder = self
                context._field_name = "healthcheck"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Healthcheck.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("healthcheck", value)

        def http_idle_timeout_seconds(self, value: Optional[float], /) -> Self:
            """
            Specifies the idle timeout for HTTPS connections on the load balancer in seconds.
            """
            return self._set("http_idle_timeout_seconds", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            The Load Balancer name
            """
            return self._set("name", value)

        def network(self, value: Optional[str], /) -> Self:
            """
            The type of network the Load Balancer is accessible from. It must be either of INTERNAL or EXTERNAL. Defaults to EXTERNAL.
            NOTE: non-EXTERNAL type may be part of closed beta feature and not available for public use.
            the type of network the load balancer is accessible from (EXTERNAL or INTERNAL)
            """
            return self._set("network", value)

        def project_id(self, value: Optional[str], /) -> Self:
            """
            The ID of the project that the load balancer is associated with. If no ID is provided at creation, the load balancer associates with the user's default project.
            """
            return self._set("project_id", value)

        @overload
        def project_id_ref(
            self, value_or_callback: Optional[ProjectIdRef], /
        ) -> "ForProviderModel3.Builder": ...

        @overload
        def project_id_ref(
            self,
            value_or_callback: Callable[
                [ProjectIdRef.Builder], ProjectIdRef.Builder | ProjectIdRef
            ],
            /,
        ) -> "ForProviderModel3.Builder": ...

        @overload
        def project_id_ref(
            self, value_or_callback: Never = ...
        ) -> "ProjectIdRef.BuilderContext": ...

        def project_id_ref(self, value_or_callback=None, /):
            """
            Reference to a Project in project to populate projectId.
            """
            if self._in_context and value_or_callback is None:
                context = ProjectIdRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "project_id_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ProjectIdRef.builder())
                if isinstance(output, ProjectIdRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("project_id_ref", value)

        @overload
        def project_id_selector(
            self, value_or_callback: Optional[ProjectIdSelector], /
        ) -> "ForProviderModel3.Builder": ...

        @overload
        def project_id_selector(
            self,
            value_or_callback: Callable[
                [ProjectIdSelector.Builder],
                ProjectIdSelector.Builder | ProjectIdSelector,
            ],
            /,
        ) -> "ForProviderModel3.Builder": ...

        @overload
        def project_id_selector(
            self, value_or_callback: Never = ...
        ) -> "ProjectIdSelector.BuilderContext": ...

        def project_id_selector(self, value_or_callback=None, /):
            """
            Selector for a Project in project to populate projectId.
            """
            if self._in_context and value_or_callback is None:
                context = ProjectIdSelector.BuilderContext()
                context._parent_builder = self
                context._field_name = "project_id_selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ProjectIdSelector.builder())
                if isinstance(output, ProjectIdSelector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("project_id_selector", value)

        def redirect_http_to_https(self, value: Optional[bool], /) -> Self:
            """
            A boolean value indicating whether
            HTTP requests to the Load Balancer on port 80 will be redirected to HTTPS on port 443.
            Default value is false.
            """
            return self._set("redirect_http_to_https", value)

        def region(self, value: Optional[str], /) -> Self:
            """
            The region to start in
            """
            return self._set("region", value)

        def size(self, value: Optional[str], /) -> Self:
            """
            The size of the Load Balancer. It must be either lb-small, lb-medium, or lb-large. Defaults to lb-small. Only one of size or size_unit may be provided.
            """
            return self._set("size", value)

        def size_unit(self, value: Optional[float], /) -> Self:
            """
            The size of the Load Balancer. It must be in the range (1, 100). Defaults to 1. Only one of size or size_unit may be provided.
            """
            return self._set("size_unit", value)

        @overload
        def sticky_sessions(
            self, value_or_callback: List[StickySession], /
        ) -> "ForProviderModel3.Builder": ...

        @overload
        def sticky_sessions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[StickySession, StickySession.Builder]],
                GenericListBuilder[StickySession, StickySession.Builder] | List[StickySession],
            ],
            /,
        ) -> "ForProviderModel3.Builder": ...

        @overload
        def sticky_sessions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[StickySession.Builder]: ...

        def sticky_sessions(self, value_or_callback=None, /):
            """
            A sticky_sessions block to be assigned to the
            Load Balancer. The sticky_sessions block is documented below. Only 1 sticky_sessions block is allowed.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[StickySession.Builder]()
                context._parent_builder = self
                context._field_name = "sticky_sessions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(StickySession.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("sticky_sessions", value)

        def target_load_balancer_ids(self, value: Optional[List[str]], /) -> Self:
            """
            A list of Load Balancer IDs to be attached behind a Global Load Balancer.
            NOTE: this is a closed beta feature and not available for public use.
            list of load balancer IDs to put behind a global load balancer
            """
            return self._set("target_load_balancer_ids", value)

        def type(self, value: Optional[str], /) -> Self:
            """
            The type of the Load Balancer. It must be either of REGIONAL or GLOBAL. Defaults to REGIONAL.
            NOTE: non-REGIONAL type may be part of closed beta feature and not available for public use.
            the type of the load balancer (GLOBAL or REGIONAL)
            """
            return self._set("type", value)

        def vpc_uuid(self, value: Optional[str], /) -> Self:
            """
            The ID of the VPC where the load balancer will be located.
            """
            return self._set("vpc_uuid", value)

        @overload
        def vpc_uuid_ref(
            self, value_or_callback: Optional[VpcUuidRef], /
        ) -> "ForProviderModel3.Builder": ...

        @overload
        def vpc_uuid_ref(
            self,
            value_or_callback: Callable[[VpcUuidRef.Builder], VpcUuidRef.Builder | VpcUuidRef],
            /,
        ) -> "ForProviderModel3.Builder": ...

        @overload
        def vpc_uuid_ref(self, value_or_callback: Never = ...) -> "VpcUuidRef.BuilderContext": ...

        def vpc_uuid_ref(self, value_or_callback=None, /):
            """
            Reference to a VPC in vpc to populate vpcUuid.
            """
            if self._in_context and value_or_callback is None:
                context = VpcUuidRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "vpc_uuid_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(VpcUuidRef.builder())
                if isinstance(output, VpcUuidRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("vpc_uuid_ref", value)

        @overload
        def vpc_uuid_selector(
            self, value_or_callback: Optional[VpcUuidSelector], /
        ) -> "ForProviderModel3.Builder": ...

        @overload
        def vpc_uuid_selector(
            self,
            value_or_callback: Callable[
                [VpcUuidSelector.Builder], VpcUuidSelector.Builder | VpcUuidSelector
            ],
            /,
        ) -> "ForProviderModel3.Builder": ...

        @overload
        def vpc_uuid_selector(
            self, value_or_callback: Never = ...
        ) -> "VpcUuidSelector.BuilderContext": ...

        def vpc_uuid_selector(self, value_or_callback=None, /):
            """
            Selector for a VPC in vpc to populate vpcUuid.
            """
            if self._in_context and value_or_callback is None:
                context = VpcUuidSelector.BuilderContext()
                context._parent_builder = self
                context._field_name = "vpc_uuid_selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(VpcUuidSelector.builder())
                if isinstance(output, VpcUuidSelector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("vpc_uuid_selector", value)

    class BuilderContext(BuilderContextBase["ForProviderModel3.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ForProviderModel3.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ForProviderModel3."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ForProviderModel3", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ForProviderModel3.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    algorithm: Optional[str] = None
    """
    Deprecated This field has been deprecated. You can no longer specify an algorithm for load balancers.
    or least_connections. The default value is round_robin.
    """
    disable_lets_encrypt_dns_records: Annotated[
        Optional[bool], Field(alias="disableLetsEncryptDnsRecords")
    ] = None
    """
    A boolean value indicating whether to disable automatic DNS record creation for Let's Encrypt certificates that are added to the load balancer. Default value is false.
    """
    domains: Optional[List[Domain]] = None
    """
    A list of domains required to ingress traffic to a Global Load Balancer. The domains block is documented below.
    NOTE: this is a closed beta feature and not available for public use.
    the list of domains required to ingress traffic to global load balancer
    """
    droplet_ids: Annotated[Optional[List[float]], Field(alias="dropletIds")] = None
    """
    A list of the IDs of each droplet to be attached to the Load Balancer.
    """
    droplet_ids_refs: Annotated[Optional[List[DropletIdsRef]], Field(alias="dropletIdsRefs")] = None
    """
    References to Droplet in droplet to populate dropletIds.
    """
    droplet_ids_selector: Annotated[
        Optional[DropletIdsSelector], Field(alias="dropletIdsSelector")
    ] = None
    """
    Selector for a list of Droplet in droplet to populate dropletIds.
    """
    droplet_tag: Annotated[Optional[str], Field(alias="dropletTag")] = None
    """
    The name of a Droplet tag corresponding to Droplets to be assigned to the Load Balancer.
    """
    enable_backend_keepalive: Annotated[Optional[bool], Field(alias="enableBackendKeepalive")] = (
        None
    )
    """
    A boolean value indicating whether HTTP keepalive connections are maintained to target Droplets. Default value is false.
    """
    enable_proxy_protocol: Annotated[Optional[bool], Field(alias="enableProxyProtocol")] = None
    """
    A boolean value indicating whether PROXY
    Protocol should be used to pass information from connecting client requests to
    the backend service. Default value is false.
    """
    firewall: Optional[List[Firewall]] = None
    """
    A block containing rules for allowing/denying traffic to the Load Balancer. The firewall block is documented below. Only 1 firewall is allowed.
    """
    forwarding_rule: Annotated[Optional[List[ForwardingRule]], Field(alias="forwardingRule")] = None
    """
    A list of forwarding_rule to be assigned to the
    Load Balancer. The forwarding_rule block is documented below.
    """
    glb_settings: Annotated[Optional[List[GlbSetting]], Field(alias="glbSettings")] = None
    """
    A block containing glb_settings required to define target rules for a Global Load Balancer. The glb_settings block is documented below.
    NOTE: this is a closed beta feature and not available for public use.
    configuration options for global load balancer
    """
    healthcheck: Optional[List[Healthcheck]] = None
    """
    A healthcheck block to be assigned to the
    Load Balancer. The healthcheck block is documented below. Only 1 healthcheck is allowed.
    """
    http_idle_timeout_seconds: Annotated[Optional[float], Field(alias="httpIdleTimeoutSeconds")] = (
        None
    )
    """
    Specifies the idle timeout for HTTPS connections on the load balancer in seconds.
    """
    name: Optional[str] = None
    """
    The Load Balancer name
    """
    network: Optional[str] = None
    """
    The type of network the Load Balancer is accessible from. It must be either of INTERNAL or EXTERNAL. Defaults to EXTERNAL.
    NOTE: non-EXTERNAL type may be part of closed beta feature and not available for public use.
    the type of network the load balancer is accessible from (EXTERNAL or INTERNAL)
    """
    project_id: Annotated[Optional[str], Field(alias="projectId")] = None
    """
    The ID of the project that the load balancer is associated with. If no ID is provided at creation, the load balancer associates with the user's default project.
    """
    project_id_ref: Annotated[Optional[ProjectIdRef], Field(alias="projectIdRef")] = None
    """
    Reference to a Project in project to populate projectId.
    """
    project_id_selector: Annotated[
        Optional[ProjectIdSelector], Field(alias="projectIdSelector")
    ] = None
    """
    Selector for a Project in project to populate projectId.
    """
    redirect_http_to_https: Annotated[Optional[bool], Field(alias="redirectHttpToHttps")] = None
    """
    A boolean value indicating whether
    HTTP requests to the Load Balancer on port 80 will be redirected to HTTPS on port 443.
    Default value is false.
    """
    region: Optional[str] = None
    """
    The region to start in
    """
    size: Optional[str] = None
    """
    The size of the Load Balancer. It must be either lb-small, lb-medium, or lb-large. Defaults to lb-small. Only one of size or size_unit may be provided.
    """
    size_unit: Annotated[Optional[float], Field(alias="sizeUnit")] = None
    """
    The size of the Load Balancer. It must be in the range (1, 100). Defaults to 1. Only one of size or size_unit may be provided.
    """
    sticky_sessions: Annotated[Optional[List[StickySession]], Field(alias="stickySessions")] = None
    """
    A sticky_sessions block to be assigned to the
    Load Balancer. The sticky_sessions block is documented below. Only 1 sticky_sessions block is allowed.
    """
    target_load_balancer_ids: Annotated[
        Optional[List[str]], Field(alias="targetLoadBalancerIds")
    ] = None
    """
    A list of Load Balancer IDs to be attached behind a Global Load Balancer.
    NOTE: this is a closed beta feature and not available for public use.
    list of load balancer IDs to put behind a global load balancer
    """
    type: Optional[str] = None
    """
    The type of the Load Balancer. It must be either of REGIONAL or GLOBAL. Defaults to REGIONAL.
    NOTE: non-REGIONAL type may be part of closed beta feature and not available for public use.
    the type of the load balancer (GLOBAL or REGIONAL)
    """
    vpc_uuid: Annotated[Optional[str], Field(alias="vpcUuid")] = None
    """
    The ID of the VPC where the load balancer will be located.
    """
    vpc_uuid_ref: Annotated[Optional[VpcUuidRef], Field(alias="vpcUuidRef")] = None
    """
    Reference to a VPC in vpc to populate vpcUuid.
    """
    vpc_uuid_selector: Annotated[Optional[VpcUuidSelector], Field(alias="vpcUuidSelector")] = None
    """
    Selector for a VPC in vpc to populate vpcUuid.
    """


class InitProviderModel3(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["InitProviderModel3"]:
            return InitProviderModel3

        def build(self) -> "InitProviderModel3":
            return InitProviderModel3(**self._attrs)

        def algorithm(self, value: Optional[str], /) -> Self:
            """
            Deprecated This field has been deprecated. You can no longer specify an algorithm for load balancers.
            or least_connections. The default value is round_robin.
            """
            return self._set("algorithm", value)

        def disable_lets_encrypt_dns_records(self, value: Optional[bool], /) -> Self:
            """
            A boolean value indicating whether to disable automatic DNS record creation for Let's Encrypt certificates that are added to the load balancer. Default value is false.
            """
            return self._set("disable_lets_encrypt_dns_records", value)

        @overload
        def domains(self, value_or_callback: List[Domain], /) -> "InitProviderModel3.Builder": ...

        @overload
        def domains(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Domain, Domain.Builder]],
                GenericListBuilder[Domain, Domain.Builder] | List[Domain],
            ],
            /,
        ) -> "InitProviderModel3.Builder": ...

        @overload
        def domains(self, value_or_callback: Never = ...) -> ListBuilderContext[Domain.Builder]: ...

        def domains(self, value_or_callback=None, /):
            """
            A list of domains required to ingress traffic to a Global Load Balancer. The domains block is documented below.
            NOTE: this is a closed beta feature and not available for public use.
            the list of domains required to ingress traffic to global load balancer
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Domain.Builder]()
                context._parent_builder = self
                context._field_name = "domains"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Domain.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("domains", value)

        def droplet_ids(self, value: Optional[List[float]], /) -> Self:
            """
            A list of the IDs of each droplet to be attached to the Load Balancer.
            """
            return self._set("droplet_ids", value)

        @overload
        def droplet_ids_refs(
            self, value_or_callback: List[DropletIdsRef], /
        ) -> "InitProviderModel3.Builder": ...

        @overload
        def droplet_ids_refs(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[DropletIdsRef, DropletIdsRef.Builder]],
                GenericListBuilder[DropletIdsRef, DropletIdsRef.Builder] | List[DropletIdsRef],
            ],
            /,
        ) -> "InitProviderModel3.Builder": ...

        @overload
        def droplet_ids_refs(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[DropletIdsRef.Builder]: ...

        def droplet_ids_refs(self, value_or_callback=None, /):
            """
            References to Droplet in droplet to populate dropletIds.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[DropletIdsRef.Builder]()
                context._parent_builder = self
                context._field_name = "droplet_ids_refs"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(DropletIdsRef.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("droplet_ids_refs", value)

        @overload
        def droplet_ids_selector(
            self, value_or_callback: Optional[DropletIdsSelector], /
        ) -> "InitProviderModel3.Builder": ...

        @overload
        def droplet_ids_selector(
            self,
            value_or_callback: Callable[
                [DropletIdsSelector.Builder],
                DropletIdsSelector.Builder | DropletIdsSelector,
            ],
            /,
        ) -> "InitProviderModel3.Builder": ...

        @overload
        def droplet_ids_selector(
            self, value_or_callback: Never = ...
        ) -> "DropletIdsSelector.BuilderContext": ...

        def droplet_ids_selector(self, value_or_callback=None, /):
            """
            Selector for a list of Droplet in droplet to populate dropletIds.
            """
            if self._in_context and value_or_callback is None:
                context = DropletIdsSelector.BuilderContext()
                context._parent_builder = self
                context._field_name = "droplet_ids_selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(DropletIdsSelector.builder())
                if isinstance(output, DropletIdsSelector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("droplet_ids_selector", value)

        def droplet_tag(self, value: Optional[str], /) -> Self:
            """
            The name of a Droplet tag corresponding to Droplets to be assigned to the Load Balancer.
            """
            return self._set("droplet_tag", value)

        def enable_backend_keepalive(self, value: Optional[bool], /) -> Self:
            """
            A boolean value indicating whether HTTP keepalive connections are maintained to target Droplets. Default value is false.
            """
            return self._set("enable_backend_keepalive", value)

        def enable_proxy_protocol(self, value: Optional[bool], /) -> Self:
            """
            A boolean value indicating whether PROXY
            Protocol should be used to pass information from connecting client requests to
            the backend service. Default value is false.
            """
            return self._set("enable_proxy_protocol", value)

        @overload
        def firewall(
            self, value_or_callback: List[Firewall], /
        ) -> "InitProviderModel3.Builder": ...

        @overload
        def firewall(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Firewall, Firewall.Builder]],
                GenericListBuilder[Firewall, Firewall.Builder] | List[Firewall],
            ],
            /,
        ) -> "InitProviderModel3.Builder": ...

        @overload
        def firewall(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Firewall.Builder]: ...

        def firewall(self, value_or_callback=None, /):
            """
            A block containing rules for allowing/denying traffic to the Load Balancer. The firewall block is documented below. Only 1 firewall is allowed.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Firewall.Builder]()
                context._parent_builder = self
                context._field_name = "firewall"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Firewall.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("firewall", value)

        @overload
        def forwarding_rule(
            self, value_or_callback: List[ForwardingRule], /
        ) -> "InitProviderModel3.Builder": ...

        @overload
        def forwarding_rule(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[ForwardingRule, ForwardingRule.Builder]],
                GenericListBuilder[ForwardingRule, ForwardingRule.Builder] | List[ForwardingRule],
            ],
            /,
        ) -> "InitProviderModel3.Builder": ...

        @overload
        def forwarding_rule(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ForwardingRule.Builder]: ...

        def forwarding_rule(self, value_or_callback=None, /):
            """
            A list of forwarding_rule to be assigned to the
            Load Balancer. The forwarding_rule block is documented below.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ForwardingRule.Builder]()
                context._parent_builder = self
                context._field_name = "forwarding_rule"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ForwardingRule.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("forwarding_rule", value)

        @overload
        def glb_settings(
            self, value_or_callback: List[GlbSetting], /
        ) -> "InitProviderModel3.Builder": ...

        @overload
        def glb_settings(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[GlbSetting, GlbSetting.Builder]],
                GenericListBuilder[GlbSetting, GlbSetting.Builder] | List[GlbSetting],
            ],
            /,
        ) -> "InitProviderModel3.Builder": ...

        @overload
        def glb_settings(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[GlbSetting.Builder]: ...

        def glb_settings(self, value_or_callback=None, /):
            """
            A block containing glb_settings required to define target rules for a Global Load Balancer. The glb_settings block is documented below.
            NOTE: this is a closed beta feature and not available for public use.
            configuration options for global load balancer
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[GlbSetting.Builder]()
                context._parent_builder = self
                context._field_name = "glb_settings"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(GlbSetting.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("glb_settings", value)

        @overload
        def healthcheck(
            self, value_or_callback: List[Healthcheck], /
        ) -> "InitProviderModel3.Builder": ...

        @overload
        def healthcheck(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Healthcheck, Healthcheck.Builder]],
                GenericListBuilder[Healthcheck, Healthcheck.Builder] | List[Healthcheck],
            ],
            /,
        ) -> "InitProviderModel3.Builder": ...

        @overload
        def healthcheck(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Healthcheck.Builder]: ...

        def healthcheck(self, value_or_callback=None, /):
            """
            A healthcheck block to be assigned to the
            Load Balancer. The healthcheck block is documented below. Only 1 healthcheck is allowed.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Healthcheck.Builder]()
                context._parent_builder = self
                context._field_name = "healthcheck"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Healthcheck.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("healthcheck", value)

        def http_idle_timeout_seconds(self, value: Optional[float], /) -> Self:
            """
            Specifies the idle timeout for HTTPS connections on the load balancer in seconds.
            """
            return self._set("http_idle_timeout_seconds", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            The Load Balancer name
            """
            return self._set("name", value)

        def network(self, value: Optional[str], /) -> Self:
            """
            The type of network the Load Balancer is accessible from. It must be either of INTERNAL or EXTERNAL. Defaults to EXTERNAL.
            NOTE: non-EXTERNAL type may be part of closed beta feature and not available for public use.
            the type of network the load balancer is accessible from (EXTERNAL or INTERNAL)
            """
            return self._set("network", value)

        def project_id(self, value: Optional[str], /) -> Self:
            """
            The ID of the project that the load balancer is associated with. If no ID is provided at creation, the load balancer associates with the user's default project.
            """
            return self._set("project_id", value)

        @overload
        def project_id_ref(
            self, value_or_callback: Optional[ProjectIdRef], /
        ) -> "InitProviderModel3.Builder": ...

        @overload
        def project_id_ref(
            self,
            value_or_callback: Callable[
                [ProjectIdRef.Builder], ProjectIdRef.Builder | ProjectIdRef
            ],
            /,
        ) -> "InitProviderModel3.Builder": ...

        @overload
        def project_id_ref(
            self, value_or_callback: Never = ...
        ) -> "ProjectIdRef.BuilderContext": ...

        def project_id_ref(self, value_or_callback=None, /):
            """
            Reference to a Project in project to populate projectId.
            """
            if self._in_context and value_or_callback is None:
                context = ProjectIdRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "project_id_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ProjectIdRef.builder())
                if isinstance(output, ProjectIdRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("project_id_ref", value)

        @overload
        def project_id_selector(
            self, value_or_callback: Optional[ProjectIdSelector], /
        ) -> "InitProviderModel3.Builder": ...

        @overload
        def project_id_selector(
            self,
            value_or_callback: Callable[
                [ProjectIdSelector.Builder],
                ProjectIdSelector.Builder | ProjectIdSelector,
            ],
            /,
        ) -> "InitProviderModel3.Builder": ...

        @overload
        def project_id_selector(
            self, value_or_callback: Never = ...
        ) -> "ProjectIdSelector.BuilderContext": ...

        def project_id_selector(self, value_or_callback=None, /):
            """
            Selector for a Project in project to populate projectId.
            """
            if self._in_context and value_or_callback is None:
                context = ProjectIdSelector.BuilderContext()
                context._parent_builder = self
                context._field_name = "project_id_selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ProjectIdSelector.builder())
                if isinstance(output, ProjectIdSelector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("project_id_selector", value)

        def redirect_http_to_https(self, value: Optional[bool], /) -> Self:
            """
            A boolean value indicating whether
            HTTP requests to the Load Balancer on port 80 will be redirected to HTTPS on port 443.
            Default value is false.
            """
            return self._set("redirect_http_to_https", value)

        def region(self, value: Optional[str], /) -> Self:
            """
            The region to start in
            """
            return self._set("region", value)

        def size(self, value: Optional[str], /) -> Self:
            """
            The size of the Load Balancer. It must be either lb-small, lb-medium, or lb-large. Defaults to lb-small. Only one of size or size_unit may be provided.
            """
            return self._set("size", value)

        def size_unit(self, value: Optional[float], /) -> Self:
            """
            The size of the Load Balancer. It must be in the range (1, 100). Defaults to 1. Only one of size or size_unit may be provided.
            """
            return self._set("size_unit", value)

        @overload
        def sticky_sessions(
            self, value_or_callback: List[StickySession], /
        ) -> "InitProviderModel3.Builder": ...

        @overload
        def sticky_sessions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[StickySession, StickySession.Builder]],
                GenericListBuilder[StickySession, StickySession.Builder] | List[StickySession],
            ],
            /,
        ) -> "InitProviderModel3.Builder": ...

        @overload
        def sticky_sessions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[StickySession.Builder]: ...

        def sticky_sessions(self, value_or_callback=None, /):
            """
            A sticky_sessions block to be assigned to the
            Load Balancer. The sticky_sessions block is documented below. Only 1 sticky_sessions block is allowed.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[StickySession.Builder]()
                context._parent_builder = self
                context._field_name = "sticky_sessions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(StickySession.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("sticky_sessions", value)

        def target_load_balancer_ids(self, value: Optional[List[str]], /) -> Self:
            """
            A list of Load Balancer IDs to be attached behind a Global Load Balancer.
            NOTE: this is a closed beta feature and not available for public use.
            list of load balancer IDs to put behind a global load balancer
            """
            return self._set("target_load_balancer_ids", value)

        def type(self, value: Optional[str], /) -> Self:
            """
            The type of the Load Balancer. It must be either of REGIONAL or GLOBAL. Defaults to REGIONAL.
            NOTE: non-REGIONAL type may be part of closed beta feature and not available for public use.
            the type of the load balancer (GLOBAL or REGIONAL)
            """
            return self._set("type", value)

        def vpc_uuid(self, value: Optional[str], /) -> Self:
            """
            The ID of the VPC where the load balancer will be located.
            """
            return self._set("vpc_uuid", value)

        @overload
        def vpc_uuid_ref(
            self, value_or_callback: Optional[VpcUuidRef], /
        ) -> "InitProviderModel3.Builder": ...

        @overload
        def vpc_uuid_ref(
            self,
            value_or_callback: Callable[[VpcUuidRef.Builder], VpcUuidRef.Builder | VpcUuidRef],
            /,
        ) -> "InitProviderModel3.Builder": ...

        @overload
        def vpc_uuid_ref(self, value_or_callback: Never = ...) -> "VpcUuidRef.BuilderContext": ...

        def vpc_uuid_ref(self, value_or_callback=None, /):
            """
            Reference to a VPC in vpc to populate vpcUuid.
            """
            if self._in_context and value_or_callback is None:
                context = VpcUuidRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "vpc_uuid_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(VpcUuidRef.builder())
                if isinstance(output, VpcUuidRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("vpc_uuid_ref", value)

        @overload
        def vpc_uuid_selector(
            self, value_or_callback: Optional[VpcUuidSelector], /
        ) -> "InitProviderModel3.Builder": ...

        @overload
        def vpc_uuid_selector(
            self,
            value_or_callback: Callable[
                [VpcUuidSelector.Builder], VpcUuidSelector.Builder | VpcUuidSelector
            ],
            /,
        ) -> "InitProviderModel3.Builder": ...

        @overload
        def vpc_uuid_selector(
            self, value_or_callback: Never = ...
        ) -> "VpcUuidSelector.BuilderContext": ...

        def vpc_uuid_selector(self, value_or_callback=None, /):
            """
            Selector for a VPC in vpc to populate vpcUuid.
            """
            if self._in_context and value_or_callback is None:
                context = VpcUuidSelector.BuilderContext()
                context._parent_builder = self
                context._field_name = "vpc_uuid_selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(VpcUuidSelector.builder())
                if isinstance(output, VpcUuidSelector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("vpc_uuid_selector", value)

    class BuilderContext(BuilderContextBase["InitProviderModel3.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = InitProviderModel3.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for InitProviderModel3."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["InitProviderModel3", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use InitProviderModel3.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    algorithm: Optional[str] = None
    """
    Deprecated This field has been deprecated. You can no longer specify an algorithm for load balancers.
    or least_connections. The default value is round_robin.
    """
    disable_lets_encrypt_dns_records: Annotated[
        Optional[bool], Field(alias="disableLetsEncryptDnsRecords")
    ] = None
    """
    A boolean value indicating whether to disable automatic DNS record creation for Let's Encrypt certificates that are added to the load balancer. Default value is false.
    """
    domains: Optional[List[Domain]] = None
    """
    A list of domains required to ingress traffic to a Global Load Balancer. The domains block is documented below.
    NOTE: this is a closed beta feature and not available for public use.
    the list of domains required to ingress traffic to global load balancer
    """
    droplet_ids: Annotated[Optional[List[float]], Field(alias="dropletIds")] = None
    """
    A list of the IDs of each droplet to be attached to the Load Balancer.
    """
    droplet_ids_refs: Annotated[Optional[List[DropletIdsRef]], Field(alias="dropletIdsRefs")] = None
    """
    References to Droplet in droplet to populate dropletIds.
    """
    droplet_ids_selector: Annotated[
        Optional[DropletIdsSelector], Field(alias="dropletIdsSelector")
    ] = None
    """
    Selector for a list of Droplet in droplet to populate dropletIds.
    """
    droplet_tag: Annotated[Optional[str], Field(alias="dropletTag")] = None
    """
    The name of a Droplet tag corresponding to Droplets to be assigned to the Load Balancer.
    """
    enable_backend_keepalive: Annotated[Optional[bool], Field(alias="enableBackendKeepalive")] = (
        None
    )
    """
    A boolean value indicating whether HTTP keepalive connections are maintained to target Droplets. Default value is false.
    """
    enable_proxy_protocol: Annotated[Optional[bool], Field(alias="enableProxyProtocol")] = None
    """
    A boolean value indicating whether PROXY
    Protocol should be used to pass information from connecting client requests to
    the backend service. Default value is false.
    """
    firewall: Optional[List[Firewall]] = None
    """
    A block containing rules for allowing/denying traffic to the Load Balancer. The firewall block is documented below. Only 1 firewall is allowed.
    """
    forwarding_rule: Annotated[Optional[List[ForwardingRule]], Field(alias="forwardingRule")] = None
    """
    A list of forwarding_rule to be assigned to the
    Load Balancer. The forwarding_rule block is documented below.
    """
    glb_settings: Annotated[Optional[List[GlbSetting]], Field(alias="glbSettings")] = None
    """
    A block containing glb_settings required to define target rules for a Global Load Balancer. The glb_settings block is documented below.
    NOTE: this is a closed beta feature and not available for public use.
    configuration options for global load balancer
    """
    healthcheck: Optional[List[Healthcheck]] = None
    """
    A healthcheck block to be assigned to the
    Load Balancer. The healthcheck block is documented below. Only 1 healthcheck is allowed.
    """
    http_idle_timeout_seconds: Annotated[Optional[float], Field(alias="httpIdleTimeoutSeconds")] = (
        None
    )
    """
    Specifies the idle timeout for HTTPS connections on the load balancer in seconds.
    """
    name: Optional[str] = None
    """
    The Load Balancer name
    """
    network: Optional[str] = None
    """
    The type of network the Load Balancer is accessible from. It must be either of INTERNAL or EXTERNAL. Defaults to EXTERNAL.
    NOTE: non-EXTERNAL type may be part of closed beta feature and not available for public use.
    the type of network the load balancer is accessible from (EXTERNAL or INTERNAL)
    """
    project_id: Annotated[Optional[str], Field(alias="projectId")] = None
    """
    The ID of the project that the load balancer is associated with. If no ID is provided at creation, the load balancer associates with the user's default project.
    """
    project_id_ref: Annotated[Optional[ProjectIdRef], Field(alias="projectIdRef")] = None
    """
    Reference to a Project in project to populate projectId.
    """
    project_id_selector: Annotated[
        Optional[ProjectIdSelector], Field(alias="projectIdSelector")
    ] = None
    """
    Selector for a Project in project to populate projectId.
    """
    redirect_http_to_https: Annotated[Optional[bool], Field(alias="redirectHttpToHttps")] = None
    """
    A boolean value indicating whether
    HTTP requests to the Load Balancer on port 80 will be redirected to HTTPS on port 443.
    Default value is false.
    """
    region: Optional[str] = None
    """
    The region to start in
    """
    size: Optional[str] = None
    """
    The size of the Load Balancer. It must be either lb-small, lb-medium, or lb-large. Defaults to lb-small. Only one of size or size_unit may be provided.
    """
    size_unit: Annotated[Optional[float], Field(alias="sizeUnit")] = None
    """
    The size of the Load Balancer. It must be in the range (1, 100). Defaults to 1. Only one of size or size_unit may be provided.
    """
    sticky_sessions: Annotated[Optional[List[StickySession]], Field(alias="stickySessions")] = None
    """
    A sticky_sessions block to be assigned to the
    Load Balancer. The sticky_sessions block is documented below. Only 1 sticky_sessions block is allowed.
    """
    target_load_balancer_ids: Annotated[
        Optional[List[str]], Field(alias="targetLoadBalancerIds")
    ] = None
    """
    A list of Load Balancer IDs to be attached behind a Global Load Balancer.
    NOTE: this is a closed beta feature and not available for public use.
    list of load balancer IDs to put behind a global load balancer
    """
    type: Optional[str] = None
    """
    The type of the Load Balancer. It must be either of REGIONAL or GLOBAL. Defaults to REGIONAL.
    NOTE: non-REGIONAL type may be part of closed beta feature and not available for public use.
    the type of the load balancer (GLOBAL or REGIONAL)
    """
    vpc_uuid: Annotated[Optional[str], Field(alias="vpcUuid")] = None
    """
    The ID of the VPC where the load balancer will be located.
    """
    vpc_uuid_ref: Annotated[Optional[VpcUuidRef], Field(alias="vpcUuidRef")] = None
    """
    Reference to a VPC in vpc to populate vpcUuid.
    """
    vpc_uuid_selector: Annotated[Optional[VpcUuidSelector], Field(alias="vpcUuidSelector")] = None
    """
    Selector for a VPC in vpc to populate vpcUuid.
    """


class LoadbalancerSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["LoadbalancerSpec"]:
            return LoadbalancerSpec

        def build(self) -> "LoadbalancerSpec":
            return LoadbalancerSpec(**self._attrs)

        def deletion_policy(self, value: Optional[Literal["Orphan", "Delete"]], /) -> Self:
            """
            DeletionPolicy specifies what will happen to the underlying external
            when this managed resource is deleted - either "Delete" or "Orphan" the
            external resource.
            This field is planned to be deprecated in favor of the ManagementPolicies
            field in a future release. Currently, both could be set independently and
            non-default values would be honored if the feature flag is enabled.
            See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
            """
            return self._set("deletion_policy", value)

        @overload
        def for_provider(
            self, value_or_callback: ForProviderModel3, /
        ) -> "LoadbalancerSpec.Builder": ...

        @overload
        def for_provider(
            self,
            value_or_callback: Callable[
                [ForProviderModel3.Builder],
                ForProviderModel3.Builder | ForProviderModel3,
            ],
            /,
        ) -> "LoadbalancerSpec.Builder": ...

        @overload
        def for_provider(
            self, value_or_callback: Never = ...
        ) -> "ForProviderModel3.BuilderContext": ...

        def for_provider(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ForProviderModel3.BuilderContext()
                context._parent_builder = self
                context._field_name = "for_provider"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ForProviderModel3.builder())
                if isinstance(output, ForProviderModel3.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("for_provider", value)

        @overload
        def init_provider(
            self, value_or_callback: Optional[InitProviderModel3], /
        ) -> "LoadbalancerSpec.Builder": ...

        @overload
        def init_provider(
            self,
            value_or_callback: Callable[
                [InitProviderModel3.Builder],
                InitProviderModel3.Builder | InitProviderModel3,
            ],
            /,
        ) -> "LoadbalancerSpec.Builder": ...

        @overload
        def init_provider(
            self, value_or_callback: Never = ...
        ) -> "InitProviderModel3.BuilderContext": ...

        def init_provider(self, value_or_callback=None, /):
            """
            THIS IS A BETA FIELD. It will be honored
            unless the Management Policies feature flag is disabled.
            InitProvider holds the same fields as ForProvider, with the exception
            of Identifier and other resource reference fields. The fields that are
            in InitProvider are merged into ForProvider when the resource is created.
            The same fields are also added to the terraform ignore_changes hook, to
            avoid updating them after creation. This is useful for fields that are
            required on creation, but we do not desire to update them after creation,
            for example because of an external controller is managing them, like an
            autoscaler.
            """
            if self._in_context and value_or_callback is None:
                context = InitProviderModel3.BuilderContext()
                context._parent_builder = self
                context._field_name = "init_provider"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(InitProviderModel3.builder())
                if isinstance(output, InitProviderModel3.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("init_provider", value)

        def management_policies(
            self,
            value: Optional[
                List[Literal["Observe", "Create", "Update", "Delete", "LateInitialize", "*"]]
            ],
            /,
        ) -> Self:
            """
            THIS IS A BETA FIELD. It is on by default but can be opted out
            through a Crossplane feature flag.
            ManagementPolicies specify the array of actions Crossplane is allowed to
            take on the managed and external resources.
            This field is planned to replace the DeletionPolicy field in a future
            release. Currently, both could be set independently and non-default
            values would be honored if the feature flag is enabled. If both are
            custom, the DeletionPolicy field will be ignored.
            See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
            and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
            """
            return self._set("management_policies", value)

        @overload
        def provider_config_ref(
            self, value_or_callback: Optional[ProviderConfigRef], /
        ) -> "LoadbalancerSpec.Builder": ...

        @overload
        def provider_config_ref(
            self,
            value_or_callback: Callable[
                [ProviderConfigRef.Builder],
                ProviderConfigRef.Builder | ProviderConfigRef,
            ],
            /,
        ) -> "LoadbalancerSpec.Builder": ...

        @overload
        def provider_config_ref(
            self, value_or_callback: Never = ...
        ) -> "ProviderConfigRef.BuilderContext": ...

        def provider_config_ref(self, value_or_callback=None, /):
            """
            ProviderConfigReference specifies how the provider that will be used to
            create, observe, update, and delete this managed resource should be
            configured.
            """
            if self._in_context and value_or_callback is None:
                context = ProviderConfigRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "provider_config_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ProviderConfigRef.builder())
                if isinstance(output, ProviderConfigRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("provider_config_ref", value)

        @overload
        def publish_connection_details_to(
            self, value_or_callback: Optional[PublishConnectionDetailsTo], /
        ) -> "LoadbalancerSpec.Builder": ...

        @overload
        def publish_connection_details_to(
            self,
            value_or_callback: Callable[
                [PublishConnectionDetailsTo.Builder],
                PublishConnectionDetailsTo.Builder | PublishConnectionDetailsTo,
            ],
            /,
        ) -> "LoadbalancerSpec.Builder": ...

        @overload
        def publish_connection_details_to(
            self, value_or_callback: Never = ...
        ) -> "PublishConnectionDetailsTo.BuilderContext": ...

        def publish_connection_details_to(self, value_or_callback=None, /):
            """
            PublishConnectionDetailsTo specifies the connection secret config which
            contains a name, metadata and a reference to secret store config to
            which any connection details for this managed resource should be written.
            Connection details frequently include the endpoint, username,
            and password required to connect to the managed resource.
            """
            if self._in_context and value_or_callback is None:
                context = PublishConnectionDetailsTo.BuilderContext()
                context._parent_builder = self
                context._field_name = "publish_connection_details_to"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PublishConnectionDetailsTo.builder())
                if isinstance(output, PublishConnectionDetailsTo.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("publish_connection_details_to", value)

        @overload
        def write_connection_secret_to_ref(
            self, value_or_callback: Optional[WriteConnectionSecretToRef], /
        ) -> "LoadbalancerSpec.Builder": ...

        @overload
        def write_connection_secret_to_ref(
            self,
            value_or_callback: Callable[
                [WriteConnectionSecretToRef.Builder],
                WriteConnectionSecretToRef.Builder | WriteConnectionSecretToRef,
            ],
            /,
        ) -> "LoadbalancerSpec.Builder": ...

        @overload
        def write_connection_secret_to_ref(
            self, value_or_callback: Never = ...
        ) -> "WriteConnectionSecretToRef.BuilderContext": ...

        def write_connection_secret_to_ref(self, value_or_callback=None, /):
            """
            WriteConnectionSecretToReference specifies the namespace and name of a
            Secret to which any connection details for this managed resource should
            be written. Connection details frequently include the endpoint, username,
            and password required to connect to the managed resource.
            This field is planned to be replaced in a future release in favor of
            PublishConnectionDetailsTo. Currently, both could be set independently
            and connection details would be published to both without affecting
            each other.
            """
            if self._in_context and value_or_callback is None:
                context = WriteConnectionSecretToRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "write_connection_secret_to_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(WriteConnectionSecretToRef.builder())
                if isinstance(output, WriteConnectionSecretToRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("write_connection_secret_to_ref", value)

    class BuilderContext(BuilderContextBase["LoadbalancerSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = LoadbalancerSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for LoadbalancerSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["LoadbalancerSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use LoadbalancerSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    deletion_policy: Annotated[
        Optional[Literal["Orphan", "Delete"]], Field(alias="deletionPolicy")
    ] = "Delete"
    """
    DeletionPolicy specifies what will happen to the underlying external
    when this managed resource is deleted - either "Delete" or "Orphan" the
    external resource.
    This field is planned to be deprecated in favor of the ManagementPolicies
    field in a future release. Currently, both could be set independently and
    non-default values would be honored if the feature flag is enabled.
    See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    """
    for_provider: Annotated[ForProviderModel3, Field(alias="forProvider")]
    init_provider: Annotated[Optional[InitProviderModel3], Field(alias="initProvider")] = None
    """
    THIS IS A BETA FIELD. It will be honored
    unless the Management Policies feature flag is disabled.
    InitProvider holds the same fields as ForProvider, with the exception
    of Identifier and other resource reference fields. The fields that are
    in InitProvider are merged into ForProvider when the resource is created.
    The same fields are also added to the terraform ignore_changes hook, to
    avoid updating them after creation. This is useful for fields that are
    required on creation, but we do not desire to update them after creation,
    for example because of an external controller is managing them, like an
    autoscaler.
    """
    management_policies: Annotated[
        Optional[List[Literal["Observe", "Create", "Update", "Delete", "LateInitialize", "*"]]],
        Field(alias="managementPolicies"),
    ] = ["*"]
    """
    THIS IS A BETA FIELD. It is on by default but can be opted out
    through a Crossplane feature flag.
    ManagementPolicies specify the array of actions Crossplane is allowed to
    take on the managed and external resources.
    This field is planned to replace the DeletionPolicy field in a future
    release. Currently, both could be set independently and non-default
    values would be honored if the feature flag is enabled. If both are
    custom, the DeletionPolicy field will be ignored.
    See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
    and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
    """
    provider_config_ref: Annotated[
        Optional[ProviderConfigRef],
        Field(
            default_factory=lambda: ProviderConfigRef.model_validate({"name": "default"}),
            alias="providerConfigRef",
        ),
    ] = {"name": "default"}
    """
    ProviderConfigReference specifies how the provider that will be used to
    create, observe, update, and delete this managed resource should be
    configured.
    """
    publish_connection_details_to: Annotated[
        Optional[PublishConnectionDetailsTo], Field(alias="publishConnectionDetailsTo")
    ] = None
    """
    PublishConnectionDetailsTo specifies the connection secret config which
    contains a name, metadata and a reference to secret store config to
    which any connection details for this managed resource should be written.
    Connection details frequently include the endpoint, username,
    and password required to connect to the managed resource.
    """
    write_connection_secret_to_ref: Annotated[
        Optional[WriteConnectionSecretToRef], Field(alias="writeConnectionSecretToRef")
    ] = None
    """
    WriteConnectionSecretToReference specifies the namespace and name of a
    Secret to which any connection details for this managed resource should
    be written. Connection details frequently include the endpoint, username,
    and password required to connect to the managed resource.
    This field is planned to be replaced in a future release in favor of
    PublishConnectionDetailsTo. Currently, both could be set independently
    and connection details would be published to both without affecting
    each other.
    """


class DomainModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["DomainModel"]:
            return DomainModel

        def build(self) -> "DomainModel":
            return DomainModel(**self._attrs)

        def certificate_name(self, value: Optional[str], /) -> Self:
            """
            The unique name of the TLS certificate to be used for SSL termination.
            name of certificate required for TLS handshaking
            """
            return self._set("certificate_name", value)

        def is_managed(self, value: Optional[bool], /) -> Self:
            """
            Control flag to specify whether the domain is managed by DigitalOcean.
            flag indicating if domain is managed by DigitalOcean
            """
            return self._set("is_managed", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            The Load Balancer name
            domain name
            """
            return self._set("name", value)

        def ssl_validation_error_reasons(self, value: Optional[List[str]], /) -> Self:
            """
            list of domain SSL validation errors
            """
            return self._set("ssl_validation_error_reasons", value)

        def verification_error_reasons(self, value: Optional[List[str]], /) -> Self:
            """
            list of domain verification errors
            """
            return self._set("verification_error_reasons", value)

    class BuilderContext(BuilderContextBase["DomainModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DomainModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DomainModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["DomainModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use DomainModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    certificate_name: Annotated[Optional[str], Field(alias="certificateName")] = None
    """
    The unique name of the TLS certificate to be used for SSL termination.
    name of certificate required for TLS handshaking
    """
    is_managed: Annotated[Optional[bool], Field(alias="isManaged")] = None
    """
    Control flag to specify whether the domain is managed by DigitalOcean.
    flag indicating if domain is managed by DigitalOcean
    """
    name: Optional[str] = None
    """
    The Load Balancer name
    domain name
    """
    ssl_validation_error_reasons: Annotated[
        Optional[List[str]], Field(alias="sslValidationErrorReasons")
    ] = None
    """
    list of domain SSL validation errors
    """
    verification_error_reasons: Annotated[
        Optional[List[str]], Field(alias="verificationErrorReasons")
    ] = None
    """
    list of domain verification errors
    """


class ForwardingRuleModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ForwardingRuleModel"]:
            return ForwardingRuleModel

        def build(self) -> "ForwardingRuleModel":
            return ForwardingRuleModel(**self._attrs)

        def certificate_id(self, value: Optional[str], /) -> Self:
            """
            Deprecated The ID of the TLS certificate to be used for SSL termination.
            """
            return self._set("certificate_id", value)

        def certificate_name(self, value: Optional[str], /) -> Self:
            """
            The unique name of the TLS certificate to be used for SSL termination.
            """
            return self._set("certificate_name", value)

        def entry_port(self, value: Optional[float], /) -> Self:
            """
            An integer representing the port on which the Load Balancer instance will listen.
            """
            return self._set("entry_port", value)

        def entry_protocol(self, value: Optional[str], /) -> Self:
            """
            The protocol used for traffic to the Load Balancer. The possible values are: http, https, http2, http3, tcp, or udp.
            """
            return self._set("entry_protocol", value)

        def target_port(self, value: Optional[float], /) -> Self:
            """
            An integer representing the port on the backend Droplets to which the Load Balancer will send traffic.
            """
            return self._set("target_port", value)

        def target_protocol(self, value: Optional[str], /) -> Self:
            """
            The protocol used for traffic from the Load Balancer to the backend Droplets. The possible values are: http, https, http2, tcp, or udp.
            """
            return self._set("target_protocol", value)

        def tls_passthrough(self, value: Optional[bool], /) -> Self:
            """
            A boolean value indicating whether SSL encrypted traffic will be passed through to the backend Droplets. The default value is false.
            """
            return self._set("tls_passthrough", value)

    class BuilderContext(BuilderContextBase["ForwardingRuleModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ForwardingRuleModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ForwardingRuleModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ForwardingRuleModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ForwardingRuleModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    certificate_id: Annotated[Optional[str], Field(alias="certificateId")] = None
    """
    Deprecated The ID of the TLS certificate to be used for SSL termination.
    """
    certificate_name: Annotated[Optional[str], Field(alias="certificateName")] = None
    """
    The unique name of the TLS certificate to be used for SSL termination.
    """
    entry_port: Annotated[Optional[float], Field(alias="entryPort")] = None
    """
    An integer representing the port on which the Load Balancer instance will listen.
    """
    entry_protocol: Annotated[Optional[str], Field(alias="entryProtocol")] = None
    """
    The protocol used for traffic to the Load Balancer. The possible values are: http, https, http2, http3, tcp, or udp.
    """
    target_port: Annotated[Optional[float], Field(alias="targetPort")] = None
    """
    An integer representing the port on the backend Droplets to which the Load Balancer will send traffic.
    """
    target_protocol: Annotated[Optional[str], Field(alias="targetProtocol")] = None
    """
    The protocol used for traffic from the Load Balancer to the backend Droplets. The possible values are: http, https, http2, tcp, or udp.
    """
    tls_passthrough: Annotated[Optional[bool], Field(alias="tlsPassthrough")] = None
    """
    A boolean value indicating whether SSL encrypted traffic will be passed through to the backend Droplets. The default value is false.
    """


class AtProviderModel3(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AtProviderModel3"]:
            return AtProviderModel3

        def build(self) -> "AtProviderModel3":
            return AtProviderModel3(**self._attrs)

        def algorithm(self, value: Optional[str], /) -> Self:
            """
            Deprecated This field has been deprecated. You can no longer specify an algorithm for load balancers.
            or least_connections. The default value is round_robin.
            """
            return self._set("algorithm", value)

        def disable_lets_encrypt_dns_records(self, value: Optional[bool], /) -> Self:
            """
            A boolean value indicating whether to disable automatic DNS record creation for Let's Encrypt certificates that are added to the load balancer. Default value is false.
            """
            return self._set("disable_lets_encrypt_dns_records", value)

        @overload
        def domains(
            self, value_or_callback: List[DomainModel], /
        ) -> "AtProviderModel3.Builder": ...

        @overload
        def domains(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[DomainModel, DomainModel.Builder]],
                GenericListBuilder[DomainModel, DomainModel.Builder] | List[DomainModel],
            ],
            /,
        ) -> "AtProviderModel3.Builder": ...

        @overload
        def domains(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[DomainModel.Builder]: ...

        def domains(self, value_or_callback=None, /):
            """
            A list of domains required to ingress traffic to a Global Load Balancer. The domains block is documented below.
            NOTE: this is a closed beta feature and not available for public use.
            the list of domains required to ingress traffic to global load balancer
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[DomainModel.Builder]()
                context._parent_builder = self
                context._field_name = "domains"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(DomainModel.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("domains", value)

        def droplet_ids(self, value: Optional[List[float]], /) -> Self:
            """
            A list of the IDs of each droplet to be attached to the Load Balancer.
            """
            return self._set("droplet_ids", value)

        def droplet_tag(self, value: Optional[str], /) -> Self:
            """
            The name of a Droplet tag corresponding to Droplets to be assigned to the Load Balancer.
            """
            return self._set("droplet_tag", value)

        def enable_backend_keepalive(self, value: Optional[bool], /) -> Self:
            """
            A boolean value indicating whether HTTP keepalive connections are maintained to target Droplets. Default value is false.
            """
            return self._set("enable_backend_keepalive", value)

        def enable_proxy_protocol(self, value: Optional[bool], /) -> Self:
            """
            A boolean value indicating whether PROXY
            Protocol should be used to pass information from connecting client requests to
            the backend service. Default value is false.
            """
            return self._set("enable_proxy_protocol", value)

        @overload
        def firewall(self, value_or_callback: List[Firewall], /) -> "AtProviderModel3.Builder": ...

        @overload
        def firewall(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Firewall, Firewall.Builder]],
                GenericListBuilder[Firewall, Firewall.Builder] | List[Firewall],
            ],
            /,
        ) -> "AtProviderModel3.Builder": ...

        @overload
        def firewall(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Firewall.Builder]: ...

        def firewall(self, value_or_callback=None, /):
            """
            A block containing rules for allowing/denying traffic to the Load Balancer. The firewall block is documented below. Only 1 firewall is allowed.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Firewall.Builder]()
                context._parent_builder = self
                context._field_name = "firewall"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Firewall.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("firewall", value)

        @overload
        def forwarding_rule(
            self, value_or_callback: List[ForwardingRuleModel], /
        ) -> "AtProviderModel3.Builder": ...

        @overload
        def forwarding_rule(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[ForwardingRuleModel, ForwardingRuleModel.Builder]],
                GenericListBuilder[ForwardingRuleModel, ForwardingRuleModel.Builder]
                | List[ForwardingRuleModel],
            ],
            /,
        ) -> "AtProviderModel3.Builder": ...

        @overload
        def forwarding_rule(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ForwardingRuleModel.Builder]: ...

        def forwarding_rule(self, value_or_callback=None, /):
            """
            A list of forwarding_rule to be assigned to the
            Load Balancer. The forwarding_rule block is documented below.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ForwardingRuleModel.Builder]()
                context._parent_builder = self
                context._field_name = "forwarding_rule"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ForwardingRuleModel.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("forwarding_rule", value)

        @overload
        def glb_settings(
            self, value_or_callback: List[GlbSetting], /
        ) -> "AtProviderModel3.Builder": ...

        @overload
        def glb_settings(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[GlbSetting, GlbSetting.Builder]],
                GenericListBuilder[GlbSetting, GlbSetting.Builder] | List[GlbSetting],
            ],
            /,
        ) -> "AtProviderModel3.Builder": ...

        @overload
        def glb_settings(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[GlbSetting.Builder]: ...

        def glb_settings(self, value_or_callback=None, /):
            """
            A block containing glb_settings required to define target rules for a Global Load Balancer. The glb_settings block is documented below.
            NOTE: this is a closed beta feature and not available for public use.
            configuration options for global load balancer
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[GlbSetting.Builder]()
                context._parent_builder = self
                context._field_name = "glb_settings"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(GlbSetting.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("glb_settings", value)

        @overload
        def healthcheck(
            self, value_or_callback: List[Healthcheck], /
        ) -> "AtProviderModel3.Builder": ...

        @overload
        def healthcheck(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Healthcheck, Healthcheck.Builder]],
                GenericListBuilder[Healthcheck, Healthcheck.Builder] | List[Healthcheck],
            ],
            /,
        ) -> "AtProviderModel3.Builder": ...

        @overload
        def healthcheck(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Healthcheck.Builder]: ...

        def healthcheck(self, value_or_callback=None, /):
            """
            A healthcheck block to be assigned to the
            Load Balancer. The healthcheck block is documented below. Only 1 healthcheck is allowed.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Healthcheck.Builder]()
                context._parent_builder = self
                context._field_name = "healthcheck"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Healthcheck.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("healthcheck", value)

        def http_idle_timeout_seconds(self, value: Optional[float], /) -> Self:
            """
            Specifies the idle timeout for HTTPS connections on the load balancer in seconds.
            """
            return self._set("http_idle_timeout_seconds", value)

        def id(self, value: Optional[str], /) -> Self:
            """
            The ID of the Load Balancer
            """
            return self._set("id", value)

        def ip(self, value: Optional[str], /) -> Self:
            """
            The ip of the Load Balancer
            """
            return self._set("ip", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            The Load Balancer name
            """
            return self._set("name", value)

        def network(self, value: Optional[str], /) -> Self:
            """
            The type of network the Load Balancer is accessible from. It must be either of INTERNAL or EXTERNAL. Defaults to EXTERNAL.
            NOTE: non-EXTERNAL type may be part of closed beta feature and not available for public use.
            the type of network the load balancer is accessible from (EXTERNAL or INTERNAL)
            """
            return self._set("network", value)

        def project_id(self, value: Optional[str], /) -> Self:
            """
            The ID of the project that the load balancer is associated with. If no ID is provided at creation, the load balancer associates with the user's default project.
            """
            return self._set("project_id", value)

        def redirect_http_to_https(self, value: Optional[bool], /) -> Self:
            """
            A boolean value indicating whether
            HTTP requests to the Load Balancer on port 80 will be redirected to HTTPS on port 443.
            Default value is false.
            """
            return self._set("redirect_http_to_https", value)

        def region(self, value: Optional[str], /) -> Self:
            """
            The region to start in
            """
            return self._set("region", value)

        def size(self, value: Optional[str], /) -> Self:
            """
            The size of the Load Balancer. It must be either lb-small, lb-medium, or lb-large. Defaults to lb-small. Only one of size or size_unit may be provided.
            """
            return self._set("size", value)

        def size_unit(self, value: Optional[float], /) -> Self:
            """
            The size of the Load Balancer. It must be in the range (1, 100). Defaults to 1. Only one of size or size_unit may be provided.
            """
            return self._set("size_unit", value)

        def status(self, value: Optional[str], /) -> Self:
            return self._set("status", value)

        @overload
        def sticky_sessions(
            self, value_or_callback: List[StickySession], /
        ) -> "AtProviderModel3.Builder": ...

        @overload
        def sticky_sessions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[StickySession, StickySession.Builder]],
                GenericListBuilder[StickySession, StickySession.Builder] | List[StickySession],
            ],
            /,
        ) -> "AtProviderModel3.Builder": ...

        @overload
        def sticky_sessions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[StickySession.Builder]: ...

        def sticky_sessions(self, value_or_callback=None, /):
            """
            A sticky_sessions block to be assigned to the
            Load Balancer. The sticky_sessions block is documented below. Only 1 sticky_sessions block is allowed.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[StickySession.Builder]()
                context._parent_builder = self
                context._field_name = "sticky_sessions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(StickySession.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("sticky_sessions", value)

        def target_load_balancer_ids(self, value: Optional[List[str]], /) -> Self:
            """
            A list of Load Balancer IDs to be attached behind a Global Load Balancer.
            NOTE: this is a closed beta feature and not available for public use.
            list of load balancer IDs to put behind a global load balancer
            """
            return self._set("target_load_balancer_ids", value)

        def type(self, value: Optional[str], /) -> Self:
            """
            The type of the Load Balancer. It must be either of REGIONAL or GLOBAL. Defaults to REGIONAL.
            NOTE: non-REGIONAL type may be part of closed beta feature and not available for public use.
            the type of the load balancer (GLOBAL or REGIONAL)
            """
            return self._set("type", value)

        def urn(self, value: Optional[str], /) -> Self:
            """
            The uniform resource name for the Load Balancer
            the uniform resource name for the load balancer
            """
            return self._set("urn", value)

        def vpc_uuid(self, value: Optional[str], /) -> Self:
            """
            The ID of the VPC where the load balancer will be located.
            """
            return self._set("vpc_uuid", value)

    class BuilderContext(BuilderContextBase["AtProviderModel3.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AtProviderModel3.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AtProviderModel3."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AtProviderModel3", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AtProviderModel3.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    algorithm: Optional[str] = None
    """
    Deprecated This field has been deprecated. You can no longer specify an algorithm for load balancers.
    or least_connections. The default value is round_robin.
    """
    disable_lets_encrypt_dns_records: Annotated[
        Optional[bool], Field(alias="disableLetsEncryptDnsRecords")
    ] = None
    """
    A boolean value indicating whether to disable automatic DNS record creation for Let's Encrypt certificates that are added to the load balancer. Default value is false.
    """
    domains: Optional[List[DomainModel]] = None
    """
    A list of domains required to ingress traffic to a Global Load Balancer. The domains block is documented below.
    NOTE: this is a closed beta feature and not available for public use.
    the list of domains required to ingress traffic to global load balancer
    """
    droplet_ids: Annotated[Optional[List[float]], Field(alias="dropletIds")] = None
    """
    A list of the IDs of each droplet to be attached to the Load Balancer.
    """
    droplet_tag: Annotated[Optional[str], Field(alias="dropletTag")] = None
    """
    The name of a Droplet tag corresponding to Droplets to be assigned to the Load Balancer.
    """
    enable_backend_keepalive: Annotated[Optional[bool], Field(alias="enableBackendKeepalive")] = (
        None
    )
    """
    A boolean value indicating whether HTTP keepalive connections are maintained to target Droplets. Default value is false.
    """
    enable_proxy_protocol: Annotated[Optional[bool], Field(alias="enableProxyProtocol")] = None
    """
    A boolean value indicating whether PROXY
    Protocol should be used to pass information from connecting client requests to
    the backend service. Default value is false.
    """
    firewall: Optional[List[Firewall]] = None
    """
    A block containing rules for allowing/denying traffic to the Load Balancer. The firewall block is documented below. Only 1 firewall is allowed.
    """
    forwarding_rule: Annotated[
        Optional[List[ForwardingRuleModel]], Field(alias="forwardingRule")
    ] = None
    """
    A list of forwarding_rule to be assigned to the
    Load Balancer. The forwarding_rule block is documented below.
    """
    glb_settings: Annotated[Optional[List[GlbSetting]], Field(alias="glbSettings")] = None
    """
    A block containing glb_settings required to define target rules for a Global Load Balancer. The glb_settings block is documented below.
    NOTE: this is a closed beta feature and not available for public use.
    configuration options for global load balancer
    """
    healthcheck: Optional[List[Healthcheck]] = None
    """
    A healthcheck block to be assigned to the
    Load Balancer. The healthcheck block is documented below. Only 1 healthcheck is allowed.
    """
    http_idle_timeout_seconds: Annotated[Optional[float], Field(alias="httpIdleTimeoutSeconds")] = (
        None
    )
    """
    Specifies the idle timeout for HTTPS connections on the load balancer in seconds.
    """
    id: Optional[str] = None
    """
    The ID of the Load Balancer
    """
    ip: Optional[str] = None
    """
    The ip of the Load Balancer
    """
    name: Optional[str] = None
    """
    The Load Balancer name
    """
    network: Optional[str] = None
    """
    The type of network the Load Balancer is accessible from. It must be either of INTERNAL or EXTERNAL. Defaults to EXTERNAL.
    NOTE: non-EXTERNAL type may be part of closed beta feature and not available for public use.
    the type of network the load balancer is accessible from (EXTERNAL or INTERNAL)
    """
    project_id: Annotated[Optional[str], Field(alias="projectId")] = None
    """
    The ID of the project that the load balancer is associated with. If no ID is provided at creation, the load balancer associates with the user's default project.
    """
    redirect_http_to_https: Annotated[Optional[bool], Field(alias="redirectHttpToHttps")] = None
    """
    A boolean value indicating whether
    HTTP requests to the Load Balancer on port 80 will be redirected to HTTPS on port 443.
    Default value is false.
    """
    region: Optional[str] = None
    """
    The region to start in
    """
    size: Optional[str] = None
    """
    The size of the Load Balancer. It must be either lb-small, lb-medium, or lb-large. Defaults to lb-small. Only one of size or size_unit may be provided.
    """
    size_unit: Annotated[Optional[float], Field(alias="sizeUnit")] = None
    """
    The size of the Load Balancer. It must be in the range (1, 100). Defaults to 1. Only one of size or size_unit may be provided.
    """
    status: Optional[str] = None
    sticky_sessions: Annotated[Optional[List[StickySession]], Field(alias="stickySessions")] = None
    """
    A sticky_sessions block to be assigned to the
    Load Balancer. The sticky_sessions block is documented below. Only 1 sticky_sessions block is allowed.
    """
    target_load_balancer_ids: Annotated[
        Optional[List[str]], Field(alias="targetLoadBalancerIds")
    ] = None
    """
    A list of Load Balancer IDs to be attached behind a Global Load Balancer.
    NOTE: this is a closed beta feature and not available for public use.
    list of load balancer IDs to put behind a global load balancer
    """
    type: Optional[str] = None
    """
    The type of the Load Balancer. It must be either of REGIONAL or GLOBAL. Defaults to REGIONAL.
    NOTE: non-REGIONAL type may be part of closed beta feature and not available for public use.
    the type of the load balancer (GLOBAL or REGIONAL)
    """
    urn: Optional[str] = None
    """
    The uniform resource name for the Load Balancer
    the uniform resource name for the load balancer
    """
    vpc_uuid: Annotated[Optional[str], Field(alias="vpcUuid")] = None
    """
    The ID of the VPC where the load balancer will be located.
    """


class LoadbalancerStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["LoadbalancerStatus"]:
            return LoadbalancerStatus

        def build(self) -> "LoadbalancerStatus":
            return LoadbalancerStatus(**self._attrs)

        @overload
        def at_provider(
            self, value_or_callback: Optional[AtProviderModel3], /
        ) -> "LoadbalancerStatus.Builder": ...

        @overload
        def at_provider(
            self,
            value_or_callback: Callable[
                [AtProviderModel3.Builder], AtProviderModel3.Builder | AtProviderModel3
            ],
            /,
        ) -> "LoadbalancerStatus.Builder": ...

        @overload
        def at_provider(
            self, value_or_callback: Never = ...
        ) -> "AtProviderModel3.BuilderContext": ...

        def at_provider(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = AtProviderModel3.BuilderContext()
                context._parent_builder = self
                context._field_name = "at_provider"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AtProviderModel3.builder())
                if isinstance(output, AtProviderModel3.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("at_provider", value)

        @overload
        def conditions(
            self, value_or_callback: List[Condition], /
        ) -> "LoadbalancerStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Condition, Condition.Builder]],
                GenericListBuilder[Condition, Condition.Builder] | List[Condition],
            ],
            /,
        ) -> "LoadbalancerStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            """
            Conditions of the resource.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        def observed_generation(self, value: Optional[int], /) -> Self:
            """
            ObservedGeneration is the latest metadata.generation
            which resulted in either a ready state, or stalled due to error
            it can not recover from without human intervention.
            """
            return self._set("observed_generation", value)

    class BuilderContext(BuilderContextBase["LoadbalancerStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = LoadbalancerStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for LoadbalancerStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["LoadbalancerStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use LoadbalancerStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    at_provider: Annotated[Optional[AtProviderModel3], Field(alias="atProvider")] = None
    conditions: Optional[List[Condition]] = None
    """
    Conditions of the resource.
    """
    observed_generation: Annotated[Optional[int], Field(alias="observedGeneration")] = None
    """
    ObservedGeneration is the latest metadata.generation
    which resulted in either a ready state, or stalled due to error
    it can not recover from without human intervention.
    """


class Certificate(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Certificate"]:
            return Certificate

        def build(self) -> "Certificate":
            return Certificate(**self._attrs)

        def api_version(
            self,
            value: Optional[Literal["networking.digitalocean.crossplane.io/v1alpha1"]],
            /,
        ) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["Certificate"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "Certificate.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "Certificate.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(self, value_or_callback: CertificateSpec, /) -> "Certificate.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [CertificateSpec.Builder], CertificateSpec.Builder | CertificateSpec
            ],
            /,
        ) -> "Certificate.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "CertificateSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = CertificateSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(CertificateSpec.builder())
                if isinstance(output, CertificateSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(
            self, value_or_callback: Optional[CertificateStatus], /
        ) -> "Certificate.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [CertificateStatus.Builder],
                CertificateStatus.Builder | CertificateStatus,
            ],
            /,
        ) -> "Certificate.Builder": ...

        @overload
        def status(self, value_or_callback: Never = ...) -> "CertificateStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = CertificateStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(CertificateStatus.builder())
                if isinstance(output, CertificateStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["Certificate.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Certificate.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Certificate."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Certificate", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Certificate.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[
        Optional[Literal["networking.digitalocean.crossplane.io/v1alpha1"]],
        Field(alias="apiVersion"),
    ] = "networking.digitalocean.crossplane.io/v1alpha1"
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["Certificate"]] = "Certificate"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: CertificateSpec
    status: Optional[CertificateStatus] = None


class FirewallModel(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["FirewallModel"]:
            return FirewallModel

        def build(self) -> "FirewallModel":
            return FirewallModel(**self._attrs)

        def api_version(
            self,
            value: Optional[Literal["networking.digitalocean.crossplane.io/v1alpha1"]],
            /,
        ) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["Firewall"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "FirewallModel.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "FirewallModel.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(self, value_or_callback: FirewallSpec, /) -> "FirewallModel.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [FirewallSpec.Builder], FirewallSpec.Builder | FirewallSpec
            ],
            /,
        ) -> "FirewallModel.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "FirewallSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = FirewallSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(FirewallSpec.builder())
                if isinstance(output, FirewallSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(
            self, value_or_callback: Optional[FirewallStatus], /
        ) -> "FirewallModel.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [FirewallStatus.Builder], FirewallStatus.Builder | FirewallStatus
            ],
            /,
        ) -> "FirewallModel.Builder": ...

        @overload
        def status(self, value_or_callback: Never = ...) -> "FirewallStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = FirewallStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(FirewallStatus.builder())
                if isinstance(output, FirewallStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["FirewallModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = FirewallModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for FirewallModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["FirewallModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use FirewallModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[
        Optional[Literal["networking.digitalocean.crossplane.io/v1alpha1"]],
        Field(alias="apiVersion"),
    ] = "networking.digitalocean.crossplane.io/v1alpha1"
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["Firewall"]] = "Firewall"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: FirewallSpec
    status: Optional[FirewallStatus] = None


class IPAssignment(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["IPAssignment"]:
            return IPAssignment

        def build(self) -> "IPAssignment":
            return IPAssignment(**self._attrs)

        def api_version(
            self,
            value: Optional[Literal["networking.digitalocean.crossplane.io/v1alpha1"]],
            /,
        ) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["IPAssignment"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "IPAssignment.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "IPAssignment.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(self, value_or_callback: IPAssignmentSpec, /) -> "IPAssignment.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [IPAssignmentSpec.Builder], IPAssignmentSpec.Builder | IPAssignmentSpec
            ],
            /,
        ) -> "IPAssignment.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "IPAssignmentSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = IPAssignmentSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(IPAssignmentSpec.builder())
                if isinstance(output, IPAssignmentSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(
            self, value_or_callback: Optional[IPAssignmentStatus], /
        ) -> "IPAssignment.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [IPAssignmentStatus.Builder],
                IPAssignmentStatus.Builder | IPAssignmentStatus,
            ],
            /,
        ) -> "IPAssignment.Builder": ...

        @overload
        def status(self, value_or_callback: Never = ...) -> "IPAssignmentStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = IPAssignmentStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(IPAssignmentStatus.builder())
                if isinstance(output, IPAssignmentStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["IPAssignment.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = IPAssignment.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for IPAssignment."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["IPAssignment", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use IPAssignment.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[
        Optional[Literal["networking.digitalocean.crossplane.io/v1alpha1"]],
        Field(alias="apiVersion"),
    ] = "networking.digitalocean.crossplane.io/v1alpha1"
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["IPAssignment"]] = "IPAssignment"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: IPAssignmentSpec
    status: Optional[IPAssignmentStatus] = None


class IP(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["IP"]:
            return IP

        def build(self) -> "IP":
            return IP(**self._attrs)

        def api_version(
            self,
            value: Optional[Literal["networking.digitalocean.crossplane.io/v1alpha1"]],
            /,
        ) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["IP"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "IP.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "IP.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(self, value_or_callback: IPSpec, /) -> "IP.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[[IPSpec.Builder], IPSpec.Builder | IPSpec],
            /,
        ) -> "IP.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "IPSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = IPSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(IPSpec.builder())
                if isinstance(output, IPSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(self, value_or_callback: Optional[IPStatus], /) -> "IP.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[[IPStatus.Builder], IPStatus.Builder | IPStatus],
            /,
        ) -> "IP.Builder": ...

        @overload
        def status(self, value_or_callback: Never = ...) -> "IPStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = IPStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(IPStatus.builder())
                if isinstance(output, IPStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["IP.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = IP.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for IP."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["IP", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use IP.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[
        Optional[Literal["networking.digitalocean.crossplane.io/v1alpha1"]],
        Field(alias="apiVersion"),
    ] = "networking.digitalocean.crossplane.io/v1alpha1"
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["IP"]] = "IP"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: IPSpec
    status: Optional[IPStatus] = None


class Loadbalancer(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Loadbalancer"]:
            return Loadbalancer

        def build(self) -> "Loadbalancer":
            return Loadbalancer(**self._attrs)

        def api_version(
            self,
            value: Optional[Literal["networking.digitalocean.crossplane.io/v1alpha1"]],
            /,
        ) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["Loadbalancer"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "Loadbalancer.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "Loadbalancer.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(self, value_or_callback: LoadbalancerSpec, /) -> "Loadbalancer.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [LoadbalancerSpec.Builder], LoadbalancerSpec.Builder | LoadbalancerSpec
            ],
            /,
        ) -> "Loadbalancer.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "LoadbalancerSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = LoadbalancerSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(LoadbalancerSpec.builder())
                if isinstance(output, LoadbalancerSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(
            self, value_or_callback: Optional[LoadbalancerStatus], /
        ) -> "Loadbalancer.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [LoadbalancerStatus.Builder],
                LoadbalancerStatus.Builder | LoadbalancerStatus,
            ],
            /,
        ) -> "Loadbalancer.Builder": ...

        @overload
        def status(self, value_or_callback: Never = ...) -> "LoadbalancerStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = LoadbalancerStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(LoadbalancerStatus.builder())
                if isinstance(output, LoadbalancerStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["Loadbalancer.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Loadbalancer.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Loadbalancer."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Loadbalancer", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Loadbalancer.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[
        Optional[Literal["networking.digitalocean.crossplane.io/v1alpha1"]],
        Field(alias="apiVersion"),
    ] = "networking.digitalocean.crossplane.io/v1alpha1"
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["Loadbalancer"]] = "Loadbalancer"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: LoadbalancerSpec
    status: Optional[LoadbalancerStatus] = None
