This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
schemas/
  crds/
    cert-manager/
      crds/
        Kptfile
        README.md
      Kptfile
      README.md
    crossplane/
      Kptfile
    crossplane-kcl-function/
      Kptfile
    crossplane-patch-and-transform/
      Kptfile
    crossplane-sequencer/
      Kptfile
    digitalocean/
      Kptfile
    fluxcd-helm/
      Kptfile
    fluxcd-kustomize/
      Kptfile
    fluxcd-source/
      Kptfile
    BUCK
    crd_codegen_groups.bzl
src/
  codegen/
    cloudcoil/
      templates/
        BaseModel.jinja2
        ConfigDict.jinja2
        RootModel.jinja2
      BUCK
      main.py
      python_codegen_rule.bzl
    go-schema-kcl/
      go.mod
      gomod2nix.toml
      main.go
  lib/
    BUCK
    main.py
tests/
  tests/
    test_basic.py
  BUCK
  conftest.py
  run_pytest.py
toolchains/
  BUCK
  flake.lock
  flake.nix
  gomod2nix.nix
  uv2nix.nix
.buckconfig
.gitignore
flake.nix
notes
pytest.ini
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/codegen/go-schema-kcl/go.mod">
module github.com/becker63/home/src/codegen/go-schema-kcl

go 1.25.4

require (
	github.com/fatedier/frp v0.65.0
	github.com/invopop/jsonschema v0.13.0
)

require (
	github.com/bahlo/generic-list-go v0.2.0 // indirect
	github.com/buger/jsonparser v1.1.1 // indirect
	github.com/fatedier/golib v0.5.1 // indirect
	github.com/kr/text v0.2.0 // indirect
	github.com/mailru/easyjson v0.7.7 // indirect
	github.com/samber/lo v1.47.0 // indirect
	github.com/wk8/go-ordered-map/v2 v2.1.8 // indirect
	golang.org/x/text v0.24.0 // indirect
	gopkg.in/yaml.v3 v3.0.1 // indirect
)
</file>

<file path="src/codegen/go-schema-kcl/gomod2nix.toml">
schema = 3

[mod]
  [mod."github.com/bahlo/generic-list-go"]
    version = "v0.2.0"
    hash = "sha256-BIzqwG61hnMDknZOn/5+VX09yemzFzMjhPF48XoALto="
  [mod."github.com/buger/jsonparser"]
    version = "v1.1.1"
    hash = "sha256-T6dXT6Vzpm8gvQYi+c2LZkV+8ZOp0ZXBX7+e1mlliZE="
  [mod."github.com/fatedier/frp"]
    version = "v0.65.0"
    hash = "sha256-otzzBBd/XABe+h7nZIw0kUsgZgX2XRo4+Tx7Fq/64ro="
  [mod."github.com/fatedier/golib"]
    version = "v0.5.1"
    hash = "sha256-EWkKkk7SFeo3sdK+5ngsJS8vupWWcxmG85B5HOA2jKY="
  [mod."github.com/invopop/jsonschema"]
    version = "v0.13.0"
    hash = "sha256-Fe4DQDJQxy5i8cgJY6dFbraTnfG/C2D3cB1Q5p2QxVc="
  [mod."github.com/kr/text"]
    version = "v0.2.0"
    hash = "sha256-fadcWxZOORv44oak3jTxm6YcITcFxdGt4bpn869HxUE="
  [mod."github.com/mailru/easyjson"]
    version = "v0.7.7"
    hash = "sha256-NVCz8MURpxgOjHXqxOZExqV4bnpHggpeAOyZDArjcy4="
  [mod."github.com/samber/lo"]
    version = "v1.47.0"
    hash = "sha256-jMXexVTlPdZ40STRpBLv7b+BIRqdxxra12Pl2Mj7Nz8="
  [mod."github.com/wk8/go-ordered-map/v2"]
    version = "v2.1.8"
    hash = "sha256-v7/5+7lAypZfgClXgWxhxtA1skQq9o+1yrI+V0o1j2o="
  [mod."golang.org/x/text"]
    version = "v0.24.0"
    hash = "sha256-qFbmteGOvJfvbLXiOSI8Fsz5Ixt2ZhSYx0/sIqApC7Y="
  [mod."gopkg.in/yaml.v3"]
    version = "v3.0.1"
    hash = "sha256-FqL9TKYJ0XkNwJFnq9j0VvJ5ZUU1RvH/52h/f5bkYAU="
</file>

<file path="src/codegen/go-schema-kcl/main.go">
package main

import (
	"context"
	"encoding/json"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"time"

	frpv1 "github.com/fatedier/frp/pkg/config/v1"
	"github.com/invopop/jsonschema"
)

type SchemaTarget struct {
	Dir             string            // Directory to output schema to
	Filename        string            // Schema filename
	Example         interface{}       // Go struct to reflect into JSON Schema
	PatchProperties map[string]string // Map of "Schema.Property" -> patch type (e.g., "array<any>")
}

func generateSchema(filepath string, example interface{}, patch map[string]string) error {
	schema := jsonschema.Reflect(example)

	rawBytes, err := json.Marshal(schema)
	if err != nil {
		return fmt.Errorf("marshal schema: %w", err)
	}

	var normalized map[string]interface{}
	if err := json.Unmarshal(rawBytes, &normalized); err != nil {
		return fmt.Errorf("unmarshal deduplication: %w", err)
	}

	// Support both $defs (JSON Schema 2020-12) and definitions (older drafts)
	defsKey := "$defs"
	if _, ok := normalized["definitions"]; ok {
		defsKey = "definitions"
	}

	defs, ok := normalized[defsKey].(map[string]interface{})
	if !ok {
		return fmt.Errorf("could not find definitions under %q", defsKey)
	}

	// üîß Apply patches using Schema.Property format
	for patchPath, patchType := range patch {
		parts := strings.Split(patchPath, ".")
		if len(parts) != 2 {
			fmt.Fprintf(os.Stderr, "‚ö†Ô∏è Invalid patch key format (use Schema.Property): %q\n", patchPath)
			continue
		}
		schemaName := parts[0]
		propName := parts[1]

		targetSchema, ok := defs[schemaName].(map[string]interface{})
		if !ok {
			fmt.Fprintf(os.Stderr, "‚ö†Ô∏è Schema %q not found\n", schemaName)
			continue
		}

		props, ok := targetSchema["properties"].(map[string]interface{})
		if !ok {
			fmt.Fprintf(os.Stderr, "‚ö†Ô∏è Schema %q has no properties\n", schemaName)
			continue
		}

		switch patchType {
		case "any":
			props[propName] = map[string]interface{}{}
		case "array<any>":
			props[propName] = map[string]interface{}{
				"type":  "array",
				"items": map[string]interface{}{},
			}
		case "object<any>":
			props[propName] = map[string]interface{}{
				"type":                 "object",
				"additionalProperties": map[string]interface{}{},
			}
		default:
			fmt.Fprintf(os.Stderr, "‚ö†Ô∏è Unknown patch type: %s for %s\n", patchType, patchPath)
		}
	}

	file, err := os.Create(filepath)
	if err != nil {
		return fmt.Errorf("create file: %w", err)
	}
	defer file.Close()

	encoder := json.NewEncoder(file)
	encoder.SetIndent("", "  ")
	if err := encoder.Encode(normalized); err != nil {
		return fmt.Errorf("write schema: %w", err)
	}
	return nil
}

func runCommand(name string, args []string, dir string) error {
	fmt.Printf("üöÄ Running: %s %v in %s\n", name, args, dir)
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	cmd := exec.CommandContext(ctx, name, args...)
	cmd.Dir = dir
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr

	if err := cmd.Run(); err != nil {
		return fmt.Errorf("command %s %v failed: %w", name, args, err)
	}
	return nil
}

func runKCLModInit(dir string) error {
	return runCommand("kcl", []string{"mod", "init"}, dir)
}

func runKCLImport(schemaFile, dir string) error {
	return runCommand("kcl", []string{"import", "-m", "jsonschema", schemaFile, "--force"}, dir)
}

func removeMainK(dir string) error {
	mainK := filepath.Join(dir, "main.k")
	if err := os.Remove(mainK); err != nil && !os.IsNotExist(err) {
		return fmt.Errorf("remove main.k: %w", err)
	}
	return nil
}

func ensureDir(dir string) error {
	return os.MkdirAll(dir, 0755)
}

func handleSchema(target SchemaTarget) error {
	fmt.Printf("üì¶ Starting %s...\n", target.Dir)

	fmt.Println("üîß ensureDir")
	if err := ensureDir(target.Dir); err != nil {
		return err
	}

	fmt.Println("üîß runKCLModInit")
	if err := runKCLModInit(target.Dir); err != nil {
		return err
	}

	fmt.Println("üîß removeMainK")
	if err := removeMainK(target.Dir); err != nil {
		return err
	}

	fmt.Println("üß¨ generateSchema")
	schemaPath := filepath.Join(target.Dir, target.Filename)
	if err := generateSchema(schemaPath, target.Example, target.PatchProperties); err != nil {
		return err
	}

	fmt.Println("üì• runKCLImport")
	if err := runKCLImport(target.Filename, target.Dir); err != nil {
		return err
	}

	fmt.Printf("‚úÖ Done with %s\n", target.Dir)
	return nil
}

func main() {
	targets := []SchemaTarget{
		{
			Dir:      "frp_schema/frpc",
			Filename: "frpcschema.json",
			Example:  &frpv1.ClientConfig{},
			PatchProperties: map[string]string{
				"ClientConfig.proxies":  "array<any>",
				"ClientConfig.visitors": "array<any>",
			},
		},
		{
			Dir:      "frp_schema/frps",
			Filename: "frpsschema.json",
			Example:  &frpv1.ServerConfig{},
		},
		{
			Dir:      "frp_schema/frpc/tcp_proxy",
			Filename: "tcp_proxy.schema.json",
			Example:  &frpv1.TCPProxyConfig{},
		},
	}

	for _, target := range targets {
		if err := handleSchema(target); err != nil {
			fmt.Fprintf(os.Stderr, "‚ùå Error generating %s: %v\n", target.Dir, err)
		}
	}
}
</file>

<file path="toolchains/gomod2nix.nix">
{
  nixpkgs,
  gomod2nix,
}:

let
  lib = nixpkgs.lib;
  forAllSystems = lib.genAttrs lib.systems.flakeExposed;
in
{
  goPackages = forAllSystems (
    system:
    let
      pkgs = import nixpkgs {
        inherit system;
        overlays = [ gomod2nix.overlays.default ];
      };
    in
    {
      inherit (pkgs)
        go
        gopls
        delve
        gomod2nix
        ;
    }
  );

  buildGoBinary =
    {
      system,
      src,
      pname,
      version ? "0.1.0",
    }:
    let
      pkgs = import nixpkgs {
        inherit system;
        overlays = [ gomod2nix.overlays.default ];
      };
    in
    pkgs.buildGoApplication {
      inherit pname version src;
      modules = ../src/codegen/go-schema-kcl/gomod2nix.toml;
    };
}
</file>

<file path="toolchains/uv2nix.nix">
{
  nixpkgs,
  pyproject-nix,
  uv2nix,
  pyproject-build-systems,
}:

let
  lib = nixpkgs.lib;
  forAllSystems = lib.genAttrs lib.systems.flakeExposed;

  # Load workspace from toolchains/
  workspace = uv2nix.lib.workspace.loadWorkspace {
    workspaceRoot = ./venv;
  };

  overlay = workspace.mkPyprojectOverlay {
    sourcePreference = "wheel";
  };

  editableOverlay = workspace.mkEditablePyprojectOverlay {
    root = "$REPO_ROOT";
  };

  pythonSets = forAllSystems (
    system:
    let
      pkgs = nixpkgs.legacyPackages.${system};
      python = pkgs.python3;
    in
    (pkgs.callPackage pyproject-nix.build.packages {
      inherit python;
    }).overrideScope
      (
        lib.composeManyExtensions [
          pyproject-build-systems.overlays.wheel
          overlay
        ]
      )
  );
in
{
  inherit
    workspace
    overlay
    editableOverlay
    pythonSets
    ;
}
</file>

<file path="schemas/crds/cert-manager/crds/Kptfile">
apiVersion: kpt.dev/v1
kind: Kptfile
metadata:
  name: crds
upstream:
  type: git
  git:
    repo: https://github.com/cert-manager/cert-manager
    directory: /deploy/crds
    ref: master
  updateStrategy: resource-merge
upstreamLock:
  type: git
  git:
    repo: https://github.com/cert-manager/cert-manager
    directory: /deploy/crds
    ref: master
    commit: c130e536a52918773fc9d13bac63e4733f11f9c7
</file>

<file path="schemas/crds/cert-manager/crds/README.md">
# CRDs source directory

> **WARNING**: if you are an end-user, you probably should NOT need to use the
> files in this directory. These files are for **reference, development and testing purposes only**.

This directory contains 'source code' used to build our CustomResourceDefinition
resources consumed by our officially supported deployment methods (e.g. the Helm chart).
The CRDs in this directory might be incomplete, and should **NOT** be used to provision the operator.
</file>

<file path="schemas/crds/cert-manager/Kptfile">
apiVersion: kpt.dev/v1
kind: Kptfile
metadata:
  name: cert-manager
upstream:
  type: git
  git:
    repo: https://github.com/cert-manager/cert-manager
    directory: /deploy/crds
    ref: master
  updateStrategy: resource-merge
upstreamLock:
  type: git
  git:
    repo: https://github.com/cert-manager/cert-manager
    directory: /deploy/crds
    ref: master
    commit: 227989f2eb6dac9892695d63d5b90e307d2f2c8b
</file>

<file path="schemas/crds/cert-manager/README.md">
# CRDs source directory

> **WARNING**: if you are an end-user, you probably should NOT need to use the
> files in this directory. These files are for **reference, development and testing purposes only**.

This directory contains 'source code' used to build our CustomResourceDefinition
resources consumed by our officially supported deployment methods (e.g. the Helm chart).
The CRDs in this directory might be incomplete, and should **NOT** be used to provision the operator.
</file>

<file path="schemas/crds/crossplane/Kptfile">
apiVersion: kpt.dev/v1
kind: Kptfile
metadata:
  name: crossplane
upstream:
  type: git
  git:
    repo: https://github.com/crossplane/crossplane
    directory: /cluster/crds
    ref: main
  updateStrategy: resource-merge
upstreamLock:
  type: git
  git:
    repo: https://github.com/crossplane/crossplane
    directory: /cluster/crds
    ref: main
    commit: f8545480c9486628b65457292808d4f84ff2dcda
</file>

<file path="schemas/crds/crossplane-kcl-function/Kptfile">
apiVersion: kpt.dev/v1
kind: Kptfile
metadata:
  name: crossplane-kcl-function
upstream:
  type: git
  git:
    repo: https://github.com/crossplane-contrib/function-kcl
    directory: /package/input
    ref: main
  updateStrategy: resource-merge
upstreamLock:
  type: git
  git:
    repo: https://github.com/crossplane-contrib/function-kcl
    directory: /package/input
    ref: main
    commit: 666b5f0cd77f97169866b65a5af45e5b6a64f2c8
</file>

<file path="schemas/crds/crossplane-patch-and-transform/Kptfile">
apiVersion: kpt.dev/v1
kind: Kptfile
metadata:
  name: crossplane-patch-and-transform
upstream:
  type: git
  git:
    repo: https://github.com/crossplane-contrib/function-patch-and-transform
    directory: /package/input
    ref: main
  updateStrategy: resource-merge
upstreamLock:
  type: git
  git:
    repo: https://github.com/crossplane-contrib/function-patch-and-transform
    directory: /package/input
    ref: main
    commit: 44e715ea9fb8c907e3214dc8efadaf28c9066bfb
</file>

<file path="schemas/crds/crossplane-sequencer/Kptfile">
apiVersion: kpt.dev/v1
kind: Kptfile
metadata:
  name: crossplane-sequencer
upstream:
  type: git
  git:
    repo: https://github.com/crossplane-contrib/function-sequencer
    directory: /package/input
    ref: main
  updateStrategy: resource-merge
upstreamLock:
  type: git
  git:
    repo: https://github.com/crossplane-contrib/function-sequencer
    directory: /package/input
    ref: main
    commit: 92253c0fcd9738b90cb689073f583d64c5daea59
</file>

<file path="schemas/crds/digitalocean/Kptfile">
apiVersion: kpt.dev/v1
kind: Kptfile
metadata:
  name: digitalocean
upstream:
  type: git
  git:
    repo: https://github.com/crossplane-contrib/provider-upjet-digitalocean
    directory: /package/crds
    ref: main
  updateStrategy: resource-merge
upstreamLock:
  type: git
  git:
    repo: https://github.com/crossplane-contrib/provider-upjet-digitalocean
    directory: /package/crds
    ref: main
    commit: 571a2fa00abe886c23896677d80873b97121101c
</file>

<file path="schemas/crds/fluxcd-helm/Kptfile">
apiVersion: kpt.dev/v1
kind: Kptfile
metadata:
  name: fluxcd-helm
upstream:
  type: git
  git:
    repo: https://github.com/fluxcd/helm-controller
    directory: /config/crd/bases
    ref: main
  updateStrategy: resource-merge
upstreamLock:
  type: git
  git:
    repo: https://github.com/fluxcd/helm-controller
    directory: /config/crd/bases
    ref: main
    commit: 2d233744ab4f91f2f5aecbe0c24d71504ca93caf
</file>

<file path="schemas/crds/fluxcd-kustomize/Kptfile">
apiVersion: kpt.dev/v1
kind: Kptfile
metadata:
  name: fluxcd-kustomize
upstream:
  type: git
  git:
    repo: https://github.com/fluxcd/kustomize-controller
    directory: /config/crd/bases
    ref: main
  updateStrategy: resource-merge
upstreamLock:
  type: git
  git:
    repo: https://github.com/fluxcd/kustomize-controller
    directory: /config/crd/bases
    ref: main
    commit: 0b68a4569ec40e536f216034ac59f32c90416d41
</file>

<file path="schemas/crds/fluxcd-source/Kptfile">
apiVersion: kpt.dev/v1
kind: Kptfile
metadata:
  name: fluxcd-source
upstream:
  type: git
  git:
    repo: https://github.com/fluxcd/source-controller
    directory: /config/crd/bases
    ref: main
  updateStrategy: resource-merge
upstreamLock:
  type: git
  git:
    repo: https://github.com/fluxcd/source-controller
    directory: /config/crd/bases
    ref: main
    commit: eae8f25c2b44defd83765b764cb680aa07fdc640
</file>

<file path="schemas/crds/BUCK">
load("//src/codegen/cloudcoil:python_codegen_rule.bzl", "python_codegen")
load("//schemas/crds:crd_codegen_groups.bzl", "crd_codegen_from_tree")

ALL_CRDS = glob(["**/*.yaml", "**/*.yml"])

GENERATORS = crd_codegen_from_tree(
    name_prefix = "gen",
    srcs = ALL_CRDS,
    namespace_prefix = "generated.models",
)

filegroup(
    name = "generated_srcs",
    srcs = GENERATORS,
    visibility = ["PUBLIC"],
)
</file>

<file path="schemas/crds/crd_codegen_groups.bzl">
load("//src/codegen/cloudcoil:python_codegen_rule.bzl", "python_codegen")

def crd_codegen_from_tree(
    *,
    name_prefix,
    srcs,
    namespace_prefix,
):
    """
    Split a flat list of CRD YAML files into multiple python_codegen targets
    based on their top-level directory.

    This is *deliberately* done at analysis time so Buck can:
      - parallelize code generation across CRD groups
      - cache each group independently
      - avoid one large CRD blocking all others

    Example:
      srcs = [
        "cert-manager/foo.yaml",
        "cert-manager/bar.yaml",
        "fluxcd-source/baz.yaml",
      ]

      =>
      python_codegen(
        name = "gen_cert_manager",
        srcs = [...],
        namespace = "generated.models.cert_manager",
      )

      python_codegen(
        name = "gen_fluxcd_source",
        srcs = [...],
        namespace = "generated.models.fluxcd_source",
      )
    """

    # Map of <top-level-dir> -> [list of yaml files]
    groups = {}

    for src in srcs:
        # src is a string path like "cert-manager/foo/bar.yaml"
        # We intentionally only look at the first path segment
        # to define a "CRD group".
        top = src.split("/")[0]
        groups.setdefault(top, []).append(src)

    targets = []

    for group, group_srcs in groups.items():
        # Buck target names and Python module names cannot contain '-'
        safe = group.replace("-", "_")

        # Use the CRD name directly as the target name
        name = safe

        python_codegen(
            name = name,
            srcs = group_srcs,
            namespace = safe,
        )

        targets.append(":{}".format(name))


    return targets
</file>

<file path="src/codegen/cloudcoil/templates/BaseModel.jinja2">
{% for decorator in decorators -%}
{{ decorator }}
{% endfor -%}
{%- if is_list %}
{{ class_name }} = ResourceList["{{ class_name.replace('List', '') }}"]
{%- else %}
{%- if is_gvk %}
class {{ class_name }}(Resource):{% if comment is defined %}  # {{ comment }}{% endif %}
{%- else %}
class {{ class_name }}(BaseModel):{% if comment is defined %}  # {{ comment }}{% endif %}
{%- endif %}
{%- if description %}
    """
    {{ description | replace("\t", " "*4) | trim | indent(4) }}
    """
{%- endif %}

    class Builder(BaseModelBuilder):

        @property
        def cls(self) -> Type["{{ class_name }}"]:
            return {{ class_name }}
            
        def build(self) -> "{{ class_name }}":
            return {{ class_name }}(**self._attrs)

    {%- for field in fields %}
        {%- set field_setter_name = field.name if field.name != "build" else "build_" %}
        {%- if field.data_type.data_types and field.data_type.data_types[0].is_list  %}
        {%- set item_type = field.data_type.data_types[0].data_types[0] %}
        {%- if item_type.reference is not none %}
        @overload
        def {{ field_setter_name }}(self, value_or_callback: List[{{ item_type.type_hint }}], /) -> "{{ class_name }}.Builder": ...
        
        @overload
        def {{ field_setter_name }}(self, value_or_callback: Callable[[GenericListBuilder[{{ item_type.type_hint }}, {{ item_type.type_hint }}.Builder]], GenericListBuilder[{{ item_type.type_hint }}, {{ item_type.type_hint }}.Builder] | List[{{ item_type.type_hint }}]], /) -> "{{ class_name }}.Builder": ...
        
        @overload
        def {{ field_setter_name }}(self, value_or_callback: Never = ...) -> ListBuilderContext[{{ item_type.type_hint }}.Builder]: ...
        
        def {{ field_setter_name }}(self, value_or_callback=None, /):
            {%- if field.docstring %}
            """
            {{ field.docstring | replace("\t", " "*4) | trim | indent(12) }}
            """
            {%- endif %}
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[{{ item_type.type_hint }}.Builder]()
                context._parent_builder = self
                context._field_name = "{{ field.name }}"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback({{ item_type.type_hint }}.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("{{ field.name }}", value)
        {%- else %}
        def {{ field_setter_name }}(self, value: {{ field.type_hint }}, /) -> Self:
            {%- if field.docstring %}
            """
            {{ field.docstring | replace("\t", " "*4) | trim | indent(12) }}
            """
            {%- endif %}
            return self._set("{{ field.name }}", value)
        {%- endif %}
        {%- else %}
        {%- if field.data_type.reference is not none %}
        @overload
        def {{ field_setter_name }}(self, value_or_callback: {{ field.type_hint }}, /) -> "{{ class_name }}.Builder": ...
        
        @overload
        def {{ field_setter_name }}(self, value_or_callback: Callable[[{{ field.data_type.type_hint }}.Builder], {{ field.data_type.type_hint }}.Builder | {{ field.data_type.type_hint }}], /) -> "{{ class_name }}.Builder": ...
        
        @overload
        def {{ field_setter_name }}(self, value_or_callback: Never = ...) -> "{{ field.data_type.type_hint }}.BuilderContext": ...
        
        def {{ field_setter_name }}(self, value_or_callback=None, /):
            {%- if field.docstring %}
            """
            {{ field.docstring | replace("\t", " "*4) | trim | indent(12) }}
            """
            {%- endif %}
            if self._in_context and value_or_callback is None:
                context = {{ field.data_type.type_hint }}.BuilderContext()
                context._parent_builder = self
                context._field_name = "{{ field.name }}"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback({{ field.data_type.type_hint }}.builder())
                if isinstance(output, {{ field.data_type.type_hint }}.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("{{ field.name }}", value)
        {%- else %}
        def {{ field_setter_name }}(self, value: {{ field.type_hint }}, /) -> Self:
            {%- if field.docstring %}
            """
            {{ field.docstring | replace("\t", " "*4) | trim | indent(12) }}
            """
            {%- endif %}
            return self._set("{{ field.name }}", value)
        {%- endif %}
        {%- endif %}
    {%- endfor %}

    class BuilderContext(BuilderContextBase["{{ class_name }}.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = {{ class_name }}.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()
        
    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for {{ class_name }}."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["{{class_name}}", Builder]):
        def __init__(self):
            raise NotImplementedError("This class is not meant to be instantiated. Use {{ class_name }}.list_builder() instead.")

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

{%- if not fields and not description %}
    pass
{%- endif %}
{%- if config %}
{%- filter indent(4) %}
{% include 'ConfigDict.jinja2' %}
{%- endfilter %}
{%- endif %}
{%- for field in fields -%}
    {%- if not field.annotated and field.field %}
    {{ field.name }}: {{ field.type_hint }} = {{ field.field }}
    {%- else %}
    {%- if field.annotated %}
    {{ field.name }}: {{ field.annotated }}
    {%- else %}
    {{ field.name }}: {{ field.type_hint }}
    {%- endif %}
    {%- if not (field.required or (field.represented_default == 'None' and field.strip_default_none)) or field.data_type.is_optional
            %} = {% if field.represented_default == "{}" and field.data_type.reference is not none %}{{ field.data_type.type_hint }}.model_validate({{ field.represented_default }}){% else %}{{ field.represented_default }}{% endif %}
    {%- endif -%}
    {%- endif %}
    {%- if field.docstring %}
    """
    {{ field.docstring | replace("\t", " "*4) | trim | indent(4) }}
    """
    {%- endif %}
{%- for method in methods -%}
    {{ method }}
{%- endfor -%}
{%- endfor -%}
{%- endif -%}
</file>

<file path="src/codegen/cloudcoil/templates/ConfigDict.jinja2">
{% if extra_fields %}
model_config = ConfigDict(extra="{{ extra_fields }}")
{% endif %}
</file>

<file path="src/codegen/cloudcoil/templates/RootModel.jinja2">
{%- macro get_type_hint(_fields) -%}
{%- if _fields -%}
{{- _fields[0].type_hint}}
{%- endif -%}
{%- endmacro -%}

{% for decorator in decorators -%}
{{ decorator }}
{% endfor -%}

class {{ class_name }}({{ base_class }}{%- if fields -%}[{{get_type_hint(fields)}}]{%- endif -%}):{% if comment is defined %}  # {{ comment }}{% endif %}
{%- if description %}
    """
    {{ description | replace("\t", " "*4) | trim | indent(4) }}
    """
{%- endif %}

{%- if config %}
{%- filter indent(4) %}
{% include 'ConfigDict.jinja2' %}
{%- endfilter %}
{%- endif %}
{%- if not fields and not description %}
    class Builder(BaseBuilder):
        @property
        def cls(self) -> Type["{{ class_name }}"]:
            return {{ class_name }}
        def build(self) -> "{{ class_name }}":
            return {{ class_name }}()
{%- else %}
    {%- set field = fields[0] %}
    class Builder(BaseBuilder):
        _value: {{ field.type_hint }} | None = None

        def root(self, value: {{ field.type_hint }}, /) -> Self:
            {%- if field.docstring %}
            """
            {{ field.docstring | replace("\t", " "*4) | trim | indent(12) }}
            """
            {%- endif %}
            self._value = value
            return self

        def __call__(self, value: {{ field.type_hint }}, /) -> Self:
            {%- if field.docstring %}
            """
            {{ field.docstring | replace("\t", " "*4) | trim | indent(12) }}
            """
            {%- endif %}
            self._value = value
            return self

        def build(self) -> "{{ class_name }}":
            value = cast({{ field.type_hint }}, self._value)
            return {{ class_name }}(value)

    {%- if not field.annotated and field.field %}
    root: {{ field.type_hint }} = {{ field.field }}
    {%- else %}
    {%- if field.annotated %}
    root: {{ field.annotated }}
    {%- else %}
    root: {{ field.type_hint }}
    {%- endif %}
    {%- if not (field.required or (field.represented_default == 'None' and field.strip_default_none))
            %} = {{ field.represented_default }}
    {%- endif -%}
    {%- endif %}
    {%- if field.docstring %}
    """
    {{ field.docstring | replace("\t", " "*4) | trim | indent(4) }}
    """
    {%- endif %}
{%- endif %}
    class BuilderContext(BuilderContextBase["{{ class_name }}.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = {{ class_name }}.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for {{ class_name }}."""
        return cls.BuilderContext()
</file>

<file path="src/codegen/cloudcoil/BUCK">
python_bootstrap_library(
    name = "codegen_templates",
    srcs = glob(["templates/**"]),
    visibility = ["PUBLIC"],
)

python_bootstrap_binary(
    name = "codegen",
    main = "main.py",
    deps = [
        ":codegen_templates",
    ],
    visibility = ["PUBLIC"],
)
</file>

<file path="src/codegen/cloudcoil/main.py">
import re
import shutil
import sys
from importlib.resources import as_file, files
from pathlib import Path
from typing import List

import typer
from cloudcoil.codegen.generator import ModelConfig, Transformation, generate

app = typer.Typer()

ROOT = Path(__file__).parent
TEMPLATE_DIR = ROOT / "templates"


def build_model_config(
    namespace: str, inputs: List[str], output_dir: Path
) -> ModelConfig:
    return ModelConfig(
        namespace=namespace,
        input_=inputs,
        output=output_dir,
        mode="resource",
        log_level="INFO",
        transformations=[
            Transformation(
                match_=re.compile(
                    r"^io\.k8s\.apimachinery\.pkg\.apis\.meta\.v1\.ObjectMeta$"
                ),
                replace="apimachinery.ObjectMeta",
                namespace="cloudcoil",
            )
        ],
        additional_datamodel_codegen_args=[
            "--custom-template-dir",
            str(TEMPLATE_DIR.absolute()),
        ],
        generate_init=True,
        generate_py_typed=True,
    )


def clean_output_dir(output: Path, clean: bool):
    if clean and output.exists():
        shutil.rmtree(output)
    output.mkdir(parents=True, exist_ok=True)


@app.command()
def main(
    namespace: str = typer.Argument(...),
    input: List[str] = typer.Option(..., "--input", "-i"),
    output: Path = typer.Option(..., "--output", "-o"),
    clean: bool = typer.Option(False, "--clean"),
):
    clean_output_dir(output, clean)

    config = build_model_config(namespace, input, output)
    try:
        generate(config)
    except Exception as e:
        raise SystemExit(1)


if __name__ == "__main__":
    app()
</file>

<file path="src/codegen/cloudcoil/python_codegen_rule.bzl">
def _python_codegen_impl(ctx):
    """
    Implementation of the python_codegen rule.

    This rule:
      - takes CRD YAML files as inputs
      - runs the codegen CLI exactly once
      - produces a directory of generated Python sources

    The rule is intentionally minimal and hermetic:
      - no Python toolchain
      - no implicit runtime deps
      - everything happens inside a single Buck action
    """

    # Each codegen target writes to its *own* output directory.
    # Using ctx.label.name avoids collisions when many generators exist.
    out = ctx.actions.declare_output(ctx.label.name, dir=True)

    # Executable tool (python_bootstrap_binary)
    codegen = ctx.attrs._codegen[RunInfo]

    # Ruff is only used to get its bin directory on PATH
    ruff = ctx.attrs._ruff[RunInfo]

    # Build CLI arguments for the codegen tool
    args = cmd_args()
    args.add(ctx.attrs.namespace)

    # Add each CRD file as --input <file>
    # Buck tracks these as action inputs automatically.
    for f in ctx.attrs.srcs:
        args.add("--input", f)

    # Tell the generator where to write files
    args.add("--output", out.as_output())

    # Ensure deterministic output by wiping the directory
    args.add("--clean")

    # We intentionally run through bash so we can:
    #   - prepend ruff to PATH
    #   - avoid Buck's stricter ctx.actions.run argument rules
    shell_cmd = cmd_args(
        [
            "bash",
            "-e",   # fail fast on errors
            "-c",
            cmd_args(
                [
                    # Put ruff on PATH, then invoke the codegen binary
                    "PATH=$(dirname ",
                    cmd_args(ruff, format="{}"),
                    "):$PATH;",
                    codegen,
                    args,
                ],
                delimiter=" "
            ),
        ]
    )

    # Register the action with Buck
    ctx.actions.run(
        shell_cmd,
        category="python_codegen"
    )

    # Expose the generated directory as the rule output
    return [DefaultInfo(default_outputs=[out])]


# Public rule wrapper
python_codegen = rule(
    impl = _python_codegen_impl,
    attrs = {
        # Input CRD YAML files
        "srcs": attrs.list(attrs.source(), default=[]),

        # Python namespace for generated models
        "namespace": attrs.string(),

        # Codegen executable (bootstrap binary)
        "_codegen": attrs.exec_dep(default="//src/codegen/cloudcoil:codegen"),

        # Ruff binary (used only for PATH injection)
        "_ruff": attrs.exec_dep(default="toolchains//:ruff"),
    },
)
</file>

<file path="src/lib/BUCK">
python_bootstrap_binary(
    name = "test",
    main = "main.py"
)
</file>

<file path="src/lib/main.py">
from cloudcoil.codegen.generator import ModelConfig, Transformation, generate

print("this module imports generator")
</file>

<file path="tests/tests/test_basic.py">
from generated.fluxcd_helm.fluxcd_helm.io.fluxcd.toolkit.helm.v2 import HelmRelease


def test_basic(dummy):
    print("Contents of instantiated generated helmrelease: ")
    print(HelmRelease)
    assert dummy == "hello from fixture"
</file>

<file path="tests/BUCK">
python_bootstrap_binary(
    name = "test",
    main = "run_pytest.py",
)
</file>

<file path="tests/conftest.py">
import pytest


@pytest.fixture
def dummy():
    return "hello from fixture"
</file>

<file path="tests/run_pytest.py">
import sys

import pytest

if __name__ == "__main__":
    raise SystemExit(pytest.main(sys.argv[1:]))
</file>

<file path="toolchains/flake.lock">
{
  "nodes": {
    "buck2-nix": {
      "flake": false,
      "locked": {
        "lastModified": 1756462063,
        "narHash": "sha256-FIGJSsPLYmQCVU620vD6t2uVg84G2YEWQzahJO00kVY=",
        "owner": "tweag",
        "repo": "buck2.nix",
        "rev": "038b031b84846101030b9d081445003e82e3be5c",
        "type": "github"
      },
      "original": {
        "owner": "tweag",
        "repo": "buck2.nix",
        "type": "github"
      }
    },
    "nixpkgs": {
      "locked": {
        "lastModified": 1764950072,
        "narHash": "sha256-BmPWzogsG2GsXZtlT+MTcAWeDK5hkbGRZTeZNW42fwA=",
        "owner": "nixos",
        "repo": "nixpkgs",
        "rev": "f61125a668a320878494449750330ca58b78c557",
        "type": "github"
      },
      "original": {
        "owner": "nixos",
        "ref": "nixos-unstable",
        "repo": "nixpkgs",
        "type": "github"
      }
    },
    "pyproject-build-systems": {
      "inputs": {
        "nixpkgs": [
          "nixpkgs"
        ],
        "pyproject-nix": [
          "pyproject-nix"
        ],
        "uv2nix": [
          "uv2nix"
        ]
      },
      "locked": {
        "lastModified": 1763662255,
        "narHash": "sha256-4bocaOyLa3AfiS8KrWjZQYu+IAta05u3gYZzZ6zXbT0=",
        "owner": "pyproject-nix",
        "repo": "build-system-pkgs",
        "rev": "042904167604c681a090c07eb6967b4dd4dae88c",
        "type": "github"
      },
      "original": {
        "owner": "pyproject-nix",
        "repo": "build-system-pkgs",
        "type": "github"
      }
    },
    "pyproject-nix": {
      "inputs": {
        "nixpkgs": [
          "nixpkgs"
        ]
      },
      "locked": {
        "lastModified": 1764134915,
        "narHash": "sha256-xaKvtPx6YAnA3HQVp5LwyYG1MaN4LLehpQI8xEdBvBY=",
        "owner": "pyproject-nix",
        "repo": "pyproject.nix",
        "rev": "2c8df1383b32e5443c921f61224b198a2282a657",
        "type": "github"
      },
      "original": {
        "owner": "pyproject-nix",
        "repo": "pyproject.nix",
        "type": "github"
      }
    },
    "root": {
      "inputs": {
        "buck2-nix": "buck2-nix",
        "nixpkgs": "nixpkgs",
        "pyproject-build-systems": "pyproject-build-systems",
        "pyproject-nix": "pyproject-nix",
        "uv2nix": "uv2nix"
      }
    },
    "uv2nix": {
      "inputs": {
        "nixpkgs": [
          "nixpkgs"
        ],
        "pyproject-nix": [
          "pyproject-nix"
        ]
      },
      "locked": {
        "lastModified": 1764992234,
        "narHash": "sha256-qBbyM1Gnvs/ncbnWfbBboMyevelz+owIdSN5Sg89wzw=",
        "owner": "pyproject-nix",
        "repo": "uv2nix",
        "rev": "1610e554e579c3d47b47c8a32d47042116d0e153",
        "type": "github"
      },
      "original": {
        "owner": "pyproject-nix",
        "repo": "uv2nix",
        "type": "github"
      }
    }
  },
  "root": "root",
  "version": 7
}
</file>

<file path=".buckconfig">
[cells]
  root = .
  prelude = prelude
  toolchains = toolchains
  hsconfig = config
  none = none
  nix = none

[cell_aliases]
  config = prelude
  ovr_config = prelude
  fbcode = none
  fbsource = none
  fbcode_macros = none
  buck = none

[external_cells]
  prelude = bundled
  nix = git

[parser]
  target_platform_detector_spec = target:root//...->prelude//platforms:default

[project]
  ignore = .git, tmp

[buck2]
  materializations = deferred
</file>

<file path="notes">
alright buster. Cloudcoils shit design is kicking your ass again. Cloudcoil inside

https://github.com/cloudcoil/cloudcoil/blob/main/cloudcoil/codegen/templates/pydantic_v2/BaseModel.jinja2

imports ConfigDict.jinja2.. which isnt even commited to its source

thats why you were generating it earlier, not just because you wanted extra fields
because its required in order for the generator to run.. and there are no examples
in cloudcoils source of even using this file.. cooooooool. What an ass lib.

buck2 and nix (nixes uv2nix venv) is readonly so we cant just do this 

tmpl_dir = Path(str(files("cloudcoil.codegen"))) / "templates" / "pydantic_v2"

as we did in the old one. And write the jinja to it. 


Your gonna need to experiment with gpt to figure out how to address that. Night bro.
</file>

<file path="pytest.ini">
[pytest]
addopts = --ignore=idlelib
testpaths = tests
</file>

<file path="toolchains/BUCK">
load("@nix//:flake.bzl", "flake")
load("@nix//toolchains:python.bzl", "nix_python_bootstrap_toolchain")

_TARGET_MAPPING = [
    select({k: k for k in ["config//os:linux", "config//os:macos"]}),
    select({k: k for k in ["config//cpu:arm64", "config//cpu:x86_64"]}),
]

flake.package(
    name = "python",
    binary = "python",
    package = "default",
    path = ".",
    target_compatible_with = _TARGET_MAPPING,
)

nix_python_bootstrap_toolchain(
    name = "python_bootstrap",
    python = ":python",
    visibility = ["PUBLIC"],
)


flake.package(
    name = "ruff",
    path = ".",
    package = "ruff",
    binary = "ruff",
    visibility = ["PUBLIC"],
)
</file>

<file path=".gitignore">
/buck-out
/.buckconfig.local
/.buckconfig.d/buck2-nix.config
/.envrc.private
/.direnv
/flake.lock
/.pytest_cache
__pycache__
generated/crds/**/*.yaml
tests/generated
</file>

<file path="flake.nix">
{
  description = "Buck2 + uv2nix project";

  inputs = {
    toolchains.url = "path:./toolchains";
  };

  outputs =
    { toolchains, ... }:
    {
      devShells = toolchains.outputs.devShells;
      packages = toolchains.outputs.packages;
    };
}
</file>

<file path="toolchains/flake.nix">
{
  description = "Buck2 + uv2nix project";

  inputs = {
    nixpkgs.url = "github:nixos/nixpkgs?ref=nixos-unstable";

    buck2-nix = {
      url = "github:tweag/buck2.nix";
      flake = false;
    };

    pyproject-nix = {
      url = "github:pyproject-nix/pyproject.nix";
      inputs.nixpkgs.follows = "nixpkgs";
    };

    uv2nix = {
      url = "github:pyproject-nix/uv2nix";
      inputs.pyproject-nix.follows = "pyproject-nix";
      inputs.nixpkgs.follows = "nixpkgs";
    };

    pyproject-build-systems = {
      url = "github:pyproject-nix/build-system-pkgs";
      inputs.pyproject-nix.follows = "pyproject-nix";
      inputs.uv2nix.follows = "uv2nix";
      inputs.nixpkgs.follows = "nixpkgs";
    };

    gomod2nix = {
      url = "github:nix-community/gomod2nix";
      inputs.nixpkgs.follows = "nixpkgs";
    };
  };

  outputs =
    inputs@{
      self,
      nixpkgs,
      buck2-nix,
      pyproject-nix,
      uv2nix,
      pyproject-build-systems,
      gomod2nix,
      ...
    }:
    let
      lib = nixpkgs.lib;
      forAllSystems = lib.genAttrs lib.systems.flakeExposed;

      uv = import ./uv2nix.nix {
        inherit
          nixpkgs
          pyproject-nix
          uv2nix
          pyproject-build-systems
          ;
      };

      go = import ./gomod2nix.nix {
        inherit nixpkgs gomod2nix;
      };
    in
    {
      devShells = forAllSystems (
        system:
        let
          pkgs = nixpkgs.legacyPackages.${system};
          pythonSet = uv.pythonSets.${system}.overrideScope uv.editableOverlay;
          virtualenv = pythonSet.mkVirtualEnv "home" uv.workspace.deps.all;
        in
        {
          default = pkgs.mkShell {
            packages = [
              virtualenv
              pkgs.uv
              pkgs.buck2

              # Go toolchain
              pkgs.go
              go.goPackages.${system}.gomod2nix
              self.packages.${system}.go-schema-kcl

              pkgs.kpt
              pkgs.kcl
            ];

            env = {
              UV_NO_SYNC = "1";
              UV_PYTHON = pythonSet.python.interpreter;
              UV_PYTHON_DOWNLOADS = "never";
            };

            shellHook = ''
              unset PYTHONPATH
              export REPO_ROOT=$(git rev-parse --show-toplevel)

              mkdir -p .buckconfig.d
              cat > .buckconfig.d/buck2-nix.config <<'EOS'
              [external_cell_nix]
                git_origin = https://github.com/tweag/buck2.nix.git
                commit_hash = ${buck2-nix.rev}
              EOS

              buck2 build root//schemas/crds:generated_srcs --out tests/generated
            '';
          };
        }
      );

      packages = forAllSystems (
        system:
        let
          pkgs = nixpkgs.legacyPackages.${system};
        in
        {
          default = uv.pythonSets.${system}.mkVirtualEnv "env" uv.workspace.deps.default;

          go-schema-kcl = go.buildGoBinary {
            inherit system;
            pname = "go-schema-kcl";
            src = ../src/codegen/go-schema-kcl;
          };

          # cloudcoil generation implicitly relies on this
          ruff = pkgs.ruff;
        }
      );
    };
}
</file>

</files>
